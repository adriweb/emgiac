\documentclass[12pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{xcolor}
\usepackage{color}
\usepackage{soul}
\usepackage[utf8]{inputenc}
\usepackage{makeidx}
\usepackage{ifpdf}
\ifpdf
 \usepackage[pdftex,colorlinks]{hyperref}
\else
 \usepackage[ps2pdf,
            breaklinks=true,
            colorlinks=true,
            linkcolor=red,
            citecolor=green
            ]{hyperref}
\fi
\newcommand{\N}{{\mathbb{N}}}
\newcommand{\Z}{{\mathbb{Z}}}
\newcommand{\Q}{{\mathbb{Q}}}
\newcommand{\R}{{\mathbb{R}}}
\newcommand{\bs}{\symbol{92}}
\makeindex
%\newcommand{\@hevea@cbrace}
%\usepackage[T1]{fontenc}
%\usepackage[francais]{babel}
%\newrgbcolor{fltk_color0}{1 0 0}
\author{Ren\'ee De Graeve \and Bernard Parisse}
\title{Algorithmique et programmation au Lyc\'ee}
\input{giacfr.tex}
\usepackage[auto]{mathjax}
\ifhevea
\renewcommand{\jax@meta}{\begin{rawhtml}<script language="javascript"> 
var ua = navigator.userAgent.toLowerCase();
if (ua.indexOf('firefox') === -1 && ua.indexOf('safari') === -1) {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML";
    document.getElementsByTagName("head")[0].appendChild(script);
}
</script>
\end{rawhtml}}
\fi
%HEVEA\renewcommand{\footertext}{}

\begin{document}
\begin{giacjshere}
\maketitle
\newpage
\tableofcontents
\newpage
\printindex 


\chapter{Introduction}
\section{Apprendre en programmant.}
Ce document est principalement destin\'e aux enseignants qui 
souhaitent utiliser Xcas pour enseigner l'algorithmique au lyc\'ee.
Nous esp\'erons qu'il sera aussi consult\'e par des \'el\`eves.
Dans sa version 
\footahref{http://www-fourier.ujf-grenoble.fr/\%7eparisse/irem/algoseconde.html}{HTML} consultable depuis un navigateur, certains champs de saisies peuvent 
\^etre modifi\'es et test\'es directement, y compris sur une tablette
ou un smartphone, ce qui devrait \^etre un plus par rapport
\`a un cours de programmation papier ou PDF (les fonctions ``utilitaires'' qui 
sont appel\'ees plusieurs fois par d'autres fonctions n'ont pas besoin 
d'\^etre valid\'ees par l'utilisateur, elles sont interpr\'et\'ees 
au chargement).

L'utilisation de {\tt Xcas} peut se faire depuis un terminal mobile (smartphone 
ou tablette) sans installation, il suffit d'ouvrir un navigateur (Firefox 
recommand\'e) et de suivre ce lien :\\
\ahref{http://www-fourier.ujf-grenoble.fr/\%7eparisse/xcasfr.html}{http://www-fourier.ujf-grenoble.fr/\~{\ }parisse/xcasfr.html}\\
(L'acc\`es r\'eseau est n\'ecessaire uniquement lors de la premi\`ere
consultation).\\
Il n'est donc pas indispensable d'aller en salle informatique
pour faire un exercice d'algorithmique pendant un cours de math\'ematiques, 
on peut utiliser les smartphones (en mode avion) 
ou les tablettes des \'el\`eves comme des super-calculatrices (formelles, 
graphiques, 3d, ... il ne manque que le mode examen...). C'est une
raison suppl\'ementaire pour \'ecrire ce document, car faire programmer 
les algorithmes par les \'el\`eves nous parait indispensable
pour les motiver par la satisfaction de faire tourner son
programme puis de le modifier et de l'am\'eliorer. 

On peut d'ailleurs regretter le nombre important d'exercices de baccalaur\'eat
qui demandent de comprendre ce que fait un algorithme non comment\'e.
Dans ce type d'exercices, l'\'el\`eve n'a aucun r\^ole cr\'eateur 
(il ne con\c{c}oit pas l'algorithme), il a un r\^ole analogue \`a
celui d'un professeur corrigeant des copies ce qui n'est pas du tout
motivant et a devant les yeux un mod\`ele d\'esastreux d'algorithme puisque
non comment\'e ! 
De plus, comprendre ce que fait un algorithme non
comment\'e est souvent plus difficile que d'en concevoir un, car les
notations de variables, par exemple, ne prennent souvent sens qu'une fois
l'algorithme compris. 
Imagine-t-on donner les \'etapes de calcul
d'une d\'emonstration, sans explications, et demander quel
est le th\'eor\`eme qui a \'et\'e d\'emontr\'e~?
Heureusement, d'autres exercices proposent
des maquettes d'algorithmes \`a compl\'eter ce qui est bien plus formateur.

\section{Le choix du langage de programmation}
Actuellement aucun langage n'est impos\'e en 2nde, 1\`ere et Terminale,
nous esp\'erons que cette situation va perdurer et que beaucoup
d'enseignants r\'esisteront aux pressions de certains de vouloir imposer
un langage unique (comme pour les enseignements obligatoires
d'informatique en classe pr\'eparatoires). Ainsi on peut
configurer {\tt Xcas} pour programmer avec des mots-clefs en fran\c{c}ais ou 
avec un style compatible avec {\tt Python, Maple, Mupad, ti89/92} (les 
personnes connaissant Python peuvent consulter l'appendice \ref{sec:python} 
qui d\'ecrit plus en d\'etails les diff\'erences entre Python et {\tt Xcas}).

La plupart des langages interpr\'et\'es permettent d'apprendre \`a programmer 
les concepts algorithmiques au programme du lyc\'ee (test, boucle,
variable, affectation, fonction). En effet, pour les \'el\`eves, la difficult\'e
principale ce sont les concepts algorithmiques, rarement la syntaxe du langage 
lui-m\^eme, car ils peuvent se faire aider par l'enseignant s'ils sont 
bloqu\'es. C'est donc aux enseignants qu'il revient de choisir un langage avec 
lequel ils sont \`a l'aise, non seulement pour \'ecrire eux-m\^emes un 
programme, mais aussi pour trouver rapidement une erreur de syntaxe ou 
d'ex\'ecution dans un programme d'un de leurs \'el\`eves. 

Pour la grande majorit\'e des \'el\`eves, il est probablement souhaitable 
qu'ils soient confront\'es lors des changements de professeur
\`a plusieurs langages au cours de leur scolarit\'e
(par exemple {\tt Xcas}, calculatrices, Python, Javascript ...),
ce qui leur permettra de mieux comprendre les concepts universels partag\'es 
(l'algorithmique) et les biais et particularit\'es propres \`a un langage 
donn\'e (voir en appendice), et facilitera aussi leur adaptation \`a d'autres 
langages. Pour ceux qui se destinent \`a des \'etudes scientifiques, il nous 
parait important qu'ils soient aussi confront\'es \`a d'autres types de langages
(compil\'es, fonctionnels ...) au cours de leurs \'etudes
dont au moins un langage de plus bas
niveau~: les langages interpr\'et\'es permettent d'utiliser
facilement des types ou instructions puissantes,
se confronter avec un langage de plus bas niveau permet
de mieux comprendre ce qui est basique ou ne l'est pas
et ce qui est intrins\`equement rapide ou/et couteux en ressource
m\'emoire ou ne l'est pas (on peut voir \c{c}a comme l'analogue entre
faire une d\'emonstration ou admettre un th\'eor\`eme).

{\bf Pourquoi choisir {\tt Xcas} ?}\\
{\tt Xcas} est fortement orient\'e math\'ematique et de ce fait
peut facilement interagir avec les th\`emes du programme de maths, tous
les types math\'ematiques au programme du lyc\'ee sont directement accessibles 
(par exemple : entiers et rationnels, nombres approch\'es r\'eels
et complexes, vecteurs, polyn\^omes et matrices). 
Le langage de programmation de {\tt Xcas} est proche du langage algorithmique
ce qui facilite ensuite sa traduction dans d'autre langage, y compris 
en syntaxe Python,
nous avons adapt\'e le langage en fran\c{c}ais pour en faciliter l'apprentissage
d'apr\`es notre exp\'erience d'enseignement avec des publics divers~:
\begin{itemize}
\item Les structures sont d\'elimit\'ees par des mots-clefs explicites 
en fran\c{c}ais \\
(\verb|si . alors . sinon . fsi|),\\
(\verb|pour . de . jusque . faire ... fpour|),\\
(\verb|tantque . faire ... ftantque|)...\\
L'indentation sert \`a controler qu'on n'a pas fait
de faute de syntaxe (non-fermeture d'une parenth\`ese par exemple).
Les diverses interfaces de {\tt Xcas} proposent des assistants
pour cr\'eer facilement les structures de controle usuelles 
(fonction, test, boucle).
\item Il faut d\'eclarer explicitement les variables locales, ainsi une
faute de frappe dans un nom de variable est d\'etect\'ee et un
avertissement est affich\'e si une variable n'est pas d\'eclar\'ee ou n'est pas
initialis\'ee.
\item Lorsqu'on programme une fonction, on peut lui passer en argument des 
variables qui sont de type fonction ou expression, ceci facilite l'\'ecriture 
de certains algorithmes (dichotomie, m\'ethode des rectangles par exemple).
\item Les th\`emes d'algorithmique abord\'es au lyc\'ee sont
presque toujours d\'ej\`a impl\'ement\'es dans une commande de {\tt Xcas}, 
ceci
permet de v\'erifier en comparant le r\'esultat de la fonction qu'on
vient de concevoir avec la commande interne.
\end{itemize}
L'engouement pour le langage Python, nous a amené \`a modifier 
{\tt Xcas} pour accepter \'egalement l'\'ecriture des programmes 
en syntaxe Python, mais en gommant certains pi\`eges du langage 
par rapport aux math\'ematiques~:
\begin{itemize}
\item on peut \'ecrire {\tt \verb|^|} pour la puissance, 
{\tt **} est \'egalement accept\'e
\item on peut \'ecrire comme en math\'ematiques {\tt 2a} (inutile de mettre 
le signe {\tt *}). Par contre il faut mettre le signe {\tt *}
dans {\tt 2a*(a+1)}
\item la fraction {\tt 1/2} est un nombre rationnel,
et non {\tt 0} (Python 2) ou le nombre approch\'e {\tt 0.5} (en Python 3)
\item le nombre complexe $i$ est not\'e {\tt i} 
et non {\tt 1j}, $i^2$ s'\'ecrit 
{\tt i\verb|^|2} et non {\tt 1j**2} et donne comme r\'eponse {\tt -1} et non 
{\tt -1+0j} 
\item les chaines de caract\`eres peuvent \^etre modifi\'ees caract\`ere
par caract\`ere, comme les listes.
\item Si on \'ecrit un programme dans lequel l'utilisateur doit saisir des 
donn\'ees, on utilise soit la commande {\tt saisir(a)} (ou {\tt input(a)}) pour 
saisir une expression, soit {\tt saisir\_chaine(s)} (ou {\tt textinput(s)}) 
pour saisir une cha\^{i}ne de caract\`eres, alors que'en Python {\tt input}
renvoie une cha\^{i}ne de caract\`eres qu'il faut affecter dans une variable
%\item  on peut cr\'eer une liste facilement et on a aussi la notion de 
%s\'equence plus facile \`a utiliser.
\item il n'y a pas besoin d'importer de biblioth\`eques  
(import math, import random, etc...)\\
\end{itemize}
On s'efforcera de donner dans ce document 
les programme \'ecrit avec les mots-clefs en fran\c{c}ais et leur 
traduction en syntaxe Python,
les deux syntaxe sont valides dans
{\tt Xcas}. Une grande partie des programmes \'ecrits en syntaxe Python,
peuvent \^etre utilis\'es dans un interpr\'eteur Python \`a condition
d'y avoir charg\'e le module 
\footahref{https://www-fourier.ujf-grenoble.fr/\%7eparisse/giac_fr.html#python}{giacpy}
par la commande \verb|from giacpy import *|  et d'avoir
affect\'e quelques variables symboliques (par exemple
pour x par \verb|x=giac('x')|)

\section{Premiers pas avec les interfaces de Xcas}
\subsection{Avec Xcas pour Firefox}
Depuis votre navigateur (il est conseill\'e 
d'utiliser Firefox pour des performances
optimales) ouvrez le lien\\
\ahref{http://www-fourier.ujf-grenoble.fr/\%7eparisse/xcasfr.html}{http://www-fourier.ujf-grenoble.fr/\~{\ }parisse/xcasfr.html}\\
Lors de la premi\`ere utilisation, vous \^etes invit\'es \`a choisir
entre la compatibilit\'e de syntaxe Python ou la syntaxe Xcas native.
Ceci peut \^etre modifi\'e ult\'erieurement en cliquant sur le bouton
Config en haut \`a gauche.

La ligne de commande se trouve en bas de page, au-dessus se trouve
une ligne de boutons assistants
\begin{itemize}
\item \verb|123| permet d'afficher un clavier scientifique
\item \verb|?| affiche une aide sur la commande ou le d\'ebut de commande
\`a l'endroit du curseur
\item deux fl\`eches de direction pour d\'eplacer le curseur
sur les smartphones ou tablettes
\item \verb|sel| pour s\'electionner la ligne de commande
\item \verb|math| qui affiche des assistants math\'ematique
\item \verb|prog| qui affiche des assistants de programmation
\begin{itemize}
\item \verb|test|: assistant pour cr\'eer un test (si alors sinon finsi)
\item \verb|boucle|: assistant pour cr\'eer une boucle (tantque ou pour)
\item \verb|fonct|: assistant pour cr\'eer une fonction
\item \verb|debug|: ins\`ere la commande \verb|debug(| pour mettre
au point un programme
\item \verb|//| ou \verb|#| pour commencer un commentaire sur la ligne actuelle
\item \verb|\n| pour passer \`a la ligne
\item \verb|del| pour effacer un caract\`ere
\item \verb|->/| pour indenter le source
\end{itemize}
\item \verb|ok| (ou touche Entree du clavier) 
pour valider la ligne de commande.
Pour passer \`a la ligne sur un clavier physique 
on peut taper simultan\'ement sur shift et Entree.
La ligne de commande est alors \'evalu\'ee et le r\'esultat affich\'e
en face ou en-dessous. Il est possible de modifier une ligne de commande
existante et de la r\'eex\'ecuter.
\end{itemize}
Vous pouvez sauvegarder une session, vous pouvez aussi l'envoyer par mail.
Le lien Clone permet de 
\begin{itemize}
\item de cloner une session (par exemple en cas de crash)
\item en utilisant clic droit,
de recopier le lien correspondant sur une page web, on peut
ainsi indiquer le lien vers un d\'ebut de session \`a des \'el\`eves.
\item toujours en utilisant clic droit, de recopier la session
vers Xcas natif. Dans Xcas natif sur PC, cliquer sur le num\'ero
de niveau o\`u vous voulez ins\'erer la session de Xcas pour Firefox
(par exemple sur \framebox{1} pour le niveau 1)
puis faites la copie en tapant simultan\'ement sur Ctrl et V.
\end{itemize}
Pour plus de d\'etails, vous pouvez cliquer sur le bouton Tutoriel en
haut \`a gauche en-dessous du bouton Config.

\subsection{Xcas natif sur PC Windows et Linux et sur Mac.}
Pour installer Xcas suivez les instructions depuis:\\
\ahref{http://www-fourier.ujf-grenoble.fr/\%7eparisse/install\_fr.html}{http://www-fourier.ujf-grenoble.fr/\~{\ }parisse/install\_fr.html}\\

Vous pouvez ensuite taper des commandes dans les lignes de commande
en utilisant les menus, en particulier le menu Outils qui contient
les commandes math\'ematiques de calcul les plus utilis\'ees, \`a d\'efaut
le menu Cmd qui les contient class\'ees par th\`emes, le menu Graph pour
les commandes de type graphes de fonction, le menu Geo pour la g\'eom\'etrie,
pour plus de d\'etails voir le menu Aide, D\'ebuter en calcul formel, Tutoriel.

Pour programmer, il est plus confortable d'ouvrir un niveau de programmes
depuis le menu Prg, nouveau programme. Un assistant de cr\'eation de
fonction s'ouvre imm\'ediatement (vous pouvez l'ignorer en tapant sur
la touche Echap). Un niveau de programme apparait avec son propre menu
et des boutons assistants Test, Boucle et Fonction pour vous aider
\`a saisir les structures de base de l'algorithmique. Une fois
votre programme saisi, vous l'interpr\'etez en tapant sur le bouton
OK (raccourci clavier F9). S'il est correct, vous pouvez tester votre
fonction depuis une ligne de commande.

Vous pouvez cloner une session simple vers Xcas pour Firefox \`a
partir du menu Fich, Clone, Online.

\subsection{Python et giacpy}
Une partie des programmes en syntaxe Python de ce document peuvent
s'ex\'ecuter dans un interpr\'eteur Python, apr\`es avoir charg\'e
le module \verb|giacpy|. Il faut d'abord installer
ce module sur votre PC, en suivant les instructions ici:\\
\ahref{https://www-fourier.ujf-grenoble.fr/\%7eparisse/giac\_fr.html\#python}{https://www-fourier.ujf-grenoble.fr/\~{\ }parisse/giac\_fr.html#python}\\
Ensuite le chargement se fait par la ligne de commande\\
\verb|from giacpy import *|\\
Les commandes de Xcas en anglais
sont en g\'en\'eral accessibles depuis l'interpr\'eteur
Python, mais il faut parfois faire des ajustements~:
\begin{itemize}
\item Pour avoir une variable symbolique, par exemple \verb|x|, 
on \'ecrira \verb|x=giac('x')|
\item Pour afficher un objet g\'eom\'etrique ou un graphe de fonction,
on utilise la m\'ethode \verb|qcas()|, par exemple
\verb|c=circle(0,1)| puis \verb|c.qcas()|
\item Il ne faut pas oublier que la puissance est \verb|**| et les r\`egles
propres \`a Python pour la division d'entiers
\end{itemize}


\chapter{Types, fonctions}
\section{Types}
\subsection{Entiers, rationnels, r\'eels, complexs  et les nombres approch\'es.}\index{evalf}\index{evalc}
Dans {\tt Xcas} :
\begin{itemize}
\item les entiers sont des nombres de $\mathbb{Z}$, par exemple -2,
\item les rationnels sont des nombres de $\mathbb{Q}$, par exemple $1/3$,
\item les nombres approch\'es sont des nombres d\'ecimaux\footnote{En toute rigueur ce sont des nombres \'ecrits en base 2 et non en base 10 mais on peut l'ignorer au niveau du lyc\'ee}, par exemple $3.14$.\\
{\bf Attention}, le s\'eparateur entre
partie enti\`ere et partie fractionnaire est le point \verb|.|\\
On peut utiliser la notation scientifique mantisse \verb|e| exposant
pour entrer des nombres approch\'es, par exemple \verb|1.2e-7|
signifie \verb|1.2| multipli\'e par $10^{-7}$.
\item les nombres r\'eels sont repr\'esent\'es par des nombres d\'ecimaux ou 
par des valeurs symboliques, par exemple $\sqrt 2$, $\pi$, $e$.
\item les nombres complexes sont repr\'esent\'es par $a+ib$ pour $a$ et $b$ 
r\'eels. Avec les commandes {\tt re}, {\tt im}, {\tt arg} et {\tt abs} pour 
avoir la partie r\'eelle, la partie imaginaire, l'argument et le module.
\end{itemize}
Pour avoir une valeur approch\'ee d'un nombre r\'eel on utilise la commande
{\tt evalf}, par exemple {\tt evalf(sqrt(2))} ou {\tt evalf(sqrt(2),20)} pour 
avoir  une valeur approch\'ee de $\sqrt 2$ avec 20 chiffres significatifs.\\
\giacinput{evalf(sqrt(2))}\\
\giacinput{evalf(sqrt(2),20)}
Pour avoir l'\'ecriture d'un nombre complexe sous la forme $a+ib$ avec $a$ et 
$b$ r\'eels on utilise la commande {\tt evalc}, par exemple 
{\tt evalc((1+i*sqrt(2))\verb|^|2+2)}.\\
\giacinput{(1+i*sqrt(2))^2+2}\\
\giacinput{evalc((1+i*sqrt(2))^2+2)}
\subsection{Les listes, les s\'equences et les cha\^ines de caract\`eres}
\subsubsection{D\'efinition d'une liste}\index{[]}
Qu'est-ce qu'une {\bf liste} ?\\
C'est une \'enum\'eration d'objets, dont l'ordre est important. 
Cela peut servir \`a repr\'esenter les coordonn\'ees d'un point ou
d'un vecteur, \`a contenir une liste de valeurs (observations) 
en statistiques, ...\\
Une liste est d\'elimit\'ee par des crochets {\tt []} et les \'el\'ements de 
la liste sont s\'epar\'es par une virgule {\tt ,}\\ 
\giacinput{L:=[2,24,1,15,5,10]}
\subsubsection{Cr\'eation d'une liste}\index{range}\index{makelist}\index{seq}\index{\$}
\begin{itemize}
\item {\tt range}\\
{\tt range(n)} renvoie la liste {\tt [0,1..n-1]}\\
{\tt range(a,b)} renvoie la liste {\tt [a,a+1..b[}\\
{\tt range(a,b,p)} la liste {\tt [a,a+p,a+2p..b[} \`a condition que {\tt p} 
soit un entier.\\
\giacinput{range(5)}\\
\giacinput{range(5,11)}\\
\giacinput{range(11,5,-1)}\\
\giacinput{range(1,11,3)}\\
\item {\tt seq} renvoie la liste obtenue lorsqu'on calcule
une expression d\'ependant d'un param\`etre {\tt var} qui varie entre {\tt a} 
et {\tt  b} (on peut ajouter un argument optionnel, le pas {\tt p}.\\
{\tt seq} a 4 ou 5 arguments)
\giacinput{seq(2^k,k,0,8)}
\giacinput{seq(2^k,k,0,8,2)}
\giacinput{seq(2^k,k,0,8,1/2)}
\item {\tt makelist} renvoie une liste faite à partir d'une fonction ou d'une 
constante.\\
\giacinput{makelist(x->x^2,1,10)}
\giacinput{makelist(x->x^2,1,10,2)}
\giacinput{makelist(x->x^2,1,10,1/2)}
\end{itemize}

\subsubsection{D\'efinition d'une s\'equence}\index{()}
Qu'est-ce qu'une {\bf s\'equence} ?\\
On peut le voir comme une liste sans crochets, ce qui signifie
que si on s\'epare 2 s\'equences par une virgule, elles sont
concat\'en\'ees, on ne peut
donc pas cr\'eer une s\'equence de s\'equences alors qu'on peut cr\'eer
une liste de listes. Par exemple les arguments d'une fonction sont
regroup\'es en une s\'equence.\\
Une s\'equence n'est pas d\'elimit\'ee 
(ou est d\'elimit\'ee par des parenth\`eses {\tt ()}) et les \'el\'ements
 de la s\'equence sont s\'epar\'es par une virgule {\tt ,}\\ 
\giacinput{S:=(2,24,1,15,5,10)}

{\bf Attention}, 
cette syntaxe renvoie un n-uplet en Python, il s'agit d'une liste
constante (non modifiable apr\`es cr\'eation).

\subsubsection{Cr\'eation d'une s\'equence}\index{seq}\index{\$}
\begin{itemize}
\item {\tt seq} renvoie la s\'equence obtenue lorsque {\tt var} varie entre 
{\tt a} et {\tt  b} (avec un argument optionnel, le pas={\tt p}).
{\tt seq}  a 2 ou 3 arguments.\\
\giacinput{seq(2^k,k=0..8)}
\giacinput{seq(2^k,k=0..8,2)}
\giacinput{seq(2^k,k=0..8,1/2)}
\item \$ est la version infix\'ee de {\tt seq}\\
\giacinput{2^k$10}
\giacinput{2^k$(k=0..8)}
\giacinput{2^k$(k=0..8,2)}
\giacinput{2^k$(k=0..8,1/2)}
\end{itemize}

\subsubsection{Transformation d'une s\'equence en liste et vice-versa}\index{op}
\index{[]}
Si {\tt S} est une s\'equence alors {\tt [S]} est une liste.\\
Si {\tt L} est une liste  alors {\tt op(L)]} est une s\'equence.\\
\giacinput{L:=[2,24,1,15,5,10]}\\
\giacinput{S:=(2,24,1,15,5,10)}\\
\giacinput{op(L)}\\
\giacinput{[S]}

\subsubsection{D\'efinition d'une chaine de caract\`eres}\index{+}\index{\symbol{34}}
Qu'est-ce qu'une {\bf chaine de caract\`eres} ?\\
C'est la concat\'enation de 0, 1 ou plusieurs caract\`eres.\\
Une chaine de caract\`eres est d\'elimit\'ee par {\tt ""}\\ 
On concat\'ene de 2 cha\^{i}nes avec {\tt +}\\
\giacinput{s:="Bonjour"}
\giacinput{s:="";s:=s+"Bon"+"jour"}

\subsection{Les instructions sur les listes les s\'equences et les cha\^ines de caract\`eres}\index{dim}\index{gauche}\index{droit}\index{len}\index{append}\index{prepend}\index{concat}\index{rotate}\index{shift}\index{suppress}\index{reverse}\index{revlist}
\begin{itemize}
\item {\tt dim(L)} ou {\tt len(L)}
renvoie le nombre d'\'el\'ements de la liste {\tt L}.\\
{\tt dim(S)}  ou {\tt len(S)} renvoie le nombre d'\'el\'ements de la 
s\'equence {\tt S}.\\
{\tt dim(s)} ou {\tt len(s)} renvoie le nombre de caract\`eres de la cha\^ine 
{\tt s}.
\item
{\tt []} repr\'esente la liste vide et {\tt dim([])} vaut {\tt 0}.\\
{\tt NULL} repr\'esente la s\'equence vide et {\tt dim(NULL)} vaut {\tt 0}.\\
{\tt ""} repr\'esente la cha\^ine vide et {\tt dim("")} vaut {\tt 0}.
\item
Les \'el\'ements de la liste sont num\'erot\'es de 0 jusque {\tt dim(L)-1}.\\
{\tt L|0]} d\'esigne le premier \'el\'ement de la liste et {\tt L[dim(L)-1]} 
 ou {\tt L[-1]} d\'esigne le dernier \'el\'ement de la liste {\tt L}.\\
Les \'el\'ements de la s\'equence sont num\'erot\'es de 0 jusque {\tt dim(S)-1}.\\
{\tt S|0]} d\'esigne le premier \'el\'ement de la s\'equence et 
{\tt S[dim(S)-1]}  ou {\tt S[-1]} d\'esigne le dernier \'el\'ement de la s\'equence.\\
{\tt s|0]} d\'esigne le premier caract\`ere de la cha\^{\i}ne et {\tt s[dim(s)-1]} 
d\'esigne le dernier caract\`ere de la cha\^ine {\tt S}.\\
%{\tt mid(L,d)} renvoie la fin de la liste {\tt L} en commençant par l'indice {\tt d}.\\
\item
{\tt gauche(L,n)} renvoie les {\tt n} premiers \'el\'ements de la liste {\tt L}
(c'est le c\^ot\'e gauche de la liste).\\
{\tt droit(L,n)} renvoie les {\tt n} derniers \'el\'ements de la liste {\tt L}
(c'est le c\^ot\'e droit de la liste).\\
{\tt gauche(s,n)} renvoie les {\tt n} premiers caract\`eres de la cha\^ine 
{\tt s} (c'est le c\^ot\'e gauche de la cha\^ine).\\
{\tt droit(s,n)} renvoie les {\tt n} derniers caract\`eres de la cha\^ine 
{\tt s} (c'est le c\^ot\'e droit de la cha\^ine).\\
 Par exemple : soient la liste  {\tt L:=[2,24,1,15,5,10]} et la cha\^ine
{\tt s:="Bonjour"}.\\
{\tt L1:=seq(2*k,k,0,4)} cr\'ee la liste {\tt [0,2,4,6,8]}
\item \verb|count_eq, count_inf, count_sup, count|~: nombre d'\'el\'ements
\'egaux, inf\'erieurs, sup\'erieurs ou v\'erifiant une condition\\
\verb|count_sup(2,L1)| ou {\tt count(x->x>2,L1)} compte le nombre d'\'el\'ements de {\tt L1} sup\'erieurs
 \`a 2.\\
{\tt S1:=seq(2*k,k=0..4)} cr\'ee la s\'equence {\tt (0,2,4,6,8)}\\
{\tt count(x->x>2,S1)} compte le nombre d'\'el\'ements de {\tt S1} sup\'erieurs
 \`a 2.
\item
{\tt sum(L)} renvoie la somme des \'el\'ements de la liste {\tt L}.\\
{\tt sum(S)} renvoie la somme des \'el\'ements de la s\'equence {\tt S}.
\item Quelques exemples~:\\
\giacinput{L:=[2,18,1,9,6,54]}\\
\giacinput{n1:=dim(L)}\\
\giacinput{L[0]} \\
\giacinput{L[1];L[2]}\\
\giacinput{L[n1-1]}\\
\giacinput{gauche(L,2)} \\
\giacinput{droit(L,2)} \\
\giacinput{sum(L)}\\
\giacinput{S:=(2,18,1,9,6,54)}\\
\giacinput{n1:=dim(S)}\\
\giacinput{S[0]} \\
\giacinput{S[1];S[2]}\\
\giacinput{S[n1-1]}\\
\giacinput{sum(S)}\\
\giacinput{S:=S,3,27}
\giacinput{S:=S,(4,36)}
\giacinput{S:=S,[5,45]}
\giacinput{s:="Bonjour"}\\
\giacinput{n2:=dim(s)} \\
\giacinput{s[0]}\\
\giacinput{s[1];s[2]} \\
\giacinput{s[n2-1]}\\
\giacinput{gauche(s,3)}\\
\giacinput{droit(s,4)}
\item
{\tt append}\\
{\tt append(L,a)} renvoie la liste o\`u l'\'el\'ement {\tt a} \`a \'et\'e
rajout\'e \`a la fin de la liste {\tt L}.\\
On tape :\\
\giacinput{append([1,2,3],4)}\\
\giacinput{L:=[1,2,3]; append(L,4); L}\\
{\bf Attention}\\
Pour ajouter {\tt 4} \`a la fin de la liste {\tt L} on tape :\\
\giacinput{L:=[1,2,3]; L:=append(L,4); L}\\
ou comme en Python\\
\giacinput{L:=[1,2,3]; L.append(4); L}
\item
Il est facile d'ajouter un \'el\'ement \`a une s\'equence ou de concat\'ener 2 
s\'equences.\\
Supposons que  {\tt S} soit la s\'equence {\tt (1,2,3)}({\tt S:=1,2,3}) et 
que {\tt L} soit la liste {\tt [1,2,3]} ({\tt L:=[1,2,3]}).\\
Pour modifier une s\'equence il suffit par exemple, d\'ecrire :\\
{\tt S:=S,4} (resp {\tt S:=S,4,5,6} ou {\tt S:=S,(4,5,6)}) pour que
{\tt S} soit la s\'equence {\tt (1,2,3,4)} (resp {\tt (1,2,3,4,5,6)}\\
alors que pour modifier une liste il faut \'ecrire :\\
{\tt L:=append(L,4)} (resp {\tt L:=append(L,4,5,6)} ou {\tt L:=concat(L,4,5,6)} 
ou {\tt L:=concat(L,[4,5,6])}) pour que {\tt L} soit la liste {\tt [1,2,3,4]} 
(resp {\tt [1,2,3,4,5,6]}).\\
{\bf  Mais attention !}\\
{\tt L:=append(L,[4,5,6])} renvoie {\tt [1,2,3,[4,5,6]]}\\
Pour les cha\^{\i}nes de caract\`eres, supposons que  {\tt s} soit la 
cha\^{\i}ne {\tt "abc"} ({\tt s:="abc"}), on peut \'ecrire pour lui rajouter 
{\tt "def"} :\\
{\tt s:=append(s,"def")} ou {\tt s:=concat(s,"def")} ou {\tt s:=s+"def")}\\
\giacinput{s:="abc";s:=s+"def"}
\item
{\tt prepend}\\
{\tt prepend(L,a)} renvoie la liste o\`u l'\'el\'ement {\tt a} \`a \'et\'e
rajout\'e au d\'ebut de la liste {\tt L}.\\
On tape :\\
\giacinput{prepend([1,2,3],0)}\\
\giacinput{L:=[1,2,3]; prepend(L,0); L}\\
{\bf Attention}\\
Pour ajouter {\tt 0} au d\'ebut de la liste {\tt L} on tape :\\
\giacinput{L:=[1,2,3]; L:=prepend(L,0); L}\\
ou\\
\giacinput{L:=[1,2,3]; L.prepend(0); L}\\
\item
{\tt concat}\\
{\tt concat(L1,L2)} renvoie la concat\'enation des deux listes {\tt L1} et 
{\tt L2)}.\\
On tape :\\
\giacinput{concat([1,2,3],[4,5,6,7])}\\
\giacinput{L:=[1,2,3]; concat(L,[4,5,6,7]); L}\\
{\bf Attention}\\
Pour ajouter {\tt 4,5,6,7} \`a la fin de la liste {\tt L} on tape :\\
\giacinput{L:=[1,2,3]; L:=concat(L,[4,5,6,7]); L}\\
ou\\
\giacinput{L:=[1,2,3]; L.concat([4,5,6,7]); L}
\item
{\tt rotate}\\
{\tt rotate(L)} (resp {\tt rotate(L,n)}) renvoie la liste obtenue en mettant le dernier \'el\'ement (resp la fin de la liste à partir du {\tt n}-i\`eme 
\'el\'ement) en premier (par d\'efaut n=-1).\\
On tape :\\
\giacinput{rotate([0,1,2,3])}\\
\giacinput{L:=[0,1,2,3]; rotate(L)}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3]; L:=rotate(L); L}\\
ou\\
\giacinput{L:=[0,1,2,3]; L.rotate(); L}\\
On tape :\\
\giacinput{rotate([0,1,2,3],2)}\\
\giacinput{ L:=[0,1,2,3]; rotate(L,2); L}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=rotate(L,2);L}\\
ou\\
\giacinput{L:=[0,1,2,3]; L.rotate(2);L}
\item
{\tt shift}\\
{\tt shift(L,n)} : si {\tt n>0} on remplace les {\tt n} premiers 
\'el\'ements de la liste par des {\tt 0} et on renvoie ces {\tt 0} \`a la fin de
la liste,\\
si {\tt n<0} renvoie la liste obtenue  en rempla\c{c}ant les 
{\tt -n} derniers \'el\'ements de la liste par {\tt 0} et on renvoie ces {\tt 0} au d\'ebut de la liste, puis on renvoie la liste ainsi obtenue.
(par défaut n=-1 ce qui signifie que le dernier \'el\'ement de la liste est 
supprim\'e et on met un {\tt 0} au d\'ebut de la liste).
On tape :\\
\giacinput{shift([1,2,3,4],-1),shift([1,2,3,4])}\\
\giacinput{L:=[0,1,2,3];shift(L);shift(L,-2)}\\
\giacinput{shift([1,2,3,4],-2);shift([1,2,3,4],2)}\\
\giacinput{L:=[0,1,2,3];shift(L,2)}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=shift(L);}\\
ou\\
\giacinput{L:=[0,1,2,3];L.shift();L}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=shift(L,-2);L}\\
ou\\
\giacinput{L:=[0,1,2,3];L.shift(-2);L}
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=shift(L,2);L}\\
ou\\
\giacinput{L:=[0,1,2,3];L.shift(2);L}\\
\item
{\tt suppress}\\
{\tt suppress(L,n)} renvoie {\tt L} sans son \'el\'ement d'indice 
{\tt n}.\\
On tape (attention les indices commencent \`a 0) :\\
\giacinput{suppress([0,1,2,3],2)}\\
\giacinput{L:=[0,1,2,3];suppress(L,2);L}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=suppress(L,2);L}\\
ou\\
\giacinput{L:=[0,1,2,3];L.suppress(2);L}
\item
{\tt reverse}\\
{\tt reverse(L)} ou {\tt revlist(L)} renvoie la liste {\tt L} invers\'ee.\\
On tape :\\
\giacinput{reverse([1,2,3])}\\
\giacinput{L:=[1,2,3];reverse(L);L}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[1,2,3];L:=reverse(L);L}\\
ou\\
\giacinput{L:=[1,2,3];L.reverse();L}
\end{itemize}

\subsection{Les bool\'eens}
\subsubsection{D\'efinition}
L'ensemble des bool\'eens est un ensemble \`a 2 \'el\'ements :\\
{\tt vrai} ou {\tt 1} et {\tt faux} ou {\tt 0}.\\
Pour faire des tests, on utilise des op\'erateurs bool\'eens.

\subsubsection{Op\'erateur bool\'een infix\'e qui teste l'\'egalit\'e {\tt ==}}
\index{==}
Pour tester l'\'egalit\'e entre deux objets (r\'eels, entiers, expressions, 
listes..) on utilise l'op\'erateur \verb|==|. Le test renvoie vrai si les
deux objets sont \'egaux, au sens o\`u leur repr\'esentation informatique
est identique. Pour tester que deux expressions litt\'erales
contenues dans les variables \verb|a| et \verb|b|
sont math\'ematiquement
\'equivalentes, il est parfois n\'ecessaire de faire une commande explicite
de simplification, au lieu d'\'ecrire \verb|a==b| on \'ecrit 
\verb|simplify(a-b)==0|.

{\bf Exemple :}\\ 
\giacinput{a:=3;b:=5}\\ 
\giacinput{b-a==0}\\
\giacinput{b-a-2==0}\\
\giacinputbig{(1+sqrt(2))^2==3+2*sqrt(2);simplify((1+sqrt(2))^2-3-2*sqrt(2))==0;}

\subsubsection{Les diff\'erentes significations des signes {\tt :=}, {\tt =},{\tt ==}, {\tt \#=}}\index{\#=}
{\bf Attention }
\begin{itemize}
\item Il ne faut pas confondre les diff\'erentes significations du signe 
\verb|=|\\
Le signe {\tt :=} sert \`a stocker une valeur dans une variable, le
signe {\tt =} sert \`a d\'efinir une \'equation (ou  \`a donner la valeur par
d\'efaut d'un argument, cf. la section \ref{sec:valdef}).\\ 
Le signe {\tt ==} sert \`a tester l'\'egalit\'e. C'est un op\'erateur bool\'een infix\'e. Il renvoie {\tt vrai} ou {\tt faux}.\\\\
{\tt Xcas} accepte toutefois {\tt =} dans certaines situations non 
ambig\"ues (affectation ou test d'\'egalit\'e), par exemple :\\
{\tt a=1;si a=2 alors vrai sinon faux fsi;a;} renvoie {\tt 1=1,faux,1}.\\
{\bf Remarque} \\
En Python l'affectation se fait avec le signe {\tt =}, car Python ne g\'ere pas 
les \'equations, 
c'est pourquoi dans {\tt Xcas} en syntaxe compatible Python, 
on utilisera le signe {\tt \#=} pour d\'efinir une \'equation. 
Dans  un interpr\'eteur Python avec {\tt giacpy}, il faut utiliser la
commande pr\'efix\'ee {\tt equal}.
\item {\tt Xcas} travaille par d\'efaut avec des nombres exacts donc :\\
{\tt 3+10\verb|^|(-16)==3} renverra {\tt faux} ou {\tt false} car il compare 2 
nombres rationnels alors qu'avec un logiciel qui ne fait pas 
de calcul formel, il se peut que {\tt 3+10\verb|^|(-16)==3} renvoie {\tt vrai} 
ou {\tt true} car il compare 2 nombres flottants i.e.  2 nombres approch\'es.
\end{itemize}

\subsubsection{Op\'erateur bool\'een infix\'e qui teste la non \'egalit\'e {\tt !=}}\index{\symbol{33}=}
Le signe {\tt !=} sert \`a tester la non \'egalit\'e. \\
C'est un op\'erateur bool\'een infix\'e. Il renvoie {\tt vrai} ou {\tt faux}.\\{\bf Exemple :}\\ 
\giacinput{a:=3;b:=5}\\
\giacinput{b!=a}\\
\giacinput{a+2!=b}

\subsubsection{Op\'erateur bool\'een infix\'e qui teste l'in\'egalit\'e {\tt <, >, <=, >=}}\index{\symbol{60}=}\index{\symbol{62}=}\index{\symbol{60}}\index{\symbol{62}}
%&lt;
Les signes {\tt <, >, <=, >=} servent \`a tester les in\'egalit\'es. \\
Ce sont des op\'erateurs bool\'eens infix\'es. Ils renvoient {\tt vrai} ou 
{\tt faux}.\\
{\bf Exemple :}\\ 
\giacinput{a:=3;b:=5}\\
\giacinput{b >= a}\\
\giacinput{a+2 > b}\\
\giacinput{a+2 >= b}



\subsection{Expressions, polyn\^omes}
\subsubsection{Simplification d'une expression avec {\tt normal}}\index{normal}
\index{simplify}
{\tt Xcas} renvoie le r\'esultat d'un calcul litt\'eral sans le simplifier 
(sauf pour les calculs dans les rationnels).\\
Il faut utiliser la fonction {\tt normal} ou {\tt simplify}
pour obtenir un r\'esulat simplifi\'e.\\
\giacinput{purge(x)}\\
\giacinput{(x^2+1)^2+(x^2-1)^2}\\
\giacinput{normal((x^2+1)^2+(x^2-1)^2)}

\subsubsection{Les polyn\^omes}
Un polyn\^ome \`a une ind\'etermin\'ee \`a coefficients dans $\mathbb{R}$ est 
d\'etermin\'e par une 
s\'equence $a_n,...,a_1,a_0$ d'\'el\'ements de $\mathbb{R}$, c'est l'expression :\\ 
$a_nx^n+...+a_1x+a_0$ (ou $a_0+a_1x+a_2x^2+..+a_nx^n$).\\
$n$ est le degr\'e du polyn\^ome.\\
On dit que l'on a \'ecrit le polyn\^ome selon les puissances d\'ecroissantes 
(ou croissantes).\\
$a_n,..a_1,a_0$ sont les coefficients du polyn\^ome et $x$ est la variable ou
l'ind\'etermin\'ee du polyn\^ome.\\
On notera l'ensemble des polyn\^omes \`a une ind\'etermin\'ee $x$ : $\mathbb{R}[x]$.

Un polyn\^ome \`a 2 ind\'etermin\'ees $x$ et $y$ \`a coefficients dans $\mathbb{R}$ est d\'etermin\'e par 
une s\'equence $A_n(y),...,A_1(y),A_0(y)$ d'\'el\'ements de $\mathbb{R}[y]$
et a pour expression :\\ 
$A_n(y)x^n+...+A_1(y)x+A_0(y)$ (ou $A_0(y)+A_1(y)x+A_2(y)x^2+..+A_n(y)x^n$)\\
Par exemple :\\
si $A_0(y)=y^3-2,A_1(y)=-2y,A_2(y)=y^3+2*y+3$\\
Le polyn\^ome s'\'ecrit :\\
$y^3-2-2y*x+(y^3+2*y+3)*x^2=x^2*y^3+2*x^2*y+3*x^2-2*x*y+y^3-2$\\
Le degr\'e par rapport \`a $x$ du polyn\^ome de cet exemple et \'egal \`a 2.\\
Le degr\'e par rapport \`a $y$ du polyn\^ome de cet exemple et \'egal \`a 3.

\subsubsection{Coefficients et degr\'e d'un  polyn\^ome}\index{degree}\index{symb2poly}\index{coeff}\index{poly2symb}
{\tt Xcas} repr\'esente les polyn\^omes soit sous la forme d'une expression 
symbolique, soit comme la s\'equence des coefficients selon les puissances 
d\'ecroissantes ({\tt poly1[1,2,3]} i.e. {\tt [a2,a1,a0]:=[1,2,3]}).\\ 
Par exemple, le polyn\^ome $x^2+2x+3$ s'\'ecrit:\\
soit {\tt x\verb|^|2+2x+3} o\`u {\tt x} est l'ind\'etermin\'ee mais 
{\bf Attention} {\tt x} doit \^etre une variable symbolique donc {\tt x} doit 
\^etre purg\'ee,\\
 soit {\tt poly1[1,2,3]}\\
Les commandes {\tt symb2poly(x\verb|^|2+2x+3)} et {\tt poly2symb([1,2,3],x)} 
passent d'une repr\'esentation \`a l'autre.
\begin{itemize}
\item
Pour avoir le degr\'e d'une expression polyn\^omiale par rapport \`a une 
variable, on utilise
l'instruction {\tt degree} qui renvoie le degr\'e d'un polyn\^ome (on peut
ajouter un 2i\`eme argument si le polyn\^ome est symbolique en une 
ind\'etermin\'ee
qui n'est pas {\tt x}).
\item
Pour  avoir les coefficients d'un  polyn\^ome par rapport \`a une variable
on utilise l'instruction {\tt symb2poly} qui renvoie la liste des coefficients 
d'un polyn\^ome par rapport au 2i\`eme argument ({\tt x} est la variable par 
d\'efaut). Ainsi si {\tt L:=symb2poly(P(x))}, {\tt degree(P(x))} est \'egal \`a 
{\tt dim(L)-1}.\\
La commande {\tt poly2symb} effectue le calcul inverse, ainsi~:\\
{\tt symb2poly(y\verb|^|2+2y+3)} renvoie {\tt poly1[1,2,3]}.\\
{\tt poly2symb([1,2,3],y)} renvoie {\tt (y+2)*y+3}.
\item
Pour avoir le coefficient de degr\'e donn\'e d'un polyn\^ome par rapport \`a 
une variable,  on utilise l'instruction {\tt coeff}.
\item Exemples~:
\giacinput{degree(x^2-2x*y+y^3-2)}\\
\giacinput{degree(x^2-2x*y+y^3-2,x)}\\
\giacinput{degree(x^2-2x*y+y^3-2,y)}\\
\giacinput{symb2poly(x^2-2x*y+y^3-2)}\\
\giacinput{symb2poly(x^2-2x*y+y^3-2,x)}\\
\giacinput{symb2poly(x^2-2x*y+y^3-2,y)}\\
\giacinput{coeff(x^2-2x*y+y^3-2,x,2)}\\
\giacinput{coeff(x^2-2x*y+y^3-2,y,1)}
\end{itemize}

\subsection{Conna\^{\i}tre les types et les sous-types}\index{type}\index{subtype}
\index{real}\index{integer}\index{rational}\index{expression}\index{func}\index{vector}\index{string}\index{identifier}
{\bf Les types}\\
{\tt Xcas} sait reconna\^{\i}tre le type d’un objet.\\
Pour avoir le type de l'objet {\tt a} ou le contenu d'une variable {\tt a}, on 
utilise {\tt type(a)}.\\
%Par exemple, si {\tt a:=<valeur>}, et si {\tt <valeur>} est un nombre 
%flottant, {\tt type(a)} renvoie {\tt real} ou {\tt 1} ce qui signifie que 
%{\tt a} contient un nombre flottant.\\
Les types utilis\'es ici sont :\\
{\tt real} ou {\tt 1} ce qui signifie que {\tt a} contient un nombre flottant.\\
\giacinput{a:=3.14}\\
\giacinput{type(a)}\\
\giacinput{type(a)+0}\\
{\tt integer} ou {\tt 2} ce qui signifie que {\tt a} contient un nombre 
entier,\\
\giacinput{a:=2017}\\
\giacinput{type(a)}\\
\giacinput{type(a)+0}\\
{\tt rational} ou {\tt 10} ce qui signifie que {\tt a} contient un nombre 
rationnel,\\
\giacinput{a:=2/7}\\
\giacinput{type(a)}\\
\giacinput{type(a)+0}\\
{\tt func} ou {\tt 13} ce qui signifie que {\tt a} est le nom d'une 
fonction,\\
\giacinput{f(x):=2x+3}\\
\giacinput{type(f)}\\
\giacinput{type(sin)}\\
\giacinput{type(sin)+0}\\
{\tt vecteur} ou {\tt 7} ce qui signifie que {\tt a} contient une liste,\\ 
\giacinput{L:=[2,24,1,15,5,10]}\\
\giacinput{type(L)}\\
\giacinput{type(L)+0}\\
{\tt string} ou {\tt 12} ce qui signifie que {\tt a} contient une 
cha\^ine de caract\`eres,\\ 
\giacinput{s:="Bonjour"}\\
\giacinput{type(s)}\\
\giacinput{type(s)+0}\\
{\tt expression} ou {\tt 8} ce qui signifie que {\tt a} contient une 
expression,\\ 
\giacinput{a:=sqrt(2)}\\
\giacinput{type(a)}\\
\giacinput{type(a)+0}\\
\giacinput{type(f(x))}\\
\giacinput{type(f(x))+0}\\
{\tt identifier} ou {\tt 6} ce qui signifie que {\tt a} contient le nom d'une 
variable non affect\'ee.\\
\giacinput{purge(a)}\\
\giacinput{type(a)}\\
\giacinput{type(a)+0}

{\bf Les sous-types}\\
Certains types de variables peuvent servir \`a plusieurs usages~: par exemple
une liste peut repr\'esenter les coordonn\'ees d'un point dans l'espace
ou les coefficients d'un polyn\^ome ou un ensemble. {\tt Xcas} poss\`ede
une commande {\tt subtype} permettant de pr\'eciser le type d'une variable.
Pour avoir le sous-type de la variable {\tt a}, on utilise {\tt subtype(a)}.\\
Par exemple si {\tt a} contient une liste,
{\tt subtype(a)} renvoie {\tt 1} pour une s\'equence, {\tt 2} pour un ensemble, 
{\tt 10} pour un polyn\^ome et {\tt 0} sinon.\\
\giacinput{subtype(1,2,3)}\\
\giacinput{subtype(set[1,2,3])}\\
\giacinput{subtype(poly1[1,2,3])}\\
\giacinput{subtype([1,2,3])}

\section{Les fonctions}\index{fonction}\index{ffonction}\index{local}\index{retourne}\index{\# local}
On distingue les fonctions ou commandes de {\tt Xcas} et les fonctions 
d\'efinies par l'utilisateur. Pour \'eviter le risque d'utiliser un nom
de fonction de {\tt Xcas}, il est conseill\'e de nommer les fonctions
utilisateurs en utilisant une majuscule comme premi\`ere lettre.
Pour d\'efinir des fonctions (utilisateurs), 
on distinguera~:
\begin{itemize}
\item les fonctions d\'efinies par une expression alg\'ebrique.
Leur d\'efinition peut se faire simplement avec {\tt :=}
\item les fonctions qui n\'ecessitent des calculs interm\'ediaires ou
des structures de contr\^ole
(test, boucle). Leur d\'efinition se fait au moyen d'un 
programme, en utilisant les instructions 
{\tt fonction...ffonction}, {\tt local} et {\tt retourne} et
les structures de contr\^ole qui seront d\'etaill\'ees au chapitre
\ref{chap:prog}\footnote{On peut utiliser la syntaxe \`a la {\tt Python} au 
sein de {\tt Xcas}, mais il faut d\'eclarer les variables locales 
avec {\tt \# local} (bien mettre un espace entre {\tt \#} et {\tt local}) et 
n'utiliser que {\tt "} (et non  {\tt '}) comme d\'elimiteur de cha\^{\i}nes de 
caract\`eres.}, par exemple : {\tt "bon"}. 
\end{itemize}
\subsection{Quelques fonctions alg\'ebriques de {\tt Xcas}}
\noindent {\tt abs} est la fonction valeur absolue.\\
\giacinput{abs(sqrt(2)-3/2)}\\
{\tt ceil} est le plus grand entier $>=$ \`a l'argument.\\
{\tt cos} est la fonction cosinus.\\
\giacinput{cos(pi/6)}\\
{\tt floor} est la partie enti\`ere i.e.le plus grand entier $<=$ \`a 
l'argument.\\
\giacinput{floor(-2.42)}\\
\giacinput{floor(2.42)}\\
{\tt frac} est la partie fractionnaire d'un r\'eel.\\
\giacinput{frac(3/2)}\\
\giacinput{frac(2.42)}\\
{\tt max} est la fonction maximum pour une s\'equence de nombres r\'eels.\\
\giacinput{max(sqrt(2),3,5,sqrt(26))}\\
{\tt min} est la fonction minimum pour une s\'equence de nombres r\'eels.\\
\giacinput{min(sqrt(2),3,5,sqrt(26))}\\
{\tt \verb|^|} est la fonction puissance.\\
\giacinput{2^10}\\
{\tt round} est la fonction qui arrondit un r\'eel en l'entier (resp le d\'ecimal) le plus proche.\\
\giacinput{round(-2.42)}\\
\giacinput{round(-2.42,1)}\\
\giacinput{round(sqrt(2),4)}\\
{\tt sign} est la fonction signe de l'argument et renvoie -1, 0 ou +1.\\
\giacinput{sign(-4)}\\
\giacinput{sign(4-4)}\\
\giacinput{sign(4)}\\
{\tt sin} est la fonction sinus.\\
\giacinput{sin(pi/3)}\\
{\tt sqrt} est la racine carr\'ee.\\
\giacinput{sqrt(2)^2}\\
\giacinput{(sqrt(3)+1)*(sqrt(3)-1)}\\
\giacinput{normal((sqrt(3)+1)*(sqrt(3)-1))}\\
{\tt tan} est la fonction tangente.\\
\giacinput{tan(pi/4)}

\subsection{Quelques fonctions al\'eatoires de {\tt Xcas}}\index{srand}\index{randseed}\index{RandSeed}\index{rand}\index{randint}\index{random}\index{choice}\index{shuffle}\index{sample}

Nous donnons ci-apr\`es les fonctions al\'eatoires les plus fr\'equentes : pour 
des raisons de compatibilité avec le langage {\tt Python} chacune des fonctions 
ci-dessous peuvent \^etre pr\'efix\'ee par {\tt random.} (par exemple on peut 
\'ecrire {\tt random.randint()} ou {\tt randint()})

{\tt srand randseed RandSeed}\\
{\tt srand} ou {\tt  randseed} initialise la suite des nombres al\'eatoires : 
{\tt srand}  ou {\tt  randseed}renvoie un entier qui a servi \`a cette 
initialisation.\\
On tape :\\
\giacinput{srand}

{\tt RandSeed}\\
{\tt RandSeed(n)} initialise les nombres al\'eatoires selon la valeur de 
l'entier {\tt n}.\\
On tape :\\
\giacinput{RandSeed(321)}

{\tt random rand}\\
{\tt random()} ou {\tt rand()} renvoie un nombre r\'eel 
(pseudo)-al\'eatoire de l’intervalle semi-ouvert $[0,1[$.\\
On tape :\\
\giacinput{random()}

{\tt choice}\\
{\tt choice(L)} ou {\tt random(L)} ou {\tt rand(L)} renvoie un \'el\'ement
 tir\'e au hasard parmi les \'el\'ements de la liste {\tt L}.\\
On tape :\\
\giacinput{choice([1,2,3,4,5,6])}

{\tt randint}\\
{\tt randint(a,b)} renvoie un nombre entier (pseudo)-al\'eatoire 
compris entre {\tt a} et {\tt b} (bornes incluses).\\
On tape :\\
\giacinput{randint(1,10)}

{\tt shuffle}\\
{\tt shuffle(L)} applique une permutation al\'eatoire \`a la liste {\tt L}.\\
On tape :\\
\giacinput{shuffle([1,2,3,4,5,6])}

{\tt sample} ou {\tt rand}\\
{\tt sample(L,n)} ou {\tt rand(n,L)} renvoie, si {\tt n<=size(L)}, {\tt n} 
\'el\'ements tir\'es, au hasard, sans remise parmi les \'el\'ements de la 
liste {\tt L} et sinon renvoie une erreur. \\
On tape :\\
\giacinput{sample([1,2,3,4,5,6,7,8,9,10],3)}\\
{\bf Remarque} {\tt sample(L,len(L))} ou {\tt rand(dim(L),L)} est identique 
\`a {\tt shuffle(L)}.

On tape  en syntaxe {\tt Xcas} :
\begin{giaconload}
fonction testrand()
  local L1,L2,L3,n1,n2,a1,a2;
  n1:=random();
  n2:=random();
  a1:=randint(1,10);
  a2:=randint(1,10)
  L1:=sample([1,2,3,4,5,6],3);
  L2:=sample([1,2,3,4,5,6],3);
  L3:=shuffle([1,2,3,4,5,6]);
  return n1,n2,a1,a2,L1,L2,L3;
ffonction:;
\end{giaconload}
\giacinput{testrand()}

On tape en syntaxe Python :
\begin{giaconload}
def testrand() :
    # local L1,L2,L3,n1,n2,a1,a2
    n1=random.random()
    n2=random.random()
    a1=random.randint(1,10)
    a2=randint(1,10)
    L1=random.sample([1,2,3,4,5,6],3)
    L2=random.sample([1,2,3,4,5,6],3)
    L3=shuffle([1,2,3,4,5,6])
    return n1,n2,a1,a2,L1,L2,L3 
\end{giaconload}
\giacinput{testrand()}


\subsection{D\'efinition d'une fonction alg\'ebrique d'une variable}\index{fonction|textbf}\index{ffonction|textbf}
{\bf Exemple :}\\
On veut d\'efinir la fonction $f_1$ d\'efinie pour $x \in \mathbb{R}$, par 
$f_1(x)=x^2+1$.\\
 $f$ est le nom de la fonction et $x$ est le nom de l'argument de $f_1$ (ici $x$
 est un r\'eel), la valeur de la fonction  $f_1$ est $x^2+1$.\\
{\bf Remarque} : En math\'ematique on dit que $x$ est une variable.\\ 
 En syntaxe {\tt Xcas}, on tape simplement :\\
\giacinput{f1(x):=x^2+1;} \\
On pourrait aussi d\'efinir {\tt f1} par un programme
avec {\tt fonction...ffonction} et {\tt retourne} :\\
\giacinput{fonction f1(x) retourne x^2+1; ffonction;}\\
En syntaxe \`a la Python\\
\begin{giacprog}
def f1(x):
    return x^2+1
\end{giacprog}
\giacinput{f1(5)}

\subsection{D\'efinition d'une fonction alg\'ebrique de 2 variables}\index{iquorem}\index{irem}\index{iquo}\index{plotfunc}\index{=}\label{sec:valdef}
{\bf Exemple} :\\
On veut d\'efinir la fonction $f_2$ d\'efinie pour $(x,y) \in \mathbb{R}^2$, 
par $f_2(x,y)=x^2+y^2$.\\
 $f_2$ est le nom de la fonction et $f_2$ a 2 arguments r\'eels : $x,y$ (en 
math\'ematique on dit que $x,y$ sont les variables de $f_2$). La valeur 
de la fonction  $f_2$ est $x^2+y^2$.\\ 
On tape simplement :\\
\giacinput{f2(x,y):=x^2+y^2}\\
Ou on tape :\\
\giacinput{fonction f2(x,y)  retourne x^2+y^2; ffonction}\\
{\bf Valeur par d\'efaut d'une variable}\\
On peut d\'efinir la {\bf valeur par d\'efaut} de la variable {\tt y} et ainsi
donner  le m\^eme nom $f$ aux 2 fonctions $f_1$ et $f_2$ d\'efinies 
pr\'ec\'edement.\\
Ainsi la fonction $f$ sera d\'efinie par :\\
si elle a une variable $x$ alors $f(x)=x^2+1$ et \\
si elle a 2 variables $x,y$ alors $f(x,y)=x^2+y^2$.\\  
En syntaxe {\tt Xcas}, on tape  alors simplement :\\
\giacinput{f(x,y=1):=x^2+y^2}\\
Ou on tape :\\
\giacinput{fonction f(x,y=1) retourne x^2+y^2;ffonction}\\
\giacinput{f(3,4)}\\
\giacinput{f(3)}\\
En syntaxe \`a la Python:\\
\begin{giacprog}
def f(x,y=1) : 
    return x^2+y^2;
\end{giacprog}
\giacinput{f(3,4)}\\
\giacinput{f(3)}\\
{\bf Autre exemple} :\\
On veut d\'efinir la fonction $g$ d\'efinie pour $(a,b) \in \mathbb{N}^2$ par 
$g(a,b)=q,r$ o\`u $q,r$ d\'esigne  le quotient et le reste de la division 
euclidienne de $a$ par $b$.\\
On tape simplement :\\
\giacinput{g(a,b):=iquorem(a,b);}\\
ou bien  avec {\tt fonction...ffonction} et {\tt retourne} : \\
\giacinputbig{fonction g(a,b) retourne iquorem(a,b); ffonction;}\\
$g$ est le nom de la fonction, $a,b$ sont les noms des arguments de $g$ ($a$ et
$b$ sont des entiers) et {\tt iquorem} renvoie le quotient et le reste de la 
division euclidienne de $a$ par $b$ sous la forme d'une liste.\\
On a aussi les instructions :\\
{\tt iquo(a,b)} qui renvoie le quotient de la division euclidienne de $a$ par 
$b$.\\
{\tt irem(a,b)} qui renvoie le reste de la division euclidienne de $a$ par $b$.\\
et on a donc {\tt iquorem(a,b)} est identique \`a {\tt [iquo(a,b),irem(a,b)]}.\\
\giacinputmath{g(25,3)}

\subsection{D\'efinition d'une fonction alg\'ebrique 
sans lui donner un nom}\index{->}\index{lambda}
On peut d\'efinir une fonction sans la nommer, cela permet de la
passer en argument d'une autre commande (par exemple une commande
de recherche de racines par dichotomie).\\
En syntaxe {\tt Xcas}\\
Par exemple pour d\'efinir la fonction $x->x^2+1$, on \'ecrit simplement :\\
{\tt x->x\verb|^|2+1}.\\
\giacinput{x->x^|2+1}\\
On tape pour avoir la valeur de cette fonction en $x=5$ :\\
\giacinput{(x->x^|2+1)(5)}\\{\tt  (x->x\verb|^|2+1)(5)}\\
Si on veut donner un nom \`a la fonction, on tape :\\
{\tt  f(x):=x\verb|^|2+1}\\
 puis, on tape :\\
\giacinput{ f(5)}
En syntaxe \`a la {\tt Python}\\
Par exemple pour d\'efinir la fonction $x->x^2+1$, on \'ecrit :\\
{\tt lambda x  : x*x+1}.\\
Le logiciel {\tt Xcas} le traduit en $x->x^2+1$.\\
On tape :\\
\giacinput{(lambda x  : x*x+1)(5)}\\
Si on veut donner un nom \`a la fonction, on tape :\\
\begin{giacprog}
def f(x):
    return x*x+1
\end{giacprog}
puis, on tape :\\
\giacinput{f(5)}

{\bf Remarque : il n'y a pas de risques de confusion !} \\
Si vous avez une variable {\tt lambda} qui est affect\'ee, l'\'ecriture :\\
{\tt (lambda x  : x*x+1)(5)}, ne modifie pas cette variable.\\
On tape pour d\'efinir la fonction {\tt lambda} :\\
\giacinput{lambda(x):=x+1}
On tape pour avoir la valeur de la fonction {\tt lambda} en $x=5$ :\\
\giacinput{lambda(5)}\\
On tape pour d\'efinir une fonction sans nom :\\
\giacinput{lambda x : x*x+1}\\
On tape pour avoir sa valeur en $x=5$ :\\
\giacinput{(lambda x : x*x+1)(5)}

\subsection{D\'efinition d'une fonction alg\'ebrique par morceaux avec {\tt quand}}\index{quand}\index{ifte}
%&lt;
{\tt quand} a 3 arguments : une condition (m\^eme symbolique) et 2 expressions : \\
{\tt quand(Cond,Expr1,Expr2)}\\
Si la condition {\tt Cond} est vraie alors {\tt quand} renvoie {\tt Expr1},
si la condition {\tt Cond} est fausse alors {\tt quand} renvoie {\tt Expr2}.

Exemple~: \'ecriture alternative pour la fonction {\tt Abs1} 
d\'efinie par {\tt Abs1}$(x)=|x-1|-1$, on a :
\begin{itemize}
\item si $x>1$ on a {\tt Abs1}$(x)=x-1-1=x-2$
\item si $x \leq 1$ on a {\tt Abs1}$(x)=-x+1-1=-x$
\end{itemize}
On tape :\\
\giacinput{Abs1(x):= quand(x > 1, x-2,-x);}\\
ou bien  avec {\tt fonction...ffonction} et {\tt retourne} : \\
\giacinputbig{fonction Abs1(x) retourne quand(x > 1,x-2,-x); ffonction;}\\
\giacinput{Abs1(1/2),Abs1(1),Abs1(3/2),Abs1(-2),Abs1(2) }\\
\giacinput{plotfunc(Abs1(x),x=-5..7)}\\

{\bf Remarque diff\'erence entre {\tt ifte} et {\tt quand}}\\
\giacinput{f(x):=ifte(x>0,1,0);}\\
\giacinput{f(3),f(-2)}\\
\giacinput{f(x)}\\
Pourquoi une erreur ?\\
Ici {\tt x} n'a pas de valeur : avec {\tt ifte} ou {\tt if then else end\_if} 
il faut que la variable {\tt x} soit affect\'ee pour pouvoir tester la 
condition (quand on d\'efinit une fonction ce qui suit le := n'est pas 
\'evalu\'e donc la d\'efinition de {\tt f(x)} ne pose pas de probl\`eme).\\
Pour la d\'efinition de $g$ avec {\tt when....}, la variable {\tt x} n'a pas
besoin d\^etre affect\'ee. Il n'y a donc pas d'erreur.\\ 
\giacinput{g(x):=quand(x>0,1,0)}\\
\giacinput{g(3),2(-2)}\\
\giacinput{g(x)}

\chapter{Les instructions de programmation utilis\'ees sur des exemples} \label{chap:prog}
On donne ici les instructions en syntaxe Xcas, et en syntaxe Python.
%%%renvoie \`a la section \ref{sec:python} pour la syntaxe Python.
\section{Commentaires et documentation.}
\subsection{Les commentaires dans un programme.}
Pour faire un commentaire, on \'ecrit {\tt //} 
(ou {\tt \#} si on a choisi la syntaxe Python), tout ce qui suit
est le commentaire. 

\subsection{Documenter une fonction avec la commande {\tt help}}
\index{help|textbf}
{\tt help(nom\_prog)} renvoie la 1\`ere ligne d'un programme
(hors commentaire). On peut donc indiquer \`a la personne utilisant un
programme ce que fait ce programme en \'ecrivant
comme premi\`ere ligne du programme une cha\^{\i}ne de caract\`eres 
commentant la fonction.\\
Exemple avec la fonction disciminant {\tt Delta(a,b,c)} qui calcule $b^2-4ac$.\\
On tape en syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Delta(a,b,c) 
  // discriminant
  "calcule b^2-4ac"; 
  return b^2-4a*c;
ffonction:;
\end{giaconload}
\giacinput{help(Delta)}
On tape en syntaxe Python :
\begin{giacprog}
def Delta(a,b,c) :
    # discriminant
    "calcule b^2-4ac" 
    return b^2-4a*c
\end{giacprog}
\giacinput{help(Delta)}


\section{Stocker une valeur dans une variable avec {\tt :=}}\index{:=|textbf}
L'op\'erateur infix\'e {\tt :=} stocke le deuxi\`eme argument dans la variable 
donn\'ee comme premier argument.\\
On peut aussi stocker plusieurs valeurs dans plusieurs variables, par exemple :
En syntaxe {\tt Xcas} :\\
{\tt a,b,c:=1,2,3} ou {\tt (a,b,c):=(1,2,3)} ou {\tt [a,b,c]:=[1,2,3]} \\
En syntaxe \`a la Python :\\
{\tt (a,b,c)=(1,2,3)} ou {\tt [a,b,c]=[1,2,3]}

{\bf Exemple :}\\ 
En syntaxe {\tt Xcas} :\\
\giacinput{a:=3}\\
\giacinput{b:=5}\\
\giacinput{a,b:=a+b,b-a}\\
\giacinput{a,b}
En syntaxe \`a la Python :\\
\giacinput{a=3}\\
\giacinput{b=5}\\
\giacinput{(a,b)=(a+b,b-a)}\\
\giacinput{a,b}

\section{Enlever une valeur stock\'ee dans une variable avec {\tt purge}}\index{purge}
En syntaxe {\tt Xcas} : l'instruction {\tt purge(a)} permet d'enlever une valeur stock\'ee dans la variable {\tt a}. La variable {\tt a} redevient une variable libre i.e. une variable non affect\'ee.\\
En syntaxe \`a la Python : l'instruction {\tt del a} permet d'enlever une 
valeur stock\'ee dans la variable {\tt a}.\\
{\bf Exemple :}\\ 
En syntaxe {\tt Xcas} :\\
\giacinput{a:=3}\\
\giacinput{b:=5}\\
\giacinput{purge(a)}\\
\giacinput{a,b}\\
En syntaxe \`a la Python :\\
\giacinput{a=3}\\
\giacinput{b=5}\\
\giacinput{del a}\\
\giacinput{a,b}
\section{Suite d'instructions avec {\tt ;} ou {\tt :;}}\index{;}\index{:;}
En syntaxe {\tt Xcas}, pour effectuer une suite d'instructions, il suffit 
d'\'ecrire ces instructions les unes \`a la suite des autres, en terminant 
chaque instruction par \verb|;|\\
En syntaxe {\tt Xcas}, on tape :\\
\giacinput{a:=2; b:=3; a*b;}\\
En syntaxe \`a la Python, on tape  :\\
\giacinput{#
a=2 
b=3
a*b}\\
Notez le signe \# qui
force l'interpr\'eteur \`a passer en mode compatible Python.

{\bf Remarque} :\\
Lorsque la r\'eponse est trop longue, on peut aussi utiliser {\tt :;} et 
on obtient {\tt Done} comme r\'eponse.\\ 
\giacinput{a:=2:; b:=[1,2,3,4,5]:; a*b;}\\
Notez qu'\`a l'int\'erieur d'un programme \'ecrit en syntaxe Python
le \verb|;| n'est pas n\'ecessaire, il suffit de s\'eparer les
instructions par un passage \`a la ligne, en respectant la même indentation
que la premi\`ere instruction.

\section{L'instruction {\tt retourne} ou {\tt return}}\index{retourne|textbf}
L'instruction {\tt retourne} arr\^ete imm\'ediatement 
l'ex\'ecution du programme et renvoie la
valeur de l'instruction situ\'ee apr\`es {\tt retourne}.

{\bf Exemple :}\\ 
En syntaxe {\tt Xcas} :\\
\giacinputbig{fonction Delta(a,b,c) retourne b^2-4*a*c; ffonction;}\\
\giacinputbig{fonction Abs(x) 
  si x > 0 alors retourne x;fsi;
  retourne -x;
ffonction;}\\
\giacinput{Delta(3,5,2)}\\
\giacinput{Abs(-3),Abs(3)}
En syntaxe \`a la Python :\\
\begin{giacprog}
def Delta(a,b,c) :
    return b^2-4*a*c
\end{giacprog}
\begin{giacprog}
def Abs(x) :
    if x>0 :
        return x
    return -x
\end{giacprog}
\giacinput{Delta(3,5,2)}\\
\giacinput{(Abs(-3),Abs(3))}

\section{L'instruction {\tt local}}\index{local|textbf}\index{gcd}
{\bf Notion de variables locales:}\\
Supposons qu'on souhaite d\'efinir une fonction $h$ de deux variables $a,b$
($a$ et $b$ sont des entiers) qui renvoie le num\'erateur et le d\'enominateur 
de la fraction $\frac{a}{b}$ simplifi\'ee.\\
Pour cela il faut diviser $a$ et $b$ par leur pgcd qui est {\tt gcd(a,b)}.

En syntaxe {\tt Xcas}, on peut \'ecrire 
{\bf sans utiliser de variables locales}~:\\
\begin{giaconload}
fonction h0(a,b) 
  retourne (a/gcd(a,b),b/gcd(a,b)); 
ffonction:;
\end{giaconload}
En syntaxe \`a la Python
\begin{giacprog}
def h0(a,b) :
     return (a/gcd(a,b),b/gcd(a,b))
\end{giacprog}
Mais on observe que cela n\'ecessite de faire deux fois le calcul de 
{\tt gcd(a,b)}.

Pour \'eviter de faire faire \`a l'ordinateur deux fois le m\^eme
calcul, on va utiliser une variable locale $c$ qui servira \`a 
stocker le calcul interm\'ediaire {\tt gcd(a,b)} 
avec l'instruction : {\tt c:=gcd(a,b)} ({\tt :=} est le 
symbole de l'affectation et {\tt gcd(a,b)} renvoie le pgcd de $a$ et $b$).\\
Cette variable n'est pas visible \`a l'ext\'erieur du programme, les
modifications faites sur {\tt c} dans le programme n'ont aucun effet
sur la variable {\tt c} de la session.\\
On \'ecrit en syntaxe Xcas {\tt local c;} (ne pas oublier le 
{\tt ;}). Le langage Python d\'eclare implicitement les variables
d'une fonction comme variables locales, aussi en syntaxe Python dans
Xcas la d\'eclaration de variables locales se fait par
un commentaire Python {\tt \# local c;}.

D'o\`u La fonction {\bf en utilisant des variables locales}\\
En syntaxe {\tt Xcas} :\\
\begin{giaconload}
fonction h(a,b) 
  local c;
  c:=gcd(a,b);
  retourne (a/c,b/c); 
ffonction:;
\end{giaconload}
\giacinput{a:=12;b:=22;c:=32;}\\
\giacinput{h0(25,15);}\\
\giacinput{h(25,15);}\\
\giacinput{a,b,c}\\
On voit ainsi que les valeurs de {\tt a,b,c} n'ont pas \'et\'e chang\'ees par
l'ex\'ecution des fonctions {\tt h0} ou {\tt h}.
En syntaxe \`a la Python :\\
\begin{giacprog}
def h(a,b) :
    # local c
    c:=gcd(a,b);
    return (a/c),b/c)
\end{giacprog}
\giacinput{a:=12;b:=22;c:=32;}\\
\giacinput{h0(25,15);}\\
\giacinput{h(25,15);}\\
\giacinput{a,b,c}\\
{\bf Autre exemple :}\\ 
En syntaxe {\tt Xcas} :\\
\begin{giaconload}
fonction Racine(a,b,c) 
  //racine x1,x2 de ax^2+bx+c=0
  "calcule b^2-4ac,x1,x2"; 
  local d,x1;x2;
  d=b^2-4a*c;
  x1=(-b+sqrt(d))/(2a);
  x2=(-b-sqrt(d))/(2a);
  retourne b^2-4a*c,x1,x2;
ffonction:;
\end{giaconload}
\giacinput{help(Racine), Racine(2,1,-3)}\\
\giacinput{Racine(1,2,3)}\\
En syntaxe Python :\\
\begin{giacprog}
def Racine(a,b,c) :
    # racine x1,x2 de ax^2+bx+c=0
    # local d,x1,x2  
    "calcule b^2-4ac,x1,x2"; 
    d=b^2-4a*c
    x1=(-b+sqrt(d))/(2a)
    x2=(-b-sqrt(d))/(2a)
    retourne b^2-4a*c,x1,x2
\end{giacprog}
\giacinput{help(Racine), Racine(2,1,-3)}\\
\giacinput{Racine(1,2,3)}

\section{L'instruction {\tt pour}}\index{pour|textbf}\index{fpour|textbf}
{\bf Exemple de pour : la somme des nombres impairs}\\
On veut, dans cet exemple, d\'efinir une fonction {\tt Simpair(n)} d'une 
variable {\tt n} ({\tt n} est un entier) qui calcule la somme des {\tt n} 
premiers entiers impairs i.e. {\tt 1+3+...+2n-1}.\\
Pour cela, on utilise une variable locale $S$ que l'on initialise \`a 0 :\\ 
{\tt S:=0;}\\
puis on va faire $n$ \'etapes en utilisant cette variable locale $S$.\\ 
$S$ va contenir successivement :\\
\'etape 1 $S:=S+(2*1-1);$ donc $S$ contient 1 (0+1)\\
\'etape 2 $S:=S+(2*2-1);$ donc $S$ contient 4 (1+3)\\
...\\
\'etape $k$ $S:=S+(2*k-1);$ donc $S$ contient $1+3+..2k-1$\\
...\\
\'etape $n$ $S:=S+2*n-1;$ donc $S$ contient $1+3+..2n-1$\\
En syntaxe {\tt Xcas}, on utilise une boucle {\tt pour} :\\
{\tt pour k de 1 jusque n faire S:=S+2*k-1; fpour;}\\

En syntaxe \`a la Python, on utilise une boucle {\tt for} :
\begin{verbatim}
for k in range(1,n+1): 
    S:=S+2*k-1
\end{verbatim}
Dans cette boucle {\tt k} sera successivement \'egal \`a {\tt 1, 2, 3,...n}.\\
On dit que l'instruction {\tt S:=S+2*k-1} figurant dans le corps la  boucle 
sera ex\'ecut\'e {\tt n} fois.\\
{\bf Comment fonctionne cette boucle} {\tt pour} ?
\begin{itemize}
\item la variable {\tt k} est initialis\'ee \`a {\tt 1},
\item les instructions du corps de la boucle sont effectu\'ees 
(ici il y en a une seule {\tt S:=S+2*k-1}),
\item {\tt k} est est incr\'ement\'e  automatiquement de 1 ({\tt k:=k+1}),
\item le test {\tt k<=n} est effectu\'e :
si {\tt k<=n} est vrai,  les instructions du corps de la boucle sont \`a 
nouveau effectu\'ees etc ... \\
sinon on effectue les instructions qui suivent {\tt fpour}.
\end{itemize}
En syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Simpair(n) 
 local S,k;
 S:=0; 
 pour k de 1 jusque n faire 
   S:=S+2*k-1; 
 fpour;
 retourne S; 
ffonction:;
\end{giaconload}
\giacinput{Simpair(5),Simpair(6),Simpair(100)}
En syntaxe \`a la Python :
\begin{giacprog}
def Simpair(n):
    # local S,k
    S=0
    for k in range(1,n+1):
       S=S+2*k-1 
    return(S)
\end{giacprog}
\giacinput{Simpair(5),Simpair(6),Simpair(100)}
On  pourra v\'erifier le r\'esultat, en utilisant la commande  {\tt sum} de
 {\tt Xcas} :\\
\giacinputbig{sum(2*k-1,k=1..5),sum(2*k-1,k=1..6),sum(2*k-1,k=1..100)}
{\bf Interm\`ede math\'ematique}\\1,3,5,7,9,11,
Au vue des r\'esultats obtenus pouvez-vous deviner la valeur de 
{\tt s(100)} ?\\
Pouvez-vous deviner et montrer la formule qui donne {\tt s(n)} ?\\
On devine : $s(n)=1+3+...2n-1=n^2$\\
On sait que pour tout $k \in \mathbb{N}$ on a :\\
$k^2-(k-1)^2=((k-1)+1)^2-(k-1)^2=2k-1$ et\\
$(k+1)^2-k^2=2k+1$\\
Donc :\\
$1=1^2-0^2$ ($k=1$),\\
$3=2^2-1^2$ ($k=2$),\\
$5=3^2-2^2$ ($k=3$),\\
...\\
$2k-1=k^2-(k-1)^2$\\
$2k+1=(k+1)^2-(k)^2$\\
...\\
$2n-1=n^2-(n-1)^2$\\
Donc :\\
$s(n)=1+3+...2n-1=1+(n)^2=1+(4-1)+(9-4)...+(n^2-(n-1)^2)=n^2$\\
En classe de terminales, on peut montrer cette formule par r\'ecurrence :\\
$s(1)=1$ si $s(n)=(n)^2$ alors on a :\\
$s(n+1)=s(n)+2(n+1)-1=(n)^2+2n+1=(n+1)^2$\\
La formule est donc montr\'ee par r\'ecurrence.


\section{L'instruction {\tt pour} avec un {\tt pas}}\index{pas|textbf}
{\bf Exemple de pour avec un pas : la somme des nombres impairs }\\
Revenons \`a l'exemple pr\'ec\'edent :\\
 d\'efinir une fonction {\tt Simpair(n)} d'une variable {\tt n} ({\tt n } est 
un  entier) qui calcule la somme : {\tt 1+3+...+2n-1}.\\
Avec la syntaxe {\tt Xcas}, on peut faire varier la variable {\tt k} avec un 
pas de 2, en commencant par 1 jusque {\tt 2n-1}, on \'ecrit :\\
{\tt pour k de 1 jusque 2*n-1n pas 2 faire  fpour;}\\
Dans ce cas la valeur de {\tt S} doit \^etre augment\'ee \`a chaque pas de la 
valeur {\tt k}.\\
On tape en syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Simpair1(n) 
 local S,k;
 S:=0; 
 pour k de 1 jusque 2*n-1 pas 2 faire 
   S:=S+k; 
 fpour;
 retourne S; 
ffonction:;
\end{giaconload}
\giacinput{Simpair(5),Simpair(6),Simpair(7)}
On tape en syntaxe Python :
\begin{giacprog}
def Simpair1(n):
    # local S,k
    S=0
    for k in range(1,2*n,2):
       S=S+k 
    return(S)
\end{giacprog}
\giacinput{Simpair(5),Simpair(6),Simpair(7)}

{\bf Autre exemple de pour avec un pas : le ticket de caisse}\\
On veut faire le programme d'un ticket de caisse lors d'achats dans 
un magasin qui ne pratique pas de r\'eduction pour les achats en gros.\\
Le programme du {\tt ticketcaisse} a comme param\`etre une liste {\tt L} donnant
le nombre d'un m\^eme article suivi du prix de cet article, par exemple :\\
 si {\tt L:=[2,24,1,15,5,10]} cela signifie qu'il y 2 articles \`a 24 euros, 1 
article  \`a 15 euros et 5 articles  \`a 10 euros.\\
Soit {\tt n:=dim(L)}, dans cet esxemple {\tt n:=6}.\\
On va  parcourir la liste avec une variable {\tt k} : {\tt L[k]} sera le nombre 
d'articles ayant  comme prix {\tt L[ k+1]} : il faut donc, dans cet exemple,
 que {\tt k} prenne successivement pour valeur {\tt 0, 2, 4=n-2}.\\
Pour cela on initialise la somme \`a payer avec 0 : {\tt S:=0} puis\\
 on utilise une boucle {\tt pour} avec un {\tt pas} de 2 :\\ 
{\tt pour k de 0 jusque n-2 pas 2 faire S:=S+L[k]*L[k+1]; fpour;}\\
Dans cette boucle {\tt pour}, la variable {\tt k} est initialis\'ee \`a 
{\tt 0}, puis les instructions du corps de la boucle sont effectu\'ees,
puis {\tt k} est incr\'ement\'e automatiquement de {\tt 2} ({\tt k:=k+2}),\\
puis on fait le test {\tt k<=n-2} si oui les instructions du corps de la boucle 
sont \`a nouveau effectu\'ees etc ... sinon on effectue les instructions qui 
suivent {\tt fpour}.\\
En syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Ticketcaisse(L) 
 local S,n,k;
 n:=dim(L);
 S:=0;
 pour k de 0 jusque n-2 pas 2 faire S:=S+L[k]*L[k+1]; fpour;
 retourne S; 
ffonction:;
\end{giaconload}
\giacinput{Ticketcaisse([1,12,3,5,2,8])}\\
\giacinput{1*12+3*5+2*8}\\
En syntaxe \`a la Python :
\begin{giacprog}
def Ticketcaisse(L) :
    # local S,n,k
    n=size(L)
    S=0
    for k in range(0,n-1,2) :
        S=S+L[k]*L[k+1]
    retourne S 
\end{giacprog}
\giacinput{Ticketcaisse([1,12,3,5,2,8])}\\
\giacinput{1*12+3*5+2*8}

\section{L'instruction {\tt si}}\index{si|textbf}\index{alors|textbf}\index{sinon|textbf}\index{fsi|textbf}\label{sec:Prix}
Lorsque l'on veut faire des instructions seulement si une condition est 
r\'ealis\'ee on utilise l'instruction {\tt si}.\\
Cette instruction a 2 formes :\\
En syntaxe {\tt Xcas} :\\
{\tt si <condition> alors <instruction>; fsi;}\\
et\\
 {\tt si <condition> alors <instruction1>; sinon <instruction2> fsi;}\\
{\bf Comment fonctionne le test {\tt si ... alors ... fsi} ?}
\begin{itemize}
\item On \'evalue la condition : une condition a 2 valeurs possibles {\tt vrai}
 ou {\tt faux} c'est ce que l'on nomme un bool\'een,
\item Si la condition est vraie : on effectue les {\tt <instruction>},
et  si la condition est fausse : on ne fait rien,
\item On effectue ensuite les instructions qui suivent {\tt fsi;}.
\end{itemize}
{\bf Comment fonctionne le test {\tt si ... alors ...sinon ... fsi} ?}
\begin{itemize}
\item On \'evalue la condition : une condition a 2 valeurs possibles {\tt vrai}
 ou {\tt faux} c'est ce que l'on nomme un bool\'een,
\item Si la condition est vraie : on effectue les {\tt <instruction1>} et  si 
la condition est fausse : on effectue les {\tt <instruction2>},
\item On effectue ensuite les instructions qui suivent {\tt fsi;}.
\end{itemize}
En syntaxe \`a la Python :
\begin{verbatim}
if <condition> : 
   <instruction>
\end{verbatim}
et
\begin{verbatim}
if <condition> : 
   <instruction1>
else :
    <instruction2>
\end{verbatim}

{\bf Exemple de si alors fsi : somme des nombres premiers <= n}\\
{\bf Rappel} Un nombre premier est un entier $n$ qui admet 2 diviseurs qui sont
1 et $n$, par exemple : 17 est un nombre premier et 1 4 ne sont pas des nombres 
premiers.\\ 
On veut d\'efinir une fonction {\tt Spremier(n)} d'une variable {\tt n} 
({\tt n } est un  entier) qui calcule la somme des nombres premiers inf\'erieurs
 ou \'egaux \`a {\tt n} : {\tt 2+3+5+7+11...+p} pour {\tt p} premier et 
{\tt p<=n}. Pour cela on utilisera la fonction bool\'eenne {\tt est\_premier}
de {\tt Xcas} qui teste si un nombre entier est premier.\\
Si {\tt est\_premier(k)==vrai} et si {\tt k<=n} alors la valeur de {\tt S} doit 
\^etre augment\'ee  de la valeur {\tt k}.\\
Pour cela, on utilise une variable locale {\tt S} (la somme) et le test :\\
en syntaxe {\tt Xcas} :\\
{\tt si est\_premier(k) alors S:=S+k fsi;}\\
en syntaxe Python :\\
\begin{verbatim}
if est_premier(k): 
    S:=S+k
\end{verbatim}

\`A part le nombre 2 les nombres premiers sont impairs, donc on initialise 
{\tt S} \`a  2 puis, on fait varier {\tt k} de 3 jusque {\tt n} avec 
un pas de 2.\\
En syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Spremier(n) 
 local S,k;
 S:=2; 
 pour k de 3 jusque n pas 2 faire 
   si est_premier(k) alors S:=S+k fsi; 
 fpour;
 retourne S; 
ffonction:;
\end{giaconload}
\giacinput{Spremier(10),Spremier(11),Spremier(20)}\\
On tape en syntaxe Python :
\begin{giacprog}
def Spremier(n):
    # local S,k
    S=2
    for k in range(3,n+1,2):
        if est_premier(k) :
            S=S+k 
    return(S)
\end{giacprog}
\giacinput{Spremier(10),Spremier(11),Spremier(20)}\\
{\bf Exercice : combien y-a-t-il de nombres premiers <= n ?}\\
Modifier l'algorithme pr\'ec\'edent pour d\'efinir la fonction 
{\tt Nbpremiers(n)} d'une variable {\tt n} ({\tt n } est un  entier) qui 
calcule le nombre de nombres premiers qui sont inf\'erieurs
 ou \'egaux \`a {\tt n}.\\
En syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Nbpremiers(n) 
 local S,k,N;
 si n<2 alors retourne 0 fsi;
 N:=1; 
 pour k de 3 jusque n pas 2 faire 
   si est_premier(k) alors N:=N+1 fsi; 
 fpour;
 retourne N; 
ffonction:;
\end{giaconload}
\giacinput{Nbpremiers(10),Nbpremiers(20),Nbpremiers(100)}\\
En syntaxe \`a la Python :
\begin{giacprog}
def Nbpremiers(n):
    # local S,k,N
    if n<2 :
        retourne 0
    N=1
    for k in range(3,n+1,2) :
        if est_premier(k) :
            N=N+1 
    return(N)
\end{giacprog}
\giacinput{Nbpremiers(10),Nbpremiers(20),Nbpremiers(100)}
On  pourra v\'erifier le r\'esultat, en utilisant la commande  {\tt nprimes} de
 {\tt Xcas} :\\
\giacinput{nprimes(10),nprimes(20),nprimes(100)}

{\bf Autre exemple du test si alors sinon fsi: le ticket de caisse}\\
Dans un magasin on favorise les achats en gros :\\
si un article {\tt a} a comme prix affich\'e {\tt P} euros, pour l'achat d'au 
moins 3 articles {\tt a}, vous avez une r\'eduction de 10\%.\\
On veut, dans cet exemple, d\'efinir une fonction {\tt Prix} de 2 variables 
{\tt n} ({\tt n} est un entier) et {\tt P} un r\'eel qui calcule le prix de 
{\tt n} article(s).\\ 
Pour cela, on utilise :\\
En syntaxe {\tt Xcas}, une variable locale {\tt S} qui sera la somme \`a 
d\'ebourser et le test :{\tt si  alors sinon  fsi;}\\ 
En syntaxe \`a la Python, on utilise le test :\\
\begin{verbatim}
if <condition> :
    <instruction1> 
else : 
    <instruction2>
\end{verbatim}
En syntaxe {\tt Xcas}  :
\begin{giaconload}
fonction Prix(n,P) 
 local S;
 si n>=3 alors S:=n*P*0.9; 
 sinon S:=n*P; fsi;
 retourne S;
ffonction:;
\end{giaconload}
\giacinput{Prix(3,8),Prix(2,8)}\\
\giacinput{3*8-3*8*0.1,2*8}\\
En syntaxe \`a la Python :
 \begin{giacprog}
def Prix(n,P) :
    # local S
    if n>=3 :
        S:=n*P*0.9
    else :
        S:=n*P
    return S
\end{giacprog}
\giacinput{Prix(3,8),Prix(2,8)}\\
\giacinput{3*8-3*8*0.1,2*8}\\


\section{Utiliser une fonction utilisateur dans un programme}
{\bf Exemple : combien de nombres premiers dans [1,b],[b+1,2b]..[(p-1)b+pb] ?}
On veut d\'efinir une fonction {\tt Lnbpremiers(b,p)} de param\`etres 2 entiers
qui renvoie une liste de {\tt p} entiers qui sont le nombre de nombres premiers 
compris entre 1 et {\tt b},{\tt b+1} et {\tt 2b} ... {\tt (p-1)*b+1} et 
{\tt p*b} de nombres premiers entre 0 et {\tt p*b=n}.\\
Par exemple si {\tt b=10} et {\tt p=3} {\tt Lnbpremiers(b,p)} doit renvoyer:
{\tt [4,4,2]} puisque :\\
entre 1 et 10 il y a 4 nombres premiers (2,3,5,7),\\ 
entre 11 et 20 il y a 4 nombres premiers (11,13,17,19),\\
entre 21 et 30 il y a 2 nombres premiers (23,29).\\

Pour cela on utilisera la fonction utilisateur {\tt Nbpremiers} \'ecrite 
pr\'ec\'edemment en exercice.\\
On tape en syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Lnbpremiers(b,p)
  local L,k,n1,n2,n;
  L:=NULL;
  n:=p*b;
  n1:=Nbpremiers(1);
  pour k de b jusque n pas b faire 
     n2:=Nbpremiers(k);
     L:=L,n2-n1;
     n1:=n2;
  fpour;
  retourne [L];
  ffonction:;
\end{giaconload}
\giacinput{Lnbpremiers(10,30)}\\
\giacinput{Lnbpremiers(100,30)}\\
On tape en syntaxe Python :
\begin{giacprog}
def Lnbpremiers(b,p) :
    # local L,k,n1,n2,n
    L=[]
    n=p*b
    n1=Nbpremiers(1)
    for k in range(b,n+1,b) : 
        n2=Nbpremiers(k)
        L.append(n2-n1)
        n1=n2
    return L;
\end{giacprog}
\giacinput{Lnbpremiers(10,30)}\\
\giacinput{Lnbpremiers(100,30)}\\

{\bf  Autre exemple : le ticket de caisse}\\
On veut faire le programme du ticket de caisse lorsque le magasin pratique 
l'achat en gros (la liste {\tt L}  doit sp\'ecifier le nombre $n$ d'un m\^eme 
article de prix $P$).\\
En utilisant la fonction {\tt Prix(n,P)} \'ecrite pr\'ec\'edemment (cf 
\ref{sec:Prix}), modifier le programme pr\'ec\'edent lorsque le magasin 
pratique l'achat en gros.\\
En syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Ticketengros(L) 
 local S,n,k; 
 n:=dim(L);
 S:=0;
 pour k de 0 jusque n-2 pas 2 faire 
   S:=S+Prix(L[k],L[k+1]); 
 fpour;
 retourne S; 
ffonction:;
\end{giaconload}
\giacinput{Ticketengros([1,12,3,5,2,8])}\\
\giacinput{12+3*5*0.9+2*8}\\
En syntaxe \`a la Python :
\begin{giacprog}
def Ticketengros(L) :
    # local S,n,k 
    n=dim(L)
    S=0
    for k in range(0,n-1,2) : 
        S=S+Prix(L[k],L[k+1]) 
    return S 
\end{giacprog}
\giacinput{Ticketengros([1,12,3,5,2,8])}\\
\giacinput{12+3*5*0.9+2*8}

\section{L'instruction {\tt tantque}}\index{tantque|textbf}\index{ftantque|textbf}\label{sec:Somme}
{\bf Notion de boucle {\tt tantque}}\\
On utilise une boucle {\tt tantque} lorsque l'on ne conna\^{\i}t pas \`a 
l'avance le nombre d'it\'erations \`a effectuer et que l'on arr\^ete les 
it\'erations quand une condition devient fausse.\\
En syntaxe {\tt Xcas} :\\
{\tt tantque <condition> faire <instructions> ftantque;}\\
En syntaxe \`a la Python :\\
\begin{verbatim}
while  <condition> :
    <instructions>
\end{verbatim}
{\bf Comment fonctionne une boucle {\tt tantque} ?}
\begin{itemize}
\item On \'evalue la condition : une condition a 2 valeurs possibles {\tt vrai}
 ou {\tt faux} c'est ce que l'on nomme un bool\'een,
\item Si la condition est vraie : on effectue  {\tt <instructions>}
et on revient au test,
si la condition est fausse : on passe directement aux 
instructions qui suivent 
{\tt ftantque;}.
\end{itemize}
ou bien on peut dire en langage courant que :\\
{\tt <condition>} est une condition de continuation de la boucle.
tant que la condition est v\'erifi\'ee, on fait les instructions de la boucle.\\
{\bf Traduction d'une boucle {\tt pour} en une boucle {\tt tantque}}\\
{\bf Exemple : somme des \'el\'ements d'une liste}
Soit une liste {\tt L} de nombres r\'eels.\\
On veut faire la somme des r\'eels de {\tt L}.\\
En syntaxe {\tt Xcas} :\\
On tape en utilisant une boucle {\tt pour} :
\begin{giaconload}
fonction Somme(L) 
 local n,j,S;
 n:=dim(L);
 S:=0;
 pour j de 0 jusque n-1 faire
   S:=S+L[j];
 fpour;
 retourne S;
ffonction:;
\end{giaconload}
On tape en utilisant une boucle {\tt tantque} :
\begin{giaconload}
fonction Somme1(L) 
 local n,j,S;
 n:=dim(L);
 S:=0;
 j:=0;
 tantque j <= n-1 faire
   S:=S+L[j];
   j:=j+1;
 ftantque;
 retourne S;
ffonction:;
\end{giaconload}
On peut aussi \'ecrire {\tt Somme2}, mais {\bf Attention} 
\`a l'ordre des instructions de la boucle {\tt tantque} et au test d'arr\^et :
\begin{giaconload}
fonction Somme2(L) 
 local n,j,S;
 n:=dim(L);
 j:=0;
 S:=L[0];
 tantque j < n-1 faire
   j:=j+1;
   S:=S+L[j];
 ftantque;
 retourne S;
ffonction:;
\end{giaconload}
\giacinput{L:=[10,13,22,15,5,27,45,31,78]}\\
\giacinput{Somme(L)}\\
\giacinput{Somme1(L)}\\
\giacinput{Somme2(L)}\\
En syntaxe \`a la Python :\\
On tape en utilisant une boucle {\tt pour} :
\begin{giacprog}
def Somme(L) :
    # local n,j,S
    n=dim(L)
    S=0
    for j in range(n) :
        S:=S+L[j]
    return S
\end{giacprog}
On tape en utilisant une boucle {\tt tantque} :
\begin{giacprog}
def Somme1(L) :
    # local n,j,S
    n=dim(L)
    S=0
    j=0
    while j <= n-1 :
        S=S+L[j]
        j=j+1
    return S
\end{giacprog}
On peut aussi \'ecrire {\tt Somme2}, mais {\bf Attention} 
\`a l'ordre des instructions de la boucle {\tt tantque} et au test d'arr\^et :
\begin{giacprog}
def Somme2(L) :
    # local n,j,S
    n=dim(L)
    j=0
    S=L[0]
    while j < n-1 :
        j=j+1
        S=S+L[j]
    return S;
\end{giacprog}
\giacinput{L:=[10,13,22,15,5,27,45,31,78]}\\
\giacinput{Somme(L)}\\
\giacinput{Somme1(L)}\\
\giacinput{Somme2(L)}\\
On peut v\'erifier ces r\'esultats avec la fonction {\tt sum} de {\tt Xcas} :\\
\giacinput{sum([10,13,22,15,5,27,45,31,78]}\\

{\bf Autre exemple : trouver le n-i\`eme nombre premier}
On veut d\'efinir une fonction {\tt Niemeprem(n)} qui renvoie le 
{\tt n}i\`eme nombre premier.\\
On utilise, pour cela la fonction bool\'eenne {\tt est\_premier} (ou 
{\tt is\_prime}) de {\tt Xcas} qui teste si un nombre entier est premier.\\
A part le nombre 2, les nombres premiers sont impairs, donc on traite le cas de 
2, puis on initialise {\tt k} \`a  3 et on fait varier  {\tt k} avec un pas de 
2.
% a faire avec un pour ...
En syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Niemeprem(n)
  local k,p;
  si n==1 alors retourne 2; fsi;
  k:=3;p:=1;
  tantque p<n faire
    si est_premier(k) alors p:=p+1; fsi;
    k:=k+2;
  ftantque;
  retourne k-2;
ffonction:;  
\end{giaconload}
\giacinput{Niemeprem(10),Niemeprem(100)}\\
 En syntaxe \`a la Python :
\begin{giacprog}
def Niemeprem(n) :
    # local k,p
    if n==1 :
        return 2
    k=3
    p=1
    while p<n :
        if isprime(k) : 
            p=p+1
        k:=k+2
    return k-2
\end{giacprog}
\giacinput{Niemeprem(10),Niemeprem(100)}\\
On pourra v\'erifier le r\'esultat du programme car cette  fonction  existe 
dans {\tt Xcas} c'est {\tt ithprime(n)}\\
\giacinput{ithprime(10),ithprime(100)}\\

\section{Un exercice et un probl\`eme}
\subsection{Exercice}
On veut d\'efinir une fonction {\tt Snpremiers(n)} d'une variable {\tt n} 
({\tt n } est un  entier positif) qui calcule la somme des {\tt n} premiers 
nombres premiers. On utilise, pour cela la fonction bool\'eenne 
{\tt est\_premier} (ou {\tt is\_prime}) de {\tt Xcas} qui teste si un nombre 
entier est premier.\\
A part le nombre 2, les nombres premiers sont impairs, donc on initialise 
{\tt S} \`a  2 et {\tt k} \`a 3 avec un pas de 2.\\

En syntaxe {\tt Xcas}, (l'indice {\tt j} compte les nombres premiers,
l'indice {\tt k} sert \`a chercher les nombres qui sont premiers) :
% a faire avec un pour ...
\begin{giacprog}
fonction Snpremiers(n)
  local S,k,p,j;
  j:=1;
  S:=2;
  k:=3;
  tantque j< n faire
     si est_premier(k) alors 
       S:=S+k;
       j:=j+1;
     fsi;
     k:=k+2;
  ftantque;
  retourne S;
ffonction:;  
\end{giacprog}

\giacinput{Snpremiers(8),Snpremiers(10),Snpremiers(100)}\\
En syntaxe \`a la Python, on tape (l'indice {\tt j} compte les nombres premiers,
l'indice {\tt k} sert \`a chercher les nombres premiers) :
\begin{giacprog}
def Snpremiers(n) :
    # local S,k,p,j
    j=1
    S=2
    k=3
    while j< n :
        if is_prime(k) : 
            S=S+k
            j=j+1
        k=k+2
    return S 
\end{giacprog}
\giacinput{Snpremiers(8),Snpremiers(10),Snpremiers(100)}\\

\subsection{Probl\`eme : le crible d'Eratosth\`ene}
\subsection{Description}
Pour trouver les nombres premiers inf\'erieurs ou \'egaux \`a $N$ :
\begin{enumerate}
\item On \'ecrit les nombres de 2 \`a $N$ dans une liste $TAB$.
\item On met 2 dans la case $P$ .
\item Si $P \times P \leq N$ il faut traiter les \'el\'ements de $P$ \`a $N$~:
on barre tous les multiples de $P$ \`a partir de $P \times P$.
\item On augmente $P$ de 1.\\
Si $P\times P$ est strictement sup\'erieur \`a $N$, on arr\^ete
\item On met le plus petit \'el\'ement non barr\'e de la liste dans la case
 $P$. On reprend \`a l'\'etape 3.
\item on met les \'el\'ements non nuls de $TAB$ dans une liste $PREM$.
\end{enumerate}
\subsection{\'Ecriture de l'algorithme}
\begin{verbatim}
Fonction crible(N)
 local TAB PREM I P
 // TAB et PREM sont des listes
 [] =>TAB
 [] =>PREM
 //on suppose que les indices d'une liste debutent par 0
 pour I de 0 a N faire 
  TAB:=concat(TAB, I)
 fpour
 //On met 0 dans TAB[1] car 1 n'est pas premier
 //barrer 1 a ete realise en le remplacant par 0
 TAB[1]:=0
 //TAB est la liste 0 0 2 3 4 ...N 
 P:=2
 // On a fait les points 1 et 2
 tantque P*P <= N faire
  pour I de P jusque E(N/P) faire
    //E(N/P) designe la partie entiere de N/P
    TAB[I*P]:=0
  fpour
  // On a donc barre tous les multiples de P a partir de P*P
  P:=P+1
  //On cherche le plus petit nombre <= N non barre (i.e. non nul)
  // entre P et N
  tantque (P*P <= N) et (TAB[P]=0) faire
    P=P+1
  ftantque
 ftantque
 //on ecrit le resultat dans une liste PREM
 pour I de 2 a N faire
  si TAB[I]!= 0 alors 
     PREM:=concat(PREM, I)
  fsi
 fpour
 retourne PREM
\end{verbatim}

\subsection{En syntaxe {\tt Xcas}}
\subsubsection{Premi\`ere version}
\begin{giaconload}
//renvoie la liste des nombres premiers<=n selon Eratosthene
crible0(n):={
  local tab,prem,p,j;
  tab:=[0,0];
  prem:=[];
  pour j de 2 jusque n faire
    tab:=append(tab,j);
  fpour;
  p:=2;
  tantque (p*p<=n) faire
    pour j de p jusque floor(n/p) faire
      tab[j*p]:=0;
    fpour
    p:=p+1;
    tantque ((p*p<=n) et (tab[p]==0)) faire
      p:=p+1;
    ftantque;
  ftantque;
  pour j de 2 jusque n faire
    si (tab[j]!=0) alors 
      prem:=append(prem,j);
    fsi
  fpour
  retourne(prem);
}:;
\end{giaconload}
\giacinput{crible0(10000)}\\
\giacinput{crible0(20000)}
\subsubsection{Une version plus efficace}
\begin{enumerate}
\item On utilise {\tt seq} pour d\'efinir {\tt tab} et on remplace les 
affectations {\tt :=} par des affectations par r\'ef\'erence {\tt =<}. 
\begin{verbatim}
tab:=[0,0];
pour j de 2 jusque n faire
 tab:=append(tab,j);
fpour;
\end{verbatim}
par
\begin{verbatim}
tab:=seq(j,j,0,n);
tab[0]=<0; tab[1]=<0;
\end{verbatim}
\item On remplace tout d'abord les affectations {\tt :=} d'\'el\'ements d'une 
liste par une affectation par r\'ef\'erence {\tt =<} c'est \`a dire sans
recopier la liste \`a chaque fois qu'on en modifie un \'el\'ement,
ce qui est plus efficace.
\item Puis, lorsque qu'on barre les multiples de {\tt p} premier on remplace les
multiplications de {\tt tab[eval(j*p)]:=0;} par des additions on faisant varier 
{\tt j} avec un pas :
On remplace donc 
\begin{verbatim}
pour j de p jusque floor(n/p) faire
   tab[j*p]:=0;
fpour;
\end{verbatim}
par
\begin{verbatim}
pour j de p*p jusque n pas p faire
    tab[j]=<0;
fpour;
\end{verbatim}
\end{enumerate}
On obtient :
\begin{giaconload}
//renvoie la liste des nombres premiers<=n selon Eratosthene
crible(n):={
  local tab,prem,p,j;
  tab:=seq(j,j,0,n);
  tab[0]=<0; tab[1]=<0; 
  prem:=[];
  p:=2;
  tantque (p*p<=n) faire
    pour j de p*p jusque n pas p faire
      tab[j]=<0;
    fpour
    p:=p+1;
    tantque ((p*p<=n) et (tab[p]==0)) faire
      p=<p+1;
    ftantque;
  ftantque;
  pour j de 2 jusque n faire
    si (tab[j]!=0) alors 
      prem:=append(prem,j);
    fsi
  fpour
  retourne(prem);
}:;
\end{giaconload}
\giacinput{crible(10000)}\\
\giacinput{crible(20000)}
\subsection{En syntaxe \`a la Python}
\subsubsection{Premi\`ere version}
\begin{giacprog}
# renvoie la liste des nombres premiers<=n selon Eratosthene
def crible0(n) :
    # local tab,prem,p,j
    tab =[0,0]
    prem =[]
    for j in  range(2,n+1) :
        tab.append(j)
    p=2
    while (p*p<=n) :
        for j in range(p,floor(n/p)+1) :
            tab[eval(j*p)]=0 
        p=p+1
        while ((p*p<=n) and (tab[p]==0)) :
            p=p+1
    for j in range(2,n+1) :
        if (tab[j]!=0) : 
            prem.append(j)
    return prem
\end{giacprog}
\giacinput{crible0(10000)}\\
\giacinput{crible0(20000)}
\subsubsection{Une version plus efficace}
\begin{giacprog}
//renvoie la liste des nombres premiers<=n selon Eratosthene
def crible(n) :
    # local tab,prem,p,j
    tab=range(0,n+1)
    tab[0]=<0; tab[1]=<0 
    prem=[]
    p=2
    while (p*p<=n) :
        for j in range(p*p,n+1,p) :
            tab[j]=<0
        p=p+1
        while ((p*p<=n) and (tab[p]==0)) :
            p=<p+1
    for j in range(2,n+1) :
        if (tab[j]!=0) :
            prem.append(j)
    return prem;
\end{giacprog}
\giacinput{crible(10000)}\\
\giacinput{crible(20000)}

\section{Autre exemple de boucle {\tt tantque} : le ticket de caisse}\\
En fin de mois, Paul n'a plus qu'une somme {\tt a} dans son porte-monnaie.
Paul fait sa liste de courses {\tt Lc} en mettant au d\'ebut ce qu'il 
veut vraiement acheter et \`a la fin de sa liste, il met les achats qu'il doit 
faire \`a plus long terme. Dans le magasin (qui ne fait pas de r\'eduction), sa
liste de courses {\tt Lc} devient une liste de prix {\tt L}.\\
Dans ce cas, on ne peut pas utiliser une boucle avec {\tt pour} car on ne 
sait pas au d\'epart combien de fois on doit effectuer la boucle.\\
On note {\tt S} la variable qui stockera successivement la somme des prix des 
premiers \'el\'ements de  {\tt L} : pour cela on utilise la fonction 
{\tt Somme(L)} \'ecrite pr\'ecedemment (cf \ref{sec:Somme}).\\
Il veut faire un programme qui arr\^ete sa liste d\`es que {\tt S>a} en coupant 
{\tt L} en 2 listes~:
{\tt La} liste des objets de ce qu'il ach\`ete r\'eellement pour un montant 
{\tt S<=a}  et {\tt Lfin} liste des objets qu'il n'ach\`ete pas ({\tt Lfin} est 
une liste vide lorsque  {\tt Somme(L)<=a}).\\
{\tt Ticketfindemois(L,a)} doit renvoyer {\tt La,Lfin,P} o\`u {\tt P} est la 
somme \`a payer.\\
"arr\^et" se traduit ici par {\tt Lfin ==[] ou S>a} donc\\
"continuation" se traduit ici par {\tt Lfin!=[] et S<=a}.\\
On teste tout d'abord si Paul a assez d'argent pour payer toute sa liste~:
pour cela, on utilise le programme {\tt Somme} pr\'ec\'edent 
(cf \ref{sec:Somme}).\\
Paul a assez d'argent pour payer toute sa liste lorsque {\tt Somme(L)<=a} 
et alors on a {\tt La :=L}, {\tt Lfin :=[]} et {\tt P:=Somme(L)}.\\
Si {\tt Somme(L)>a}, Paul n'a pas assez d'argent donc {\tt Lfin!=[]} est 
vrai et la condition d'arr\^et  est : {\tt S<=a}.
On \'ecrit {\tt Ticketfindemois(L,a)} pour que {\tt k} soit le 
nombre d'articles achet\'es lorsqu' on sort du {\tt tantque}.\\
En syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Ticketfindemois(L,a) 
 local S,n,k,Lfin,La;
 S:=Somme(L);
 si S <=a alors retourne L,[],S fsi;
 n:=dim(L);
 k:=0;
 S:=L[0];
 tantque S <=a faire 
   k:=k+1;
   S:=S+L[k];
  ftantque;
 La:=gauche(L,k);
 Lfin:=droit(L,n-k);
 retourne La,Lfin,S-L[k];
ffonction:;
\end{giaconload}
\giacinput{L1:=[15,10,2,7,5,1.2,3,5.5,10,4,5.3]}\\
\giacinput{Ticketfindemois(L1,50)}\\
\giacinput{L2:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketfindemois(L2,60)}\\
En syntaxe \`a la Python :
\begin{giacprog}
def Ticketfindemois(L,a) : 
    # local S,n,k,Lfin,La
    S=Somme(L)
    if S <=a :
        return L,[],S
    n=dim(L)
    k=0
    S=L[0]
    while S <=a : 
        k=k+1
        S=S+L[k]
    La:=gauche(L,k)
    Lfin:=droit(L,n-k)
    return La,Lfin,S-L[k]
\end{giacprog}
\giacinput{L1:=[15,10,2,7,5,1.2,3,5.5,10,4,5.3]}\\
\giacinput{Ticketfindemois(L1,50)}\\
\giacinput{L2:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketfindemois(L2,60)}\\
On peut aussi \'ecrire  mais {\bf Attention} \`a 
l'ordre des instructions dans le {\tt tantque}. 
\begin{giaconload}
fonction Ticketfindemois1(L,a) 
 local S,n,k,Lfin,La;
 S:=Somme(L);
 si S <=a alors retourne L,[],S fsi;
 n:=dim(L);
 S:=0;
 k:=0;
 tantque S <=a faire 
   S:=S+L[k];
   k:=k+1;
 ftantque;
 La:=gauche(L,k-1);
 Lfin:=droit(L,n-k+1);
 retourne La,Lfin,S-L[k-1];
ffonction:;
\end{giaconload}
\giacinput{L1:=[15,10,2,7,5,1.2,3,5.5,10,4,5.3]}\\
\giacinput{L2:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketfindemois1(L1,50)}\\
\giacinput{Ticketfindemois1(L2,60)}\\
Dans {\tt Ticketfindemois1}, c'est  {\tt k-1} et non {\tt k}, qui est pas la 
valeur du nombre d'articles achet\'es lorsqu'on sort du {\tt tantque}.\\
En effet, lorsqu'on s'arr\^ete  $S$ devient 
sup\'erieur \`a $a$ : il ne faut donc pas acheter l'article {\tt L[k]}.\\
Donc {\tt La:=gauche(L,k-1);} et {\tt Lfin:=droit(L,n-k+1)}.\\

{\bf Remarque}\\
%%%%
On aurait pu aussi \'ecrire sans utiliser {\tt Somme}
mais c'est plus compliqu\'e car la condition du {\tt tantque} porte sur {\tt k}
 et sur {\tt S} !!!
\begin{giacprog}
fonction Ticketfindemois2(L,a) 
  local S,n,k,La,Lfin,P;
  n:=dim(L);
  k:=0;
  S:=L[0];
  tantque S<=a et k<n-1 faire
    k:=k+1;
    S:=S+L[k];
  ftantque;
  si S<=a alors retourne L,[],S fsi;
  La:=gauche(L,k);
  Lfin:=droit(L,n-k);
  P:=S-L[k];
 retourne La,Lfin,P;
ffonction:;
\end{giacprog}
\`A chaque \'etape on a :\\
Au d\'ebut, on a :\\
{\tt k:=0;S:=L[0];} donc  {\tt S} est le prix de {\tt 1} article.\\
lorsqu'on fait $k$ fois la boucle on a :\\
{\tt S:=L[0]+..L[k];} donc {\tt S} est la somme de {\tt k+1} articles.\\
Quand on sort du {\tt tantque} on a :\\
soit {\tt S<=a} est vrai, donc {\tt k==n-1} est vrai (puisque 
{\tt (S<=a et k<n-1)==faux}).\\
{\tt S} est donc la somme de toute la liste {\tt L} i.e. {\tt S} est la somme 
\`a payer pour l'achat de {\tt n} articles i.e. Paul peut acheter toute 
sa liste de courses.\\
soit {\tt S>a} et {\tt k<=n-1} alors {\tt S} repr\'esente la somme des prix des 
{\tt k+1} premiers articles ({\tt k+1} car on a commenc\'e \`a l'article 
{\tt k=0}. Mais Paul ne peut pas acheter le dernier 
article puisque {\tt S>a}. Le prix {\tt P} repr\'esente la somme des prix des 
{\tt k} premiers articles i.e.des articles {\tt L[0],..L[k-1]} ou encore des 
artices de la liste {\tt gauche(L,k)}  donc {\tt P:=S-L[k]}.\\
\giacinput{L1:=[15,10,2,7,5,1.2,3,5.5,10,4,5.3]}\\
\giacinput{L2:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketfindemois2(L1,50)}\\
\giacinput{Ticketfindemois2(L2,60)}

\section{Interruption d'une boucle}\index{retourne}
Si on utilise {\tt retourne} \`a l'int\'erieur d'une boucle dans une fonction, 
celle-ci est interrompue. Ceci permet de 
transformer des boucles "tantque" en boucle "pour" souvent plus lisibles.

Reprenons l'exemple ci-dessus,
on remarque que la boucle tantque utilise un compteur {\tt k}
qu'on incr\'emente \`a chaque it\'eration comme dans une boucle {\tt pour}.
Il est donc naturel d'essayer de r\'e\'ecrire cette fonction avec
une boucle {\tt pour}. Il suffira de tester dans le corps de 
la boucle si la somme (avec le nouvel article)
d\'epasse le contenu du porte-monnaie, dans ce cas il faut s'arr\^eter
sans acheter le nouvel article, on interrompt la boucle et on renvoie les
r\'esultats (on calcule la somme au fur et \`a mesure et donc on n'utilise pas 
la fonction {\tt Somme}).
Dans {\tt Ticketfindemois3}, c'est  {\tt k}, qui est pas la 
valeur du nombre d'articles achet\'es lorsqu'on sort du {\tt pour}.\\
En effet, lorsqu'on s'arr\^ete  $S$ devient 
sup\'erieur \`a $a$ : il ne faut donc pas acheter l'article {\tt L[k]}.\\
Donc {\tt La:=gauche(L,k);} et {\tt Lfin:=droit(L,n-k)}.\\
\begin{giaconload}
fonction Ticketfindemois3(L,a)
  local k,n,S,La,Lfin;
  n:=dim(L);
  S:=0;
  pour k de 0 jusque n-1 faire
    si S+L[k]>a alors 
      La:=gauche(L,k);
      Lfin:=droit(L,n-k);
      retourne La,Lfin,S;
    fsi;
    S:=S+L[k];
  fpour;
  retourne L,[],S;
ffonction:;
\end{giaconload}
\giacinput{L1:=[15,10,2,7,5,1.2,3,5.5,10,4,5.3]}\\
\giacinput{L2:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketfindemois3(L1,50)}\\
\giacinput{Ticketfindemois3(L2,60)}\\
En syntaxe Python:
\begin{giacprog}
def Ticketfindemois3(L,a):
    # local k,n,S,La,Lfin
    n=dim(L)
    S=0
    k=0
    for k in range(n) :        
        if (S+L[k])>a :
            La=gauche(L,k)
            Lfin=droit(L,n-k)
            return La,Lfin,S
        S=S+L[k]
    return(L,[],S)
\end{giacprog}

Cette m\'ethode s'applique pour toute boucle ``tantque'' dont on peut
pr\'evoir \`a priori un majorant du nombre d'it\'erations. On peut
d'ailleurs aussi l'utiliser si on se fixe un nombre maximal d'it\'erations
qui tient compte du temps d'ex\'ecutions, typiquement en {\tt Xcas}
de l'ordre du million d'it\'erations si on veut un
r\'esultat en moins de quelques secondes.

{\bf Remarque}~: si on ne veut pas quitter la fonction, il est quand m\^eme
possible d'interrompre la boucle pr\'ematur\'ement 
en utilisant l'instruction {\tt break}.


\section{Autre exemple de boucle {\tt tantque} : le ticket de caisse}
Pour avoir des clients le dimanche matin, le magasin de Paul offre selon 
les dimanches une r\'eduction imm\'ediate $r$ qui varie selon le montant 
$a$ des achats par exemple une r\'eduction de 10 euros d\`es 60 euros 
d'achats, ou  une r\'eduction de 5 euros d\`es 50 euros d'achats etc...\\
Ce magasin ne pratique pas de r\'eduction pour des achats en gros.\\
Pour \^etre s\^ur de b\'en\'eficier de la r\'eduction, Paul fait sa liste
de courses $Lc$ en mettant au d\'ebut ce qu'il veut vraiement acheter et \`a la
fin de sa liste, il met les achats qu'il doit faire \`a plus long terme
(contrairement au programme pr\'ec\'edent, on suppose ici 
que Paul a suffisamment d'argent).\\
{\bf Attention}\\
On suppose ici que la liste de courses est constitu\'ee par une suite des 
nombres $n$,$P$ o\`u $n$ est le nombre d'achats du m\^eme article de prix $P$.\\
Il veut faire un programme qui arr\^ete sa liste d\`es que $S>=a$ en coupant 
$Lc$ en 2 listes $La$ liste des objets de ce qu'il ach\`ete r\'eellement pour 
un montant $S$ avant r\'eduction et $Lfin$ liste des objets qu'il 
n'ach\`ete pas ($Lfin$ est \'eventuellement une liste vide).\\
Paul veut que son programme ait param\`etres $Lc,a,r$ et qu'il renvoie :\\
$La$, $Lfin$, $S$, $S-r$.\\ 
Dans ce cas, on ne sait pas au d\'epart combien de fois on doit effectuer la 
boucle.\\
Mais on sait quand on doit s'arr\^eter :\\
on arr\^ete la boucle lorsque le prix $S$ de la liste compl\`ete $Lc$ 
n'atteint pas le montant $a$ ou d\'es que le prix $S$ du d\'ebut de $Lc$ 
v\'erifie {\tt S>=a}.\\
On utilise pour cela une boucle {\tt tantque} :\\
{\tt tantque <condition> faire <instructions> ftantque;}\\
Cela veut dire :\\
tant que "non arr\^et", on fait les instructions de la boucle.\\
"arr\^et" se traduit ici par {\tt Lfin ==[] ou S>=a} donc, \\
"non arr\^et" se traduit ici par {\tt Lfin!=[] et S<a}.\\
{\bf Attention} la variable $k$ qui va parcourir la liste {\tt L} devra \^etre 
initialis\'ee (ici {\tt k:=0;}) et modifi\'ee dans le corps de la boucle (ici 
{\tt k:=k+2;}).\\
La fonction {\tt Ticketdimanche} a 3 param\`etres {\tt L,a,r} et renvoie
la liste $La$ des courses qui ont \'et\'e prises en compte,\\
la liste $Lfin$ des courses qui n'ont pas \'et\'e prises en compte (cette liste peut \^etre vide si {\tt S<=a})\\
la somme {\tt S} des achats sans la remise et\\
la somme {\tt S-r} \`a payer.\\
En syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Ticketdimanche(L,a,r) 
 local S,n,k,Lfin,La; 
 n:=dim(L);
 S:=0;
 k:=0;
 tantque k<n et S<a faire 
   S:=S+L[k]*L[k+1];
   k:=k+2;
 ftantque;
 La:=gauche(L,k);
 Lfin:=droit(L,n-k);
 si S<a alors r:=0; fsi;
 retourne La,Lfin,S,S-r;
ffonction:;
\end{giaconload}
\giacinput{L1:=[1,15,2,7,5,1.2,3,5.5]}\\
\giacinput{L2:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketdimanche(L1,50,5)}\\
\giacinput{Ticketdimanche(L2,60,10)}
En syntaxe \`a la Python :
\begin{giacprog}
def Ticketdimanche(L,a,r) :
    # local S,n,k,Lfin,La 
    n=dim(L)
    S=0
    k=0
    while k<n and S<a : 
        S=S+L[k]*L[k+1]
        k=k+2
    La=gauche(L,k)
    Lfin=droit(L,n-k)
    if S<a :
        r=0
    return La,Lfin,S,S-r
\end{giacprog}
\giacinput{L1:=[1,15,2,7,5,1.2,3,5.5]}\\
\giacinput{L2:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketdimanche(L1,50,5)}\\
\giacinput{Ticketdimanche(L2,60,10)}

{\bf Traduction du ``tantque'' en ``pour''}\\
On remarque que la boucle ``tantque'' a un compteur {\tt k}, on peut donc 
la transformer en boucle ``pour'' avec sortie pr\'ematur\'ee de la boucle
lorsque $S>a$.\\
{\bf Attention}  {\tt gauche(L,k)} repr\'esente les {\tt k} premiers 
\'el\'ements de {\tt L} i.e c'est {\tt L[0]..L[k-1]}.\\
Ici, on sort de la boucle {\tt pour} lorsque {\tt S>=a} donc pour avoir la 
r\'eduction il faut acheter {\tt L[k]} fois l'article {\tt L[k+1]}, c'est \`a 
dire prendre en compte la liste {\tt L[0].. L[k+1]} qui est une liste de
{\tt k+2} \'el\'ements c'est donc {\tt gauche(L,k+2)}.
\begin{giacprog}
fonction Ticketdimanche1(L,a,r) 
 local S,n,k,Lfin,La; 
 n:=dim(L);
 S:=0;
 pour k de 0 jusque n-1 pas 2 faire
   S:=S+L[k]*L[k+1];
   si S>=a alors 
     La:=gauche(L,k+2); 
     Lfin:=droit(L,n-k-2); 
     retourne La,Lfin,S,S-r;
   fsi;
 fpour;
 retourne L,[],S,S;
ffonction:;
\end{giacprog}
\giacinput{L1:=[1,15,2,7,5,1.2,3,5.5]}\\
\giacinput{L2:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketdimanche1(L1,50,5)}\\
\giacinput{Ticketdimanche1(L2,60,10)}

En syntaxe Python
\begin{giacprog}
def Ticketdimanche1(L,a,r):
    # local S,n,k,Lfin,La
    n=dim(L)
    S=0
    for k in range(0,n,2):
        S=S+L[k]*L[k+1]
        if S>=a :
            La=gauche(L,k+2)
            Lfin=droit(L,n-k-2)
            return La,Lfin,S,S-r
    return L,[],S,S

\end{giacprog}

\section{Encore un exemple de boucle {\tt tantque} : le ticket de caisse}
Maintenant le magasin de Paul favorise aussi les achats en gros :
 10\% de r\'eduction lorsque on ach\`ete 3 fois le m\^eme produit.
En plus il offre selon les dimanches une r\'eduction imm\'ediate $r$ qui varie 
selon le montant $a$ des achats, par exemple une r\'eduction de 10 euros d\`es 
60 euros d'achats.\\
Modifier les programmes pr\'ec\'edents pour tenir compte des achats en 
gros. On utilise ici la fonction {\tt Prix} \'ecrite pr\'ec\'edemment 
(cf \ref{sec:Prix}).\\
{\bf Attention} comme pr\'ec\'edemment on suppose ici que la liste de courses 
est constitu\'ee par une suite des nombres $n$,$P$ o\`u $n$ est le nombre 
d'achats du m\^eme article de prix $P$.\\
On tape en syntaxe {\tt Xcas} :
\begin{giaconload}
fonction Ticketdimgros(L,a,r) 
 local S,n,k,Lfin,La; 
 n:=dim(L);
 S:=0;
 k:=0;
 tantque k < n et S<a faire 
   S:=S+Prix(L[k],L[k+1]);
   k:=k+2;
 ftantque;
 La:=gauche(L,k);
 Lfin:=droit(L,n-k);
 si S < a alors r:=0 ;fsi;
 retourne La,Lfin,S,S-r;
ffonction:;
\end{giaconload}
\giacinput{L:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketdimgros(L,60,10)}\\
\giacinput{1*15+2*7.8+5*2.2*0.9+4*5.5*0.9}\\
On tape en syntaxe Python :
\begin{giacprog}
def Ticketdimgros(L,a,r) :
    # local S,n,k,Lfin,La 
    n=dim(L)
    S=0
    k=0
    while k < n and S<a :
        S=S+Prix(L[k],L[k+1])
        k=k+2
    La=gauche(L,k)
    Lfin=droit(L,n-k)
    if S < a :
        r=0 
    return La,Lfin,S,S-r
\end{giacprog}
\giacinput{L:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketdimgros(L,60,10)}\\
\giacinput{1*15+2*7.8+5*2.2*0.9+4*5.5*0.9}\\
{\bf Transformation en boucle ``pour''}
\begin{giaconload}
fonction Ticketdimgros1(L,a,r) 
 local S,n,k,Lfin,La; 
 n:=dim(L);
 S:=0;
 pour k de 0 jusque n-1 pas 2 faire
   S:=S+Prix(L[k],L[k+1]);
   si S>=a alors 
     La:=gauche(L,k+2);
     Lfin:=droit(L,n-k-2);
     retourne La,Lfin,S,S-r;
   fsi;
 fpour;
 retourne La,[],S,S;
ffonction:;
\end{giaconload}
\giacinput{L:=[1,15,2,7.8,5,2.2,4,5.5,2,2.7,1,2.1]}\\
\giacinput{Ticketdimgros1(L,60,10)}\\
\giacinput{1*15+2*7.8+5*2.2*0.9+4*5.5*0.9}

En syntaxe Python~:
\begin{giacprog}
def Ticketdimgros1(L,a,r):
    # local S,n,k,Lfin,La
    n=dim(L)
    S=0
    for k in range(0,n,2):
        S=S+Prix(L[k],L[k+1])
        if S>=a :
            La=gauche(L,k+2)
            Lfin=droit(L,n-k-2)
            return La,Lfin,S,S-r
    return La,[],S,S
\end{giacprog}

\section{Exercice : Algorithme de trac\'e de courbe}\index{point}\index{segment}
Soit la fonction {\tt f} d\'efinie sur {\tt [a,b]}.\\
 On veut tracer le graphe de cette fonction sur l'intervalle {\tt [a,b]}.\\
 En partageant {\tt [a,b]} en {\tt n} parties \'egales on obtient : \\
{\tt a=a0,a1=a+h,a2=a+2h, ...b=a+n*h} avec {\tt h=(b-a)/n}.
Le graphe sera obtenu en reliant les points de coordonn\'ees {\tt [a f(a)]}
{\tt [a1 f(a1)]} etc ... par des segments.\\
On tape :
\begin{giaconload}
fonction Graphe(f,a,b,n)
 local L,h,k;
 L:=NULL;
 h:=(b-a)/n;
 pour k de 0 jusque n-1 faire
   L:=L,segment(point(a,f(a)),point(a+h,f(a+h)));
   a:=a+h;
 fpour;
 retourne L;
ffonction:;
\end{giaconload}
\giacinput{f(x):=x^2+1}\\
\giacinput{g(x):=(x+1)/(x-1)}\\
\giacinput{Graphe(f,-2,2,100)}
\giacinput{Graphe(g,-12,12,100)}
\giacinput{Graphe(Abs1,-10,12,100)}

En syntaxe Python~:
\begin{giacprog}
def Graphe(f,a,b,n):
    # local L,h,k
    L=NULL
    h=(b-a)/n
    for k in range(n):
        L=L,segment(point(a,f(a)),point(a+h,f(a+h)))
        a=a+h
    return L
\end{giacprog}

\section{Mettre au point un programme}
Lorsqu'on \'ecrit un programme, il y a deux \'etapes
\`a franchir~:
\begin{itemize}
\item \'Ecrire un programme syntaxiquement correct. Quand on
tape sur le bouton ok, on ``compile'' le programme 
(plus pr\'eci\'sement il est interpr\'et\'e).  
Les erreurs \`a ce stade sont appel\'ees
{\bf erreurs de syntaxe}\index{syntaxe, erreur de}\index{erreur de syntaxe}.\\
Certaines interfaces de {\tt Xcas} essaient de placer
le curseur \`a l'endroit de l'erreur, d'autres affichent le num\'ero
de ligne et colonne de l'erreur. Il faut garder en t\^ete que
l'erreur peut \^etre situ\'ee avant l'endroit indiqu\'e par le curseur
ou dans le message d'erreur, l'endroit indiqu\'e est le premier endroit
o\`u l'interpr\'eteur ne comprend plus la syntaxe.
\item S'assurer que le programme fait bien ce qu'on attend de lui.
Si ce n'est pas le cas on parle d'{\bf erreur 
d'ex\'ecution}\index{ex\'ecution, erreur de}\index{erreur d'ex\'ecution} 
(en anglais runtime error). \\
Pour corriger ce type d'erreur, {\tt Xcas}
propose une commande appel\'ee \verb|debug|\index{debug}. Au lieu d'appeler
directement le programme, on le place dans \verb|debug()|,
par exemple au lieu de taper \verb|Graphe(f,-2,2,100)|
on tape \giacinput{debug(Graphe(f,-2,2,100))}
Le debogueur affiche alors la liste des variables locales et leur valeur
ainsi que la prochaine ligne du programme qui sera ex\'ecut\'ee. On
peut alors ex\'ecuter ligne par ligne le programme avec des arguments
pour lequel on connait la r\'eponse, regarder l'\'evolution
des valeurs des variables et comprendre plus facilement pourquoi
le programme ne fait pas ce qui est attendu.
\end{itemize}

\chapter{R\'esolution d'\'equations}
\section{Encadrer une racine d'une \'equation par dichotomie} \label{sec:dichotomie}
{\bf Algorithme de dichotomie}\\
On suppose que la fonction $f$ est continue sur 
l'intervalle $[a,b]$ et que $f(a)<0$ et $f(b)>0$
(si $f(a)>0$ et $f(b)<0$ on peut se ramener au cas pr\'ec\'edent
en \'echangeant $a$ et $b$).
On en d\'eduit que $f$ s'annule pour $x=x_0$ avec $a<x_0<b$, 
on cherche une valeur approch\'ee de $x_0$.

Pour avoir une meilleur approximation de $x_0$, on cherche le signe de 
$f(c)$ o\`u $c=\frac{a+b}{2}$ est le milieu de $[a,b]$.
Si $f(c)=0$ alors $x_0=c$ et on est content !
Si $f(c)< 0$, il est de m\^eme signe que $f(a)$,
on peut donc remplacer $a$ par $c$, sinon $f(c)>0$ est de 
m\^eme signe que $f(b)$, on peut remplacer $b$ par $c$.
On recommence le processus jusqu\`a ce que
$f(c)=0$ ou $|b-a|<10^{-n}$ (avec par exemple $n=3$).
\begin{giacprog}
fonction Dichotomie0(f,a,b,n)
 local c;
 si f(a)*f(b)>0 alors retourne [] fsi; 
 si f(a)==0 alors retourne [a] fsi;
 si f(b)==0 alors retourne [b] fsi;
 si f(a)>0 alors a,b:=b,a; fsi; // echange a et b pour avoir f(a)<=0
 tantque abs(b-a)>10^(-n) faire
   c:=evalf(a+b)/2;
   si f(c)=0 alors retourne [c] fsi;
   si f(c)<0 alors a:=c; sinon b:=c; fsi; // on a f(a)<=0
 ftantque
 retourne [c];
ffonction:;
\end{giacprog}
Notez le test d'arr\^et qui utilise $|b-a|$ car $a$ et $b$ ont peut-\^etre
\'et\'e \'echang\'es.
Exemple~:\\
\giacinput{f(x):=x^2-2}\\
\giacinput{Dichotomie0(f,1,2,12)}\\
\giacinput{g(x):=cos(x)-x}\\
\giacinput{Dichotomie0(g,0.,1.,12)}

On peut rajouter en d\'ebut de programme
un test sur {\tt n} pour que le nombre d'it\'erations 
ne soit pas trop grand, par exemple\\
{\tt si n>12 alors n:=12; fsi;}\\
On peut aussi utiliser une variable locale pour ne faire qu'une seule fois
le calcul de $10^{-n}$ et de $f(c)$. Ce qui donne le programme suivant~:
\begin{giacprog}
fonction Dichotomie1(f,a,b,n)
 local c,fc,eps;
 si f(a)*f(b)>0 alors retourne [] fsi; 
 si f(a)==0 alors retourne [a] fsi;
 si f(b)==0 alors retourne [b] fsi;
 si f(a)>0 alors a,b:=b,a; fsi; // echange a et b pour avoir f(a)<=0
 si n>12 alors n:=12; fsi;
 eps:=10^(-n);
 tantque abs(b-a)>eps faire
   c:=evalf(a+b)/2;
   fc:=f(c);
   si fc=0 alors retourne [c] fsi;
   si fc<0 alors a:=c; sinon b:=c; fsi; // on a f(a)<0
 ftantque
 retourne [c];
ffonction:;
\end{giacprog}
\giacinput{g(x):=cos(x)-x}\\
\giacinput{Dichotomie1(g,0.,1.,12)}

Il n'est pas indispensable de tester que $f(a)=0$, $f(b)=0$ 
et $f(c)=0$ (comme cela n'arrive
pratiquement jamais, c'est donc inefficace de le faire), 
on peut supprimer ces lignes. Il faut alors utiliser $f(c)\leq 0$
comme test (au lieu de $f(c)<0$)
pour conserver comme invariant de boucle $f(a)\leq 0$ et $f(b)>0$.
\begin{giacprog}
fonction Dichotomie(f,a,b,n)
 local c,eps;
 si f(a)*f(b)>0 alors retourne [] fsi; 
 si f(a)>0 alors a,b:=b,a; fsi; // echange a et b pour avoir f(a)<=0
 si n>12 alors n:=12; fsi;
 eps:=10^(-n);
 tantque abs(b-a)>eps faire
   c:=evalf(a+b)/2; // invariant f(a)<=0 et f(b)>0
   si f(c)<=0 alors a:=c; sinon b:=c; fsi; 
 ftantque
 retourne [c];
ffonction:;
\end{giacprog}
\giacinput{Dichotomie(g,0.,1.,12)}\\

{\bf Traduction du ``tantque'' en ``pour''}\\
On observe qu'\`a chaque it\'eration de la boucle 
on divise la longueur de l'intervalle par 2, le nombre
d'it\'erations ne peut pas \^etre tr\`es grand.
On peut donc transformer la boucle ``tantque'' en boucle ``pour''
en se fixant \`a priori un nombre maximal d'it\'erations ce qui
\'evitera d'ailleurs d'avoir une boucle qui ne se termine jamais. On
montrera plus bas que 2100 it\'erations
suffisent en calcul approch\'e.
\begin{giacprog}
fonction Dichotomie2(f,a,b,n)
 local c,k,eps;
 eps:=10^-n;
 si f(a)*f(b)>0 alors retourne []; fsi; 
 pour k de 1 jusque 2100 faire
   c:=(a+b)/2.0; // invariant f(a)*f(b)<=0
   si b-a<eps alors retourne [c]; fsi;
   si f(a)*f(c)<=0 alors b:=c; sinon a:=c; fsi;
 fpour;
 retourne [c];
ffonction:;
\end{giacprog}
\giacinput{g(x):=cos(x)-x}\\
\giacinput{Dichotomie2(g,0.,1.,12)}\\
{\bf Exercice~:} modifier le programme pour ne pas faire le calcul de $f(a)$
dans la boucle.
 
Remarque avanc\'ee~: 
si on conna\^{\i}t les logarithmes, on peut calculer 
le nombre d'it\'erations $N$ 
pour que $|b-a|/2^N<10^{-n}$ en r\'esolvant cette \'equation.
On peut aussi observer que les calculs se font en approch\'e, dans {\tt Xcas} 
le plus grand nombre repr\'esentable par d\'efaut 
est \verb|evalf(2^(1024-1)|, donc la taille
du plus grand intervalle est (l\'eg\`erement inf\'erieure \`a)
$2^{1025}$. Le plus petit r\'eel strictement positif repr\'esentable
est \verb|evalf(2^(-1069))|. Comme on divise par 2 la taille
de l'intervalle \`a chaque it\'eration, le nombre maximal d'it\'erations
est au plus 1025+1069=2094\footnote{Il faut ajouter 5 pour un langage 
traditionnel
o\`u la mantisse a 53 chiffres significatifs. Attention, ceci n'est
plus valable dans {\tt Xcas} si on modifie la valeur de {\tt Digits}}. 
Au-del\`a, soit $a$ et $b$ sont repr\'esent\'es
par le m\^eme nombre flottant (et le test $|b-a|<10^{-n}$ sera
donc vrai) soit ils ne diff\'ereront que par leur dernier bit de mantisse,
et dans ce cas $c=(a+b)/2$ sera arrondi vers $a$ ou vers $b$ et la boucle
{\tt tanque} continuera ind\'efiniment.\\
La majoration est le plus souvent tr\`es pessimiste, par exemple 
si $a=1$ et $b=2$ ils sont d\'ej\`a repr\'esent\'es avec le m\^eme
exposant et le nombre d'it\'erations sera limit\'e par 48.
\begin{giacprog}
fonction Dichotomie3(f,a,b,n)
 local c,k,N;
 si f(a)*f(b)>0 alors retourne []; fsi; 
 N:=ceil(log((b-a)/10^(-n))/log(2)); 
 si N>2100 alors N:=2100 fsi;
 pour k de 1 jusque N faire
   c:=(a+b)/2.0; // f(a)*f(b)<=0
   si f(a)*f(c)<=0 alors b:=c; sinon a:=c; fsi;
 fpour;
 retourne [c];
ffonction:;
\end{giacprog}
\giacinput{g(x):=cos(x)-x}\\
\giacinput{Dichotomie3(g,0.,1.,12)}

{\bf Exercice~:} Modifier la fonction ci-dessus pour calculer $f$ une
seule fois par it\'eration, c'est-\`a-dire qu'on calcule $c$ et $f(c)$ 
mais qu'on ne recalcule pas $f(a)$.\\
{\bf Premi\`ere m\'ethode~:}\\
On introduit 3 variables locales {\tt fa, fb, fc} contenant les valeurs
de $f(a)$, $f(b)$, $f(c)$. On en profite pour tester au passage si $f(c)=0$.
\begin{giacprog}
fonction Dichotomie4(f,a,b,n)
 local c,k,N,fa,fb,fc;
 fa:=f(a);
 fb:=f(b);
 si fa*fb>0 alors retourne []; fsi; 
 si fa==0 alors retourne [a] fsi;
 si fb==0 alors retourne [b] fsi;
 N:=ceil(log((b-a)/10^(-n))/log(2)); 
 si N>2100 alors N:=2100 fsi;
 pour k de 1 jusque N faire
   c:=(a+b)/2.0;
   fc:=f(c);
   si fc==0 alors retourne [c] fsi;
   si fa*fc<0 alors b:=c; sinon a:=c; fa:=fc; fsi;
 fpour;
 retourne [c];
ffonction:;
\end{giacprog}
\giacinput{g(x):=cos(x)-x}\\
\giacinput{Dichotomie4(g,0.,1.,12)}\\

{\bf Deuxi\`eme m\'ethode :}\\
On \'echange le r\^ole de $a$ et $b$ si $f(a)>0$.
\begin{giacprog}
fonction Dichotomie5(f,a,b,n)
 local c,k,N;
 si f(a)*f(b)>0 alors retourne []; fsi; 
 N:=ceil(log(abs(b-a)/10^(-n))/log(2)); 
 si N>2100 alors N:=2100 fsi;
 si f(a)>0 alors a,b:=b,a; fsi;
 pour k de 1 jusque N faire
   c:=(a+b)/2.0; // invariant f(a)<=0 et f(b)>0
   si f(c)<=0 alors a:=c; sinon b:=c; fsi;
 fpour;
 retourne [c];
ffonction:;
\end{giacprog}
\giacinput{g(x):=cos(x)-x}\\
\giacinput{Dichotomie5(g,0.,1.,12)}\\
Ce programme est optimal.

On peut v\'erifier ces r\'esultats en utilisant la commande {\tt fsolve} de 
{\tt Xcas} qui effectue la r\'esolution num\'erique d'une \'equation :\\
\giacinput{fsolve(cos(x)=x,x,0..1)}

\section{R\'esoudre dans $\mathbb{R}$ une \'equation se ramenant au premier degr\'e ou au degr\'e 2}\label{sec:Solution12}
On consid\`ere une \'equation qui se ram\`ene au premier ou au deuxi\`eme
degr\'e.\\
Si cette \'equation se ram\`ene au premier degr\'e, elle est de la forme :
\begin{center}{\tt a*x+b=0} avec {\tt a!=0}\end{center}
 donc cette \'equation a une solution qui est:\\
 {\tt x0:=-b/a}.\\
Si cette \'equation se ram\`ene au deuxi\`eme degr\'e, elle est de la forme :
\begin{center}{\tt a*x\verb|^|2+b*x+c=0} avec {\tt a!=0}\end{center} 
donc :
\begin{itemize}
\item si $\Delta$={\tt b\verb|^|2-4*a*c>0} il y a 2 solutions qui sont :\\
  {\tt x1:=(-b}+$\sqrt\Delta)${\tt )/(2*a)} et
 {\tt x2:=(-b}-$\sqrt\Delta)${\tt )/(2*a)}.
\item si $\Delta$={\tt b\verb|^|2-4*a*c=0} il y a 1 solution qui est :\\
 {\tt x1} et {\tt x1:=-b/(2*a)}
\item si $\Delta$={\tt b\verb|^|2-4*a*c<0} il n'y a pas de solution r\'eelle.
\end{itemize}
On tape :
\begin{giaconload}
fonction Solution12(Eq,Var)
 local a,b,c,d;
 Eq:=normal(gauche(Eq)-droit(Eq));
 si degree(Eq,Var)==0 alors 
   si (Eq==0) alors retourne "infinite de solution" ;
   sinon retourne "pas de solution" ;
   fsi;
 fsi; 
 si degree(Eq,Var)==1 alors 
   //a:=coeff(Eq,Var,1);b:=coeff(Eq,Var,0);
   b:=subst(Eq,Var=0);
   a:=subst(Eq,Var=1)-b;
   retourne normal([-b/a]);
 fsi;
 si degree(Eq,Var)==2 alors 
   //a:=coeff(Eq,Var,2);b:=coeff(Eq,Var,1);c:=coeff(Eq,Var,0);
   c:=subst(Eq,Var=0);
   d:=subst(Eq,Var=1);
   b:=(d-subst(Eq,Var=-1))/2;
   a:=d-b-c;
   d:=b^2-4*a*c;
   si d>0 alors retourne simplify([(-b+sqrt(d))/(2*a),(-b-sqrt(d))/(2*a)]);fsi;
   si d==0 alors retourne simplify([-b/(2*a)]); fsi;
   retourne [];
 fsi;
 retourne "degree >2";
ffonction:;
\end{giaconload}
\giacinput{purge(x)}\\
\giacinput{Solution12(2*x^2+2*x+2=x^2+2*x+4,x)}\\
\giacinput{Solution12(2*x^2+2*x+2=2x^2+x+4,x)}\\
\giacinput{Solution12(2*x^2+2*x+1=-2*x+31,x)}\\
\giacinput{Solution12(2*x^2+2*x+1=-2*x-2,x)}


\section{R\'esoudre un syst\`eme de deux \'equations du premier degr\'e \`a deux inconnues.}
On veut r\'esoudre le syst\`eme de deux \'equations du premier degr\'e \\
$$ a_1 x+b_1 y+c_1=0, \quad a_2x+b_2y+c_2=0$$
\`a deux inconnues $x,y$. On notera {\tt a1, b1, c1, a2, b2, c2} les
coefficients des \'equations dans les programmes.\\
Pour \'eviter d'\'etudier des cas particuliers inint\'eressants, on va 
supposer que $(a_1,b_1)\neq (0,0)$ et $(a_2,b_2) \neq (0,0)$. 
Dans ce cas $a_1 x+b_1 y+c_1=0$ et $ a_2x+b_2y+c_2=0$
sont les \'equations de 2 droites $D_1$ et $D_2$.

{\bf Solution g\'eom\'etrique}
\begin{itemize}
\item
Si $D_1$ et $D_2$ sont concourantes, il y a une seule solution.
Pour la d\'eterminer, on peut utiliser la commande 
{\tt solve} de {\tt Xcas}\\
\giacinputmath{solve([a1*x+b1*y+c1=0,a2*x+b2*y+c2=0],[x,y])}\\
On justifiera ce r\'esultat plus bas.
\item Si $D_1$ et $D_2$ sont parall\`eles il n'y a pas de solution, sauf si
$D_1$ et $D_2$ sont confondues, il y a une infinit\'e de solutions. On
va montrer que cela se produit si et seulement si $a_1 b_2-a_2b_1 \neq 0$.\\
En effet, 
$D_1$ et $D_2$ sont  parall\`eles lorsque les coefficients $ [a_1,b_1]$ 
et $ [a_2,b_2]$ sont proportionnels i.e si il existe $ k\neq0$ tel que :\\
 $ [a_1,b_1]=k[a_2,b_2]=[ka_2,kb_2]$ ce qui entraine~:
$$ (b_1a_2-b_2a_1)=kb_2a_2-kb_2a_2=0$$
R\'eciproquement, si $ (b_1a_2=b_2a_1)$ alors $D_1$ et $D_2$ sont 
parall\`eles ou confondues.\\
En effet :
\begin{itemize}
\item Si $ b_1=0$ (resp $ a_1=0$) alors $ b_2=0$ (resp $ a_2=0$) puisque 
$ [a_1,b_1]\neq[0,0]$ et $ (b_1a_2=b_2a_1)$,  donc 
$D_1$ et $D_2$ sont parall\`eles \`a l'axe des $ x$  (resp  $ y$).
\item 
Si $ b_1\neq0$ et $ a_1\neq0$ alors $ b_2/b_1==a_2/a_1=k$ ce qui signifie que
$D_1$ et $D_2$ sont parall\`eles ou confondues 
($D_1$ et $D_2$ sont confondues lorsque les coefficients $ [a_1,b_1,c_1]$ 
et $ [a_2,b_2,c_2]$ sont proportionnels i.e si il existe $ k\neq0$ tel que :\\
 $ [a_1,b_1,c_1]=k[a_2,b_2,c_2]=[ka_2,kb_2,kc_2]$).
\end{itemize}
\end{itemize}

On commence par \'ecrire un programme dans le cas o\`u les droites
$D_1$ et $D_2$ sont concourrantes.
\begin{giacprog}
fonction Intersection1(Eq1,Eq2,Var1,Var2)
 local a1,b1,c1,a2,b2,c2;
 Eq1:=normal(gauche(Eq1)-droit(Eq1));
 Eq2:=normal(gauche(Eq2)-droit(Eq2));
 a1:=coeff(Eq1,Var1,1);
 a2:=coeff(Eq2,Var1,1);
 b1:=coeff(Eq1,Var2,1);
 b2:=coeff(Eq2,Var2,1);
 si normal(a1*b2-a2*b1)==0 alors
   retourne "Cas non traite : Eq1 ou Eq2 n'est pas une  "+
          "equation de droite ou droites paralleles"; 
 fsi;
 c1:=subst(Eq1,[Var1,Var2],[0,0]);
 c2:=subst(Eq2,[Var1,Var2],[0,0]);
 print("droites concourantes");
 retourne [normal((-b2*c1+b1*c2)/(a1*b2-a2*b1)),
           normal((a2*c1-a1*c2)/(a1*b2-a2*b1))];
ffonction:;
\end{giacprog}
\giacinput{purge(x,y)}\\
\giacinputbig{d1:=droite(x+y=3);d2:=droite(2x-y=9);d3:=droite(-4x+2y=3)}
\giacinput{Intersection1(x+y=3,2x-y=9,x,y)}\\
\giacinput{Intersection1(4x-2y+9=0,2x-y=3,x,y)}\\

{\bf Exercice~:} modifiez le programme ci-dessus pour \'eviter de calculer
plusieurs fois $a_1b_2-a_2b_1$, en stockant sa valeur dans une variable 
locale.\\

{\bf Correction de l'exercice~:}
\begin{giacprog}
fonction Intersection2(Eq1,Eq2,Var1,Var2)
 local a1,b1,c1,a2,b2,c2,d;
 Eq1:=normal(gauche(Eq1)-droit(Eq1));
 Eq2:=normal(gauche(Eq2)-droit(Eq2));
 a1:=coeff(Eq1,Var1,1);
 a2:=coeff(Eq2,Var1,1);
 b1:=coeff(Eq1,Var2,1);
 b2:=coeff(Eq2,Var2,1);
 d:=normal(a1*b2-a2*b1);
 si d==0 alors
   retourne "Cas non traite : Eq1 ou Eq2 n'est pas une"+
    " equation de droite ou droites paralleles ou confondues"; 
 fsi;
 c1:=subst(Eq1,[Var1,Var2],[0,0]);
 c2:=subst(Eq2,[Var1,Var2],[0,0]);
 print("droites concourantes");
 retourne [normal((-b2*c1+b1*c2)/d),
           normal((a2*c1-a1*c2)/d)];
ffonction:;
\end{giacprog}
\giacinputbig{d1:=droite(x+y=3);d2:=droite(2x-y=9);d3:=droite(-4x+2y=3)}
\giacinput{Intersection2(x+y=3,2x-y=9,x,y)}\\
\giacinput{Intersection2(4x-2y+9=0,2x-y=3,x,y)}\\

Voici maintenant un programme qui teste que les \'equations
entr\'ees sont bien des \'equations de droite et traite aussi 
le cas des droites parall\`eles ou confondues~:
\begin{giacprog}
fonction Intersection(Eq1,Eq2,Var1,Var2)
 local a1,b1,c1,a2,b2,c2,d;
 Eq1:=normal(gauche(Eq1)-droit(Eq1));
 si degree(Eq1,Var1)>1 et degree(Eq1,Var2)>1  alors 
   retourne "pas de degre 1"; 
 fsi;
 Eq2:=normal(gauche(Eq2)-droit(Eq2));
 si degree(Eq2,Var1)>1 et degree(Eq2,Var2)>1 alors 
   retourne "pas de degre 1"; 
 fsi;
 a1:=coeff(Eq1,Var1,1);
 a2:=coeff(Eq2,Var1,1);
 b1:=coeff(Eq1,Var2,1);
 b2:=coeff(Eq2,Var2,1);
 si [a1,b1]==[0,0] ou [a2,b2]==[0,0] alors 
   retourne "Eq1 ou Eq2 est nulle"; 
 fsi;
 c1:=subst(Eq1,[Var1,Var2],[0,0]);
 c2:=subst(Eq2,[Var1,Var2],[0,0]);
 d:=normal(a1*b2-a2*b1);
 si d!=0 alors 
   print("droites concourantes");
   retourne [normal((-b2*c1+b1*c2)/d),
             normal((a2*c1-a1*c2)/d)];
 fsi;
 si a1!=0 et a2!=0 alors 
   si c1*a2-c2*a1==0 alors 
     print("droites confondues");
     retourne [normal(-c1/a1),Var2]; 
   sinon 
     print("droites paralleles");
     retourne [] ;
   fsi;
 fsi;    
 si b1!=0 et b2!=0 alors 
   si c1*b2==c2*b1 alors 
     print("droites confondues");
     retourne [Var1,normal(-c1/b1)]; 
   sinon 
     print("droites paralleles");
     retourne [];
   fsi;
 fsi;
ffonction:;
\end{giacprog}
%On fait la figure avec {\tt Xcas} :\\
%\giacinputbig{d1:=droite(x+y=3);d2:=droite(2x-y=9);d3:=droite(-4x+2y=3)}
\giacinput{Intersection(x+y=3,2x-y=9,x,y)}\\
\giacinput{Intersection(4x-2y+3=0,2x-y=9,x,y)}\\
On v\'erifie avec {\tt Xcas} :\\
\giacinput{coordonnees(inter_unique(d1,d2))}\\
\giacinput{est_parallele(d2,d3)}\\
{\bf Justification de la solution lorsque $D_1$ et $D_2$ sont concourantes}\\
On a vu que c'\'etait le cas si et seulement si
$ b_1a_2-b_2a_1\neq0$.
\begin{itemize}
\item Si $ b_1\neq0$ on a $ y=(-a_1x-c_1)/b_1$ donc l'abscisse du point 
d'intersection de $D_1$ et $D_2$ v\'erifie :\\
$ b_1a_2x+b_2(-a_1x-c_1)+b_1c_2=0$\\
donc $ (b_1a_2-b_2a_1)x+b_1c_2-b_2c_1=0$ et finalement :
$$x=\frac{b_1c_2-b_2c_1}{b_2a_1-b_1a_2} $$
On remplace dans l'expression de $y$ en fonction de $x$ :
$$y=\frac{1}{b_1}(-a_1\frac{b_1c_2-b_2c_1}{b_2a_1-b_1a_2}-c_1)=\frac{1}{b_1}(\frac{-a_1b_1c_2+a_1b_2c_1-c_1(b_2a_1-b_1a_2)}{b_2a_1-b_1a_2})$$
Donc
$$y=\frac{-a_1b_1c_2+c_1b_1a_2}{b_1(b_2a_1-b_1a_2)}=\frac{-a_1c_2+c_1a_2}{b_2a_1-b_1a_2}$$
%\begin{eqnarray*}
% y&=&\frac{-a_1\frac{b_1c_2-b_2c_1}{b_2a_1-b_1a_2}-c_1}{b_1}\\
%&=&\frac{\frac{-a_1b_1c_2+a_1b_2c_1-c_1(b_2a_1-b_1a_2)}{b_2a_1-b_1a_2}}{b_1}\\
%&=&\frac{-a_1b_1c_2+c_1b_1a_2}{b_1(b_2a_1-b_1a_2)} \\
%&=& \frac{-a_1c_2+c_1a_2}{b_2a_1-b_1a_2}
%\end{eqnarray*}
\item
Si $ b_1=0$, on va voir que les m\^emes formules s'appliquent.
En effet l'abscisse du point d'intersection de 
$D_1$ et $D_2$ v\'erifie $a_1x+c_1=0$  donc 
$$x=-\frac{c_1}{a_1}=\frac{b_1c_2-b_2c_1}{b_2a_1-b_1a_2}$$
Comme $b_2\neq0$, on a 
$$y=\frac{-a_2x-c_2}{b_2}=\frac{a_2\frac{c_1}{a_1}-c_2}{b_2}=\frac{a_2 c_1-a_1 c_2}{a_1b_2}=\frac{-a_1c_2+c_1a_2}{b_2a_1-b_1a_2}$$
%\begin{eqnarray*}
%y&=&\frac{-a_2x-c_2}{b_2}\\
%&=&\frac{a_2\frac{c_1}{a_1}-c_2}{b_2}\\
%&=& \frac{a_2 c_1-a_1 c_2}{a_1b_2}\\
%&=& \frac{-a_1c_2+c_1a_2}{b_2a_1-b_1a_2}
%\end{eqnarray*}
\end{itemize}


\chapter{Les figures en g\'eom\'etrie plane avec {\tt Xcas}}
\section{Le point : {\tt point} et le segment : {\tt segment}}\index{point}\index{segment}
\noindent{\tt point} a comme arguments l'abscisse et l'ordonn\'ee du point.\\
{\tt point} trace le point \`a l'aide d'une croix sur l'\'ecran de 
g\'eom\'etrie $2d$.\\
Si on a donn\'e un nom au point (par ex {\tt A:=point(1,1);} ou 
{\tt A:=point([1,1]);}) ce nom sera affich\'e \`a c\^ot\'e de la croix.\\
\giacinput{A:=point(1,1);B:=point(2,3);}
{\tt segment} a comme argument 2 points.\\
{\tt segment} trace le segment reliant ces 2 points sur l'\'ecran de 
g\'eom\'etrie $2d$.\\
\giacinput{A:=A;B:=B;segment(A,B);}
\section{Les coordonn\'ees d'un point : {\tt coordonnees}}\index{coordonnees}
\noindent{\tt coordonnees} a comme argument 1 point.\\
{\tt coordonnees} renvoie la liste constitu\'e de l'abscisse et de l'ordonn\'ee
 du point.\\
\giacinput{coordonnees(A)}\\
\giacinput{coordonnees(B)}
\section{La droite et son \'equation : {\tt droite} et {\tt equation}}\index{droite}\index{equation}
\noindent{\tt droite} a comme argument 2 points.\\
{\tt droite} trace la droite passant par ces 2 points sur l'\'ecran de 
g\'eom\'etrie $2d$.\\
\giacinput{A:=A;B:=B;d:=droite(A,B);}
{\tt equation} a comme argument une droite.\\
{\tt equation} renvoie l'\'equation de cette droite\\
\giacinput{equation(d)}
\section{Ligne bris\'ee : {\tt polygone\_ouvert}}\index{polygone\_ouvert}
\noindent{\tt polygone\_ouvert} a comme argument une liste {\tt L} de points.\\
{\tt polygone\_ouvert} trace la ligne bris\'ee joignant les points 
{\tt L[k]} et {\tt L[k+1]} pour {\tt k=0..dim(L)-2}.\\
\giacinputbig{A:=point(1,1);B:=point(2,3);C:=point(3,2);D:=point(2,0);polygone_ouvert(A,B,C,D)}
\section{Les polygones : {\tt triangle, carre, polygone}}\index{polygone}\index{triangle}\index{carre}
\noindent{\tt triangle} a comme argument 3 points.\\
{\tt triangle} trace le triangle d\'efini par ces 3 points sur l'\'ecran de 
g\'eom\'etrie $2d$.\\
\giacinput{A:=A;B:=B;C:=C;triangle(A,B,C)}
{\tt carre} a comme argument 2 points.\\
{\tt carre} trace le carr\'e direct d\'efini par ces 2 points sur l'\'ecran de 
g\'eom\'etrie $2d$.\\
\giacinput{A:=A;D:=D;carre(A,D)}
\giacinput{A:=A;D:=D;carre(D,A)}
{\tt polygone} a comme argument une liste de points.\\
{\tt polygone} trace le polygone ferm\'e d\'efini par cette liste de points sur 
l'\'ecran de g\'eom\'etrie $2d$.\\
\giacinput{A:=A;B:=B;C:=C;D:=D;polygone(A,B,C,D)}
{\bf Exercice}\\
Faire un programme qui trace les polygones r\'eguliers connaissant son centre 
$C$, un de ses sommets $A$ et le nombre $n$ de c\^ot\'es.\\
\begin{giaconload}
fonction Isopolygonec(C,A,n)
 local L,k;
 L:=NULL;
 L:=A;
 pour k de 0 jusque n-1 faire
   L:=L,C+(A-C)*exp(2*i*k*pi/n);
 fpour;
 retourne polygone(L);
ffonction:;
\end{giaconload}
{\tt Xcas}, la fonction {\tt isopolygone} a 3 arguments  : 2 sommets 
 et $n$ le nombre de c\^ot\'es ou bien le centre du polygone, un sommet 
et un nombre n\'egatif $-n$ qui a comme valeur absolue le nombre $n$ de 
c\^ot\'es.\\
Avec {\tt Xcas}, on tape :\\
\giacinput{isopolygone(point(1),point(i),-6)} 
qui est identique \`a :\\
\giacinput{Isopolygonec(point(1),point(i),6)}

\section{Le cercle  et son \'equation : {\tt cercle} et {\tt equation}}\index{cercle}\index{equation}
Si le cercle est d\'efini par son centre et son rayon alors
{\tt cercle} a pour argument un point et un r\'eel {\tt r}.\\ 
{\tt cercle} trace le cercle de centre ce point et de rayon {\tt abs(r)}
sur l'\'ecran de g\'eom\'etrie $2d$.\\ 
\giacinput{A:=point(1,1);C1:=cercle(A,-2)}
\giacinput{equation(C1)}

Si le cercle est d\'efini par son diam\`etre alors
{\tt cercle} a pour argument 2 points.\\
 {\tt cercle} trace le cercle de diam\`etre ces 2 points.\\
\giacinput{A1:=point(1,1);A2:=point(2,3);C2:=cercle(A1,A2)}
\giacinput{equation(C2)}

\section{Les tangentes \`a un cercle passant par un point et leurs \'equations}
Si {\tt C} est un cercle et {\tt B} un point situ\'e \`a l'ext\'erieur de
(resp sur) {\tt C} alors {\tt tangent(C,B)} trace les (resp la) tangente(s) \`a 
{\tt C} passant par {\tt B}.\\
\giacinputbig{B:=point(3,1);C1:=cercle(point(1,1),1);T1:=tangent(C1,B);}
\giacinput{equation(T1)}\\
\giacinputbig{B:=point(3,1);C2:=cercle(A1,A2);T2:=tangent(C2,B);}
\giacinput{equation(T2);}
 
\section{Exercice : les lunules d'Hippocrate}
Ce th\'eorème, très ancien, a \'et\'e d\'emontr\'e par Hippocrate de Chios 
(-500) (Ne pas le confondre avec Hippocrate de Cos, le m\'edecin), qui \'etudia 
aussi la duplication du cube, c’est-à-dire le calcul de la racine cubique de 2.\\
Hippocrate recherchait alors la quadrature du cercle et pensait que la 
quadrature de ses lunules allait le rapprocher du but.\\
Une lunule est une portion de surface d\'elimit\'ee par deux arcs de cercles 
non concentriques de rayons diff\'erents. Ces arcs ont m\^emes extr\'emit\'es et
forment un croissant de lune en forme de m\'enisque : convexe d’un côt\'e et 
concave de l’autre.\\
\subsection{Exercice 1}
Soit le triangle $ABC$ rectangle en $A$ et $\mathcal{C}$ le cercle circonscrit 
à $ABC$ (de diamètre $BC$).\\
La lunule $L_{AC}$ est la figure form\'ee par le demi-disque de diamètre $AC$ 
ext\'erieur au triangle $ABC$, auquel on enlève son intersection avec le disque 
d\'elimit\'e par $\mathcal{C}$.\\
La lunule $L_{AB}$ est la figure form\'ee par le demi-disque de diamètre $AB$ 
ext\'erieur au triangle $ABC$, auquel on enl\`eve son intersection avec le 
disque d\'elimit\'e par $\mathcal{C}$.\\
Ces deux lunules (en jaune sur la figure ci-dessous) sont appel\'ees 
{\bf lunules d'Hippocrate}.\\
Montrer que la somme des aires de ces deux lunules $L_{BC}$ et de $L_{BA}$ (en 
jaune) est \'egale à l'aire du triangle $ABC$ (en rouge).\\
On tape pour faire la figure :
\begin{giaconload}
fonction Lunule1()
local A,B,C,L;
L:=NULL;
A:=point(0);
B:=point(2,affichage=quadrant1);
C:=point(3*i,affichage=quadrant1);
L:=L,cercle((A+C)/2,3/2,pi/2,3*pi/2,affichage=3+rempli);
L:=L,cercle(A,B,-pi,0,affichage=3+rempli);
L:=L,cercle(B,C,0,pi,affichage=4+rempli);
L:=L,triangle(A,B,C,affichage=1+rempli);
retourne L;
ffonction:;
\end{giaconload}
\giacinputbig{Lunule1();A:=point(0);B:=point(2,affichage=quadrant1);C:=point(3*i,affichage=quadrant1);}

{\bf Solution}\\
On calcule $S1$ l'aire du triangle $ABC$ :\\
$S1=AB*AC/2$
On calcule $S2$ la somme des aires de $L_{BC}$ et de $L_{BA}$ :\\
$S2$ est obtenue par diff\'erence : $S2$ est \'egale \`a la somme des aires des
demi-cercles de diam\`etres $AB$ et $AC$ \`a laquelle on enl\`eve l'aire en 
bleu.\\
L'aire en bleu est \'egale \`a l'aire du demi-cercle de 
diam\`etre $BC$ \`a laquelle on enl\`eve l'aire $S1$ du triangle $ABC$ :\\
$S2=\pi*AB^2/2+\pi*AC^2/2-(\pi*BC^2/2-S1)$\\
D'apr\`es le th\'eor\`eme de Pythagore on a  : $AB^2+AC^2=BC^2$ donc :\\
$S2=S1$.
\subsection{Exercice 2}
Soient un carr\'e de c\^ot\'es $l$ et les cercles ayant comme 
diam\`etre les c\^ot\'es du carr\'e.\\
\`A l'ext\'erieur du carr\'e, ces cercles d\'eterminent avec le cercle 
circonscrit au carr\'e 4 lunules.\\
Trouver l'aire des 4 lunules ainsi d\'etermin\'ees.\\
\`A l'int\'erieur du carr\'e, ces cercles en se coupant d\'eterminent 4 
"p\'etales".\\
 Trouver l'aire des 4 "p\'etales" ainsi d\'etermin\'ees.\\
On tape pour faire la figure :
\begin{giaconload}
fonction Lunule2()
local A,B,C,L;
L:=NULL;
L:=L,cercle(point(2),2,-pi/2,pi/2,affichage=1+rempli);
L:=L,cercle(point(2*i),2,0,pi,affichage=2+rempli);
L:=L,cercle(point(-2),2,pi/2,3*pi/2,affichage=3+rempli);
L:=L,cercle(point(0,-2),2,pi,2*pi,affichage=4+rempli);
L:=L,cercle(0,2*sqrt(2),affichage=5+rempli);
L:=L,cercle(point(0,-2),2);
L:=L,cercle(point(0,2),2);
L:=L,cercle(point(2,0),2);
L:=L,cercle(point(-2,0),2);
L:=L,carre(-2-2*i,2-2*i);
retourne L;
ffonction:;
\end{giaconload}
\giacinputbig{Lunule2();}
{\bf Solution}
Un carr\'e est form\'e de 2 triangles rectangles donc l'aire des 4 lunules est 
\'egale \`a l'aire du carr\'e (cl le r\'esultat pr\'ec\'edent).\\
La somme de l'aire du carr\'e et de  l'aire des "p\'etales" est \'egale \`a 
l'aire des 4 demi-cercles de rayon $l/2$ (car les 4 demi-cercles qui sont \`a 
l'int\'erieur du carr\'e remplissent le carr\'e et se superposent selon les 
"p\'etales") donc l'aire des "p\'etales"=$\pi*l^2/2-l^2$.

\subsection{Exercice 3}
Si la tentative de la quadrature du cercle est un \'echec, Hippocrate a trouv\'e
la quadrature de plusieurs lunules en partant de la remarque suivante :\\
deux secteurs circulaires $OAB$ et $O_1A_1B_1$ de rayon $r$ et $r_1$ semblables 
i.e. dont les angles au centre $a$ ont la m\^eme valeur ont des aires 
proportionnelles aux carr\'es des longueurs de leurs cordes.\\
On tape pour faire la figure :
\begin{giaconload}
fonction Secteurcirc(O,r,t,a)
local A,B,L,xO,yO;
L:=NULL;
[xO,yO]:=coordonnees(O);
A:=point(xO+r*cos(t),yO+r*sin(t));
B:=point(xO+r*cos(t+a),yO+r*sin(t+a));
L:=L,cercle(O,r,t,t+a,affichage=4+rempli);
L:=L,triangle(O,A,B,affichage=1+rempli);
retourne L;
ffonction:;
\end{giaconload}
Voici 2 secteurs circulaires identiques :\\
\giacinputbig{Secteurcirc(-1,1,pi/6,2*pi/5),Secteurcirc(0,1,0,2*pi/5)}
Voici 2 secteurs circulaires semblables :\\
\giacinputbig{Secteurcirc(-1,1,pi/6,2*pi/5),Secteurcirc(0,2,0,2*pi/5)}
Chaque secteur circulaire est compos\'e ici d'un triangle (en rouge) et d'une 
calotte circulaire (en bleu). Les aires des triangles ainsi que les aires des 
calottes circulaires,sont aussi proportionnelles aux carr\'es des longueurs des 
cordes.\\
Montrer ces r\'esultats.\\
{\bf Solution}\\
Si deux secteurs circulaires $OAB$ et $O_1A_1B_1$ de rayon $r$ et $r_1$ ont pour
 angle au centre $a$ on a :\\
La longueur $AB$ vaut $2R\sin(a/2$ donc $r=AB/(2\sin(a/2)$\\
L'aire du secteur circulaire vaut $aR^2/2=AB^2(a/(8\sin(a/2)^2)$\\
L'aire du secteur circulaire est donc proportionnelle \`a $AB^2$.\\
L'aire du triangle $OAB$ vaut  $R^2\cos(a/2)\sin(a/2)=AB^2(1/(4\tan(a/2))$\\
L'aire du triangle est donc proportionnelle \`a $AB^2$.\\
L'aire de la calotte circulaire vaut $AB^2((a/(8\sin(a/2)^2)-(1/(4\tan(a/2))$.\\
L'aire du calotte circulaire est donc proportionnelle \`a $AB^2$.\\
{\bf Application}\\
Soit un triangle $ABC$ isoc\`ele et rectangle en $C$.\\ 
Soit $D$ le sym\'etrique de $C$ par rapport \`a $AB$.\\
Le demi-cercle $ABC$ de diam\`etre $AB$ et le quart de cercle $AMB$ de centre
$D$ d\'efinissent la lunule $AMBC$ en rouge sur la figure.\\
On tape pour faire la figure :
\begin{giaconload}
fonction Lunule3()
local A,B,C,D,L,xO,yO;
L:=NULL;
A:=point(-2);
B:=point(2,affichage=quadrant1);
C:=point([0,2],affichage=quadrant1);
D:=point(0,-2);
L:=L,affichage(cercle(0,2,0,pi),1+rempli);
L:=L,triangle(A,B,C,affichage=4+rempli);
L:=L,affichage(cercle(D,2*sqrt(2),pi/4,3*pi/4),6+rempli);
L:=L,triangle(A,B,D,affichage=3+rempli);
retourne L;
ffonction:;
\end{giaconload}
\giacinputbig{Lunule3();A:=point(-2);B:=point(2,affichage=quadrant1);C:=point(0,2,affichage=quadrant1);M:=point(0,-2+2*sqrt(2))}
{\bf Solution}
L'aire des 2 calottes circulaires rouges est \'egale \`a l'aire de la calotte
 circulaire cyan puisque $AB^2=AC^2+BC^2=2AC^2$ (car le triangle $ABC$ est 
rectangle isoc\`ele de sommet $C$.\\
L'aire du triangle $ABC$ (aire bleue+aire de la calotte circulaire cyan) est 
donc \'egale \`a l'aire de la lunule $AMBC$ (aires des calottes circulaires 
rouges +aire bleue)
\subsection{Exercice 4}
Soit un trap\`eze isoc\`ele $ABCD$ v\'erifiant $BC=CD=AD$ et $AB^2=3DC^2$.\\ 
Soit l'arc de cercle $BCMDA$ de centre $I$ intersection des m\'ediatrices de
$AC$ et de $DC$ (o\`u $M$ est un point de l'arc $CD$).\\
Soit l'arc de cercle $BNA$ tangent \`a $AC$ de centre $J$ intersection de la
m\'ediatrice de $DC$ et de la perpendiculaire en $A$ \`a $AC$.\\
On tape pour faire la figure :
\begin{giaconload}
fonction Lunule4()
local A,B,C,D,I,J,L;
L:=NULL;
A:=point(-sqrt(3.));
B:=point(sqrt(3.));
C:=point(1,sqrt(2*sqrt(3.)));
D:=point(-1,sqrt(2*sqrt(3.)));
//I:=inter_unique(droite(x=0),mediatrice(A,D));
I:=point(0,sqrt(-3+2*sqrt(3.))*sqrt(3.))/3);
//J:=inter_unique(droite(x=0),perpendiculaire(A,droite(A,C)));
J:=point(0,-sqrt(3+2*sqrt(3.)));
L:=L,affichage(cercle(I,evalf(longueur(A,I)),angle(I,I+2,B),2*pi+angle(I,I+2,A)),1+rempli);
L:=L,triangle(A,B,C,affichage=2+rempli);
L:=L,triangle(A,C,D,affichage=2+rempli);
L:=L,affichage(cercle(J,sqrt(6+2*sqrt(3.)),angle(J,J+2,B),angle(J,J+2,A)),4+rempli);
L:=L,affichage(triangle(J,A,B),3+rempli);
L:=L,segment(D,I),segment(C,I),segment(A,C),segment(A,J),segment(J,B),segment(I,J);
retourne L;
ffonction:;
\end{giaconload}

\giacinputbig{Lunule4();A:=point(-sqrt(3.),affichage=quadrant2);B:=point(sqrt(3.),affichage=quadrant1);C:=point(1,sqrt(2*sqrt(3.)),affichage=quadrant1);D:=point(-1,sqrt(2*sqrt(3.)),affichage=quadrant2);I:=point(0,sqrt(-3+2*sqrt(3.))/sqrt(3.));J:=point(0,-sqrt(3+2*sqrt(3.)))}

{\bf Solution}
L'aire de la lunule (rouge + vert) $ABCD$ est \'egale \`a l'aire du trap\`eze 
$ABCD$ (vert+bleu).\\
En effet, l'aire de la calotte bleue est \'egale \`a 3 fois l'aire d'une calotte
rouge  car les secteurs circulaires $JBA$ et $ICD$ sont homoth\'etiques et que 
$AB^2=3DC^2$.\\
On a donc puisque $AD=DC=CB$, l'aire des calottes rouges sont \'egales.\\
Donc l'aire des 3 calottes rouges est \'egale  \`a l'aire bleue  et :\\
aire lunule($ABCD$)=aire trapeze($ABCD$)-aire calotte bleue+3*aire lunule($CD$)\\
Donc \\
aire lunule($ABCD$)=aire trapeze($ABCD$).

\chapter{La g\'eom\'etrie analytique}
Dans ce chapitre, les programmes que l'on va faire ne feront pas de trac\'es 
mais renverront des valeurs (coordonn\'ees, coefficients, \'equations).\\
On pourra alors faire les figures avec {\tt Xcas} et v\'erifier les r\'esultats
obtenus par ces programmes.
\section{Les segments}
\subsection{Calculer la distance de deux points connaissant leurs coordonn\'ees}
\label{sec:Longueur}
Si les points {\tt A} et  {\tt B} ont pour coordonn\'ees {\tt cA:=[xA,yA]} et
 {\tt cB:=[xB,yB]} le segment {\tt AB} a pour longueur :\\
{\tt sqrt((xA-xB)\verb|^|2+(yA-yB)\verb|^|2)}\\
On tape :
\begin{giaconload}
fonction Longueur(cA,cB)
 local xA,xB,yA,yB;
 xA:=cA[0];
 yA:=cA[1];
 xB:=cB[0];
 yB:=cB[1];
 retourne simplify(sqrt((xA-xB)^2+(yA-yB)^2));
ffonction:;
\end{giaconload}
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[-1,-3]}\\
\giacinput{Longueur(cA,cB)}\\
V\'erifions avec {\tt Xcas} :\\
\giacinput{longueur(cA,cB)}
\subsection{Calculer les coordonn\'ees du milieu d'un segment}\label{sec:Milieu}
Si les points {\tt A} et {\tt B} ont pour coordonn\'ees {\tt cA:=[xA,yA]} et 
{\tt cB:=[xB,yB]}, le milieu de {\tt AB} a pour coordonn\'ees 
{\tt [(xA+xB)/2,(yA+yB)/2]} :\\
On tape :
\begin{giaconload}
fonction Milieu(cA,cB)
 local xA,xB,yA,yB;
 xA:=cA[0];
 yA:=cA[1];
 xB:=cB[0];
 yB:=cB[1];
 retourne [(xA+xB)/2,(yA+yB)/2];
ffonction:;
\end{giaconload}
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[-1,-3]}\\
\giacinput{Milieu(cA,cB)}\\
V\'erifions  avec {\tt Xcas} :\\
\giacinput{coordonnees(milieu(cA,cB))}
\section{Les droites}
\subsection{\'Equation d'une droite d\'efinie par 2 points ou par sa pente et un point}\label{sec:Droite}
{\bf \'Equation d'une droite d\'efinie par 2 points}\\
Si les points {\tt A} et {\tt B} ont pour coordonn\'ees {\tt cA:=[xA,yA]} et 
{\tt cB:=[xB,yB]}, la droite {\tt d} passant par {\tt A} et {\tt B} a pour 
\'equation :\\
{\tt (xA-xB)*y-(yA-yB)*x-yB*xA+yA*xB=0} ou encore\\
si {\tt (xA==xB)} alors l'\'equation de {\tt d} est {\tt x=xA} \\
si {\tt (xA!=xB)} alors l'\'equation de {\tt d} est 
{\tt y=(yA-yB)*(x-xB)/(xA-xB)+yB} \\

{\bf \'Equation d'une droite d\'efinie par sa pente et un point}\\
La droite passant par le point {\tt A} de coordonn\'ees 
{\tt cA:=[xA,yA]} et de pente {\tt m} a pour \'equation :\\
{\tt y=m*(x-xA)+yA}.\\
On tape :
\begin{giacprog}
fonction Droite1(cA,cB)
 local xA,xB,yA,yB;
 xA:=cA[0];
 yA:=cA[1];
 xB:=cB[0];
 yB:=cB[1];
 retourne normal((xA-xB)*y-(yA-yB)*x-yB*xA+yA*xB)=0;
ffonction:;

fonction Droite2(cA,m)
 local xA,yA;
 xA:=cA[0];
 yA:=cA[1];
 retourne y-m*(x-xA)-yA=0;
ffonction:;
\end{giacprog}
On peut r\'eunir les 2 programmes en un seul en testant la dimension du 
deuxi\`eme param\`etre de {\tt Droite} qui est soit une liste de dimension 2,
soit un r\'e\'el.\\
On peut aussi faire en sorte que {\tt Droite} accepte 1 seul argument qui soit 
son \'equation : pour cela, on donne au deuxi\`eme argument une valeur par 
d\'efaut (ici cette valeur sera arbitraire par exemple 0) (cf \ref{sec:valdef}).\\
On tape :
\begin{giaconload}
fonction Droite(cA,L=0)
 local xA,xB,yA,yB,m;
 si type(cA)==expression alors retourne cA;fsi;
 xA:=cA[0];
 yA:=cA[1];
 si type(L)==vecteur alors 
   xB:=L[0];
   yB:=L[1];
   retourne normal((xA-xB)*y-(yA-yB)*x-yB*xA+yA*xB)=0;
 sinon
   m:=L;
   retourne y-m*(x-xA)-yA=0;
 fsi;
ffonction:;
\end{giaconload}
Observez qu'on a donn\'e une valeur par d\'efaut 0 
au deuxi\`eme param\`etre \verb|L|, si \verb|Droite| est appel\'ee
avec deux arguments tout se passe comme si on avait \'ecrit
\verb|L| et non \verb|L=0|, par contre si \verb|Droite| est
appel\'ee avec un seul argument, alors \verb|L|  prend la valeur
0 au d\'ebut de la fonction.\\
\giacinput{purge(x,y)}\\
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[-1,-3]}\\
\giacinput{m:=2}\\
\giacinput{Droite(cA,cB)}\\
\giacinput{Droite(cA,m)}\\
\giacinput{Droite(x+y=1)}\\
V\'erifions  avec {\tt Xcas} :\\
\giacinput{equation(droite(point(cA),point(cB)))}\\
\giacinput{equation(droite(point(cA),pente=m))}
\subsection{Coefficients (a,b,c) de la droite d'\'equation ax+by+c=0}\index{coeff}\index{gauche}\index{droit}\label{sec:Coeffsdroite}
\'Etant donn\'ee l'\'equation d'une droite {\tt a*x+b*y+c=0}, on va \'ecrire une
 fonction  qui renvoie les coefficients {\tt a}, {\tt b} et {\tt c}.\\
On utilise tout d'abord {\tt gauche} et {\tt droit} qui renvoie le c\^ot\'e 
gauche et le c\^ot\'e droit d'une \'equation.\\
Par exemple si {\tt Eq:=eq1=eq2}  alors
{\tt gauche(Eq)} renvoie {\tt eq1} et
{\tt droit(Eq)} renvoie {\tt eq2} donc \\
{\tt gauche(Eq)-droit(Eq)} renvoie {\tt eq} 
qui est \'egal \`a  {\tt eq1-eq2}.\\
On peut alors trouver {\tt a}, {\tt b}  et {\tt c} en donnant des valeurs \`a
{\tt x} et {\tt y}.\\
Posons :\\
{\tt c:=subst(eq,[x,y],[0,0])}\\
{\tt d1:=subst(eq,[x,y],[1,0])}\\
{\tt d2:=subst(eq,[x,y],[0,1])}\\
Alors on a {\tt a:=d1-c} et {\tt b:=d2-c}\\
On tape :
\begin{giaconload}
fonction Coeffsdroite(Eq)
 local a,b,c,d1,d2,eq;
 eq:=gauche(Eq)-droit(Eq);
 c:=subst(eq,[x,y],[0,0]);
 d1:=subst(eq,[x,y],[1,0]);
 d2:=subst(eq,[x,y],[0,1]);
 retourne normal(d1-c,d2-c,c);
ffonction:;
\end{giaconload}
\giacinput{Coeffsdroite(y-3*(x-1)-1=0)}\\
\giacinput{Coeffsdroite((1+sqrt(2))^2*x-y+3=0)}\\
{\bf Remarque}\\
On peut aussi utiliser :\\
{\tt coeff(P(x,y),x)} (resp {\tt coeff(P(x,y),y)}) qui renvoie la liste 
des coefficients selon les puissances d\'ecroissantes du polyn\^ome {\tt P} par 
rapport \`a la variable {\tt x} (resp {\tt y}) et\\
{\tt coeff(P(x,y),x,n)} (resp {\tt coeff(P(x,y),y,n)}) qui renvoie le 
coefficient de {\tt x\verb|^|n} (resp de {\tt y\verb|^|n}) du
polyn\^ome {\tt P}.\\
On tape :
\begin{giacprog}
fonction Coeffdroite(Eq)
 local a,b,c;
 Eq:=gauche(Eq)-droit(Eq);
 a:=coeff(Eq,x,1);
 b:=coeff(Eq,y,1);
 c:=subst(Eq,[x,y]=[0,0]);
 retourne normal(a,b,c);
ffonction:;
\end{giacprog}
\giacinput{Coeffdroite(y-3*(x-1)-1=0)}\\
\giacinput{Coeffdroite(Droite(y-3*(x-1)-1=0))}\\
V\'erifions  avec {\tt Xcas} :\\
\giacinputbig{Eq:=y-3*(x-1)-1;[coeff(Eq,x,1),coeff(Eq,y,1),subst(Eq,[x,y]=[0,0])]}

\subsection{Point d'intersection de 2 droites s\'ecantes}
Cette section reprend la section sur la r\'esolution de syst\`eme
de 2 \'equations \`a 2 inconnues.
Soient deux droites {\tt d1} et {\tt d2} d'\'equation :\\
$a_1x+b_1y+c_1=0$ et $a_2x+b_2y+c_2=0$\\
Ces 2 droites sont parall\`eles si $a_1b_2=a_2b_1$.\\
Si $a_1b_2\neq a_2b_1$ {\tt d1} et {\tt d2} sont s\'ecantes.\\
Les coordonn\'ees de leur point d'intersection sont \\
$(-c_2*b_1+b_2*c_1)/(-b_2*a_1+a_2*b_1),(c_2*a_1-a_2*c_1)/(-b_2*a_1+a_2*b_1)$
 {\tt Interdroite(d1,d2)} renvoie {\tt []} si {\tt d1} et {\tt d2} sont 
parall\'eles et sinon renvoie les coordon\'ees de leur point d'intersection.\\
%%B Utiliser CoeffDroite pour eviter des derivees
On utilise les programmes {\tt Droite} et {\tt Coeffsdroite} pr\'ec\'edents 
(cf \ref{sec:Coeffsdroite} pour avoir les coefficients
des \'equations {\tt Eq1} et  {\tt Eq2} de {\tt d1} et de {\tt d2}
On tape :
\begin{giacprog}
fonction Interdroite(d1,d2)
 local a1,a2,b1,b2,c1,c2,gd1,gd2,d;
 (a1,b1,c1):=Coeffsdroite(d1);
 (a2,b2,c2):=Coeffsdroite(d2);
 d:=normal(a2*b1-b2*a1);
 si d==0 alors retourne [];fsi;
 retourne [(b2*c1-b1*c2)/d,(c2*a1-a2*c1)/d];
ffonction:;
\end{giacprog}
\giacinput{d1:=Droite(2x+3y-1=0)}\\
\giacinput{d2:=Droite(-x+y+1=0)}\\
\giacinput{d3:=Droite([1,1],[2,3])}\\
\giacinput{d4:=Droite([1,0],[0,1])}\\
\giacinput{d5:=Droite([1,2],2)}\\
\giacinput{Interdroite(d1,d2)}\\
\giacinput{Interdroite(d3,d4)}\\
\giacinput{Interdroite(d5,d3)}
On fait la figure avec {\tt Xcas}:\\
\giacinputbig{droite(d1),droite(d2),droite(d3),droite(d4),droite(d5)}
V\'erifions  avec {\tt Xcas} :\\
\giacinput{coordonnees(inter_unique(droite(d1),droite(d2)))}\\
\giacinput{coordonnees(inter_unique(droite(d3),droite(d4)))}
\section{Triangles et quadrilat\`eres d\'efinis par les coordonn\'ees des sommets}
On d\'efinit des versions de la commande \verb|polygone| de {\tt Xcas} donc ces 2 programmes vont faire des figures.
\begin{giacprog}
fonction Triangle(cA,cB,cC)
 retourne polygone(cA,cB,cC);
ffonction:;
fonction Quadrilatere(cA,cB,cC,cD)
 retourne polygone(cA,cB,cC,cD);
ffonction:;
\end{giacprog}
\giacinput{cA:=[1,-1]}\\
\giacinput{cB:=[1/2,2]}\\
\giacinput{cC:=[0,3/2]}\\
\giacinput{cD:=[-1/2,0]}\\
\giacinput{Triangle(cA,cB,cC)}
\giacinput{Quadrilatere(cA,cB,cC,cD)}
\section{Les vecteurs}
\subsection{Les coordonn\'ees d'un vecteur d\'efini par 2 points}
Si les coordonn\'ees du point A (resp B) sont {\tt cA:=[xA,yA]} 
(resp {\tt cB:=[xB,yB]}), les coordonn\'ees du vecteur {\tt AB} 
sont {\tt [xB-xA,yB-yA]}.\\
On tape :
\begin{giacprog}
fonction Vecteur(cA,cB)
 local xA,xB,yA,yB;
 xA:=cA[0];
 yA:=cA[1];
 xB:=cB[0];
 yB:=cB[1];
 retourne normal([xB-xA,yB-yA]);
ffonction:;
\end{giacprog}
ou plus simplement :\\
\giacinput{Vecteur(cA,cB):=normal(cB-cA);}\\
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[-1,-3]}\\
\giacinput{Vecteur(cA,cB)}\\
On fait la figure avec {\tt Xcas} :\\
\giacinput{A:=point(cA);B:=point(cB);vecteur(A,B);}
V\'erifions avec {\tt Xcas} :\\
\giacinput{coordonnees(vecteur(A,B))}

\subsection{Calculer les coordonn\'ees de la somme de deux vecteurs dans un rep\`ere}
Si les vecteurs {\tt V1} et {\tt V2} ont pour coordonn\'ees {\tt cV1:=[x1,y1]} 
et {\tt cV2:=[x2,y2]}, les coordonn\'ees du vecteur {\tt V1+V2} sont 
{\tt [x1+x2,y1+y2]}.\\
On tape :
\begin{giacprog}
fonction SumVect(cV1,cV2)
 local x1,x2,y1,y2;
 x1:=cV1[0];
 y1:=cV1[1];
 x2:=cV2[0];
 y2:=cV2[1];
 retourne normal([x1+x2,y1+y2]);
ffonction:;
\end{giacprog}
ou plus simplement :\\
\giacinput{SumVect(cV1,cV2):=normal(cV1+cV2);}\\
\giacinput{cV1:=[1,2]}\\
\giacinput{cV2:=[-2,3]}\\
\giacinput{cV3:=SumVect(cV1,cV2)}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{V1:=vecteur(0,cV1);V2:=vecteur(0,cV2);V3:=vecteur(0,cV3)}
V\'erifions avec {\tt Xcas} :\\
\giacinput{cV1+cV2}
\subsection{Coordonn\'ees de $D$ extr\'emit\'e du vecteur 
d'origine $C$ \'equipollent au vecteur $AB$}
On a $D:=C+(B-A)$.\\
On tape :\\
\giacinput{Translation(cA,cB,cC):=cC+(cB-cA);}\\
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[2,3]}\\
\giacinput{cC:=[-1,1]}\\
\giacinput{cD:=Translation(cA,cB,cC)}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{A:=point(cA);B:=point(cB);C:=point(cC);D:=point(cD);polygone(cA,cB,cD,cC)}
V\'erifions avec {\tt Xcas} :\\
\giacinput{coordonnees(translation(cB-cA,point(cC)))}

\subsection{Norme d'un vecteur}
Soit le vecteur {\tt V:=[xV,yV]}, on pose {\tt cV:=[xV,yV]} la liste des 
coordonn\'ees de V.\\
La norme de {\tt V} est \'egale \`a {\tt sqrt(xV\verb|^|2+yV\verb|^|2)}.\\
On tape :
\begin{giacprog}
fonction Norme(cV)
 local xV,yV;
 xV:=cV[0];
 yV:=cV[1];
 retourne sqrt(xV^2+yV^2);
ffonction:;
\end{giacprog}
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[2,3]}\\
\giacinput{Norme(cB-cA)}\\
V\'erifions avec {\tt Xcas} :\\
\giacinput{norm(vecteur(point(cA),point(cB)))}
\section{Changement de rep\`eres}
%%B A mon avis il vaudrait mieux utiliser de la trigo pour faire ca
%%B la c'est trop dur a relire
\subsection{Le probl\`eme}
Soient 2 rep\`eres orthonorm\'es $ O,Ox,Oy$ et $ I,IX,IY$. \\
{\bf Notations~:}
\begin{itemize}
\item Soit $ M$ un point ou un vecteur.\\
On note $ c_M$ les coordonn\'ees $ [x_M,y_M]$ de $ M$ dans le rep\`ere 
$ Oxy$.\\
On note $ C_M$ les coordonn\'ees $ [X_M,Y_M]$ de $ M$ dans le rep\`ere 
$ IXY$.
\item On note $ u$ (resp  $ v$) le vecteur unitaire port\'e par $ Ox$ 
(resp $ Oy$)
\item On note $ U$ (resp  $ V$) le vecteur unitaire port\'e par $ OX$ 
(resp $ OY$)
\end{itemize}
Avec ces notations, on a~:
\begin{itemize}
\item le  point $ I$ a pour coordonn\'ees $ c_I:=[x_I,y_I]$ dans le rep\`ere 
$ O,Ox,Oy$ donc $ OI=x_Iu+y_Iv$
\item le vecteur $ U$ a pour coordonn\'ees $ c_U:=[x_U,yU]$ dans le rep\`ere 
$ O,Ox,Oy$ ($ x_U^2+y_U^2=1$) donc $ U=x_Uu+y_Uv$ 
\item le vecteur $ V$ a pour coordonn\'ees $ c_V:=[x_V,y_V]$ dans le rep\`ere 
$ O,Ox,Oy$ ($ x_V^2+y_V^2=1$) donc  $ V=x_Vu+y_Vv$.
L'angle $ (U,V)=\pi/2$ donc $ x_V:=-y_U$ et $ y_V:=x_U$
\end{itemize} 

\subsection{Le programme {\tt Changexy2XY(cM,cI,cU)}}\label{sec:Changexy2XY}
On conna\^{\i}t les coordonn\'ees $ cM:=[x_M,y_M]$ d'un point $ M$  dans le 
rep\`ere $ (O,Ox,Oy)$ ainsi que les  coordonn\'ees $ c_I:=[x_I,y_I]$ et
$ c_U:=[x_U,y_U]$ de $ I$ et de $ U$  dans le rep\`ere $ (O,Ox,Oy)$.\\
On cherche les coordonn\'ees $ C_M:=[X_M,Y_M]$ de 
$ M$ dans le rep\`ere $ (I,IX,IY)$.\\
On a donc :
\begin{eqnarray*}
OM=x_Mu+y_Mv&=&OI+IM\\
 &=&(x_Iu+y_Iv)+(X_MU+Y_MV) \\
 &=&x_Iu+y_Iv+X_M(x_Uu+y_Uv)+Y_M(x_Vu+y_Vv)\\
 &=&(x_I+X_Mx_U+Y_Mx_V)u+(y_I+X_My_U+Y_My_V)v
\end{eqnarray*}
Donc :
$$ x_M=x_I+X_Mx_U+Y_Mx_V, \quad
 y_M=y_I+X_My_U+Y_My_V$$
on en d\'eduit $X_M, Y_M$
$$ X_M= \frac{(x_M-x_I)y_V-(y_M-y_I)x_V}{x_Uy_V-y_Ux_V},
\quad
Y_M= \frac{(x_M-x_I)y_U-(y_M-y_I)x_U}{x_Vy_U-y_Vx_U}
$$
Or $ x_V=-y_U$ et $ y_V=x_U$ donc
$$ x_Uy_V-y_Ux_V=x_U^2+y_U^2=1 $$
Finalement :
$$ X_M= (x_M-x_I)x_U+(y_M-y_I)y_U, \quad
 Y_M= (x_M-x_I)y_U-(y_M-y_I)x_U$$
On tape :
\begin{giacprog}
fonction Changexy2XY(cM,cI,cU)
local xM,xI,xU,xV,yM,yI,yU,yV,l;
xM:=cM[0];
yM:=cM[1];
xI:=cI[0];
yI:=cI[1];
xU:=cU[0];
yU:=cU[1];
l:=xU^2+yU^2;
si l!=1 alors l:=sqrt(l);xU:=xU/l;yU:=yU/l;fsi;
xV:=-yU;
yV:=xU;
retourne normal([((xM-xI)*xU+(yM-yI)*yU),(-(xM-xI)*yU+(yM-yI)*xU)]);
ffonction:;
\end{giacprog}
{\bf Remarque} \\
Dans le programme ci-dessus, on teste si le vecteur {\tt U} est unitaire, si ce 
n'est pas le cas, on le rend unitaire avec :\\
{\tt l:=xU\verb|^|2+yU\verb|^|2;si l!=1 alors l:=sqrt(l);xU:=xU/l;yU:=yU/l;fsi;}\\
On tape :\\
\giacinput{cM:=[5/2,9/2]}\\
\giacinput{cI:=[2,3]}\\
\giacinput{cU:=[sqrt(2)/2,sqrt(2)/2]}\\
\giacinput{cV:=[-sqrt(2)/2,sqrt(2)/2]}\\
\giacinput{Changexy2XY(cM,cI,cU)}\\
La figure avec {\tt Xcas} :\\
%\giacinputbig{O:=point(0);M:=point(cM);I:=point(cI);U:=point(cI+cU);V:=point(cI+cV);segment(I,U);segment(I,V);segment(I,M)}
\giacinputbig{O:=point(0);M:=point(cM);I:=point(cI);U:=point(cI+cU);V:=point(cI+cV);vecteur(I,U);vecteur(I,V);vecteur(I,M)}

\subsection{Le programme {\tt ChangeXY2xy(CM,cI,cU)}}\label{sec:ChangeXY2xy}
Il s'agit du programme inverse du pr\'ec\'edent~:
on conna\^{\i}t les coordonn\'ees $C_M:=[X_M,Y_M]$ d'un point $M$  dans le 
rep\`ere $(I,IX,IY)$ ainsi que les  coordonn\'ees $c_I:=[x_I,y_I]$ et
$c_U:=[x_U,y_U]$ de $I$ et de $U$  dans le rep\`ere $(O,Ox,Oy)$.
On cherche les coordonn\'ees $c_M:=[x_M,y_M]$ de 
$M$ dans le rep\`ere $(O,Ox,Oy)$.

On a vu pr\'ec\'edemment que~:
$$ x_M=x_I+X_Mx_U+Y_Mx_V, \quad
 y_M=y_I+X_My_U+Y_My_V$$
On tape :
\begin{giaconload}
fonction ChangeXY2xy(CM,cI,cU)
 local XM,xI,xU,xV,YM,yI,yU,yV,l;
 XM:=CM[0];
 YM:=CM[1];
 xI:=cI[0];
 yI:=cI[1];
 xU:=cU[0];
 yU:=cU[1];
 l:=xU^2+yU^2;
 si l!=1 alors l:=sqrt(l);xU:=xU/l;yU:=yU/l;fsi;
 xV:=-yU;
 yV:=xU;
 retourne normal([xI+XM*xU+YM*xV,yI+XM*yU+YM*yV]);
ffonction:;
\end{giaconload}
{\bf Remarque}\\
 Dans le programme ci-dessus, si le vecteur {\tt U} n'est pas 
unitaire, on le rend unitaire :\\
{\tt l:=xU\verb|^|2+yU\verb|^|2;si l!=1 alors l:=sqrt(l);xU:=xU/l;yU:=yU/l;fsi;}\\
On tape :\\
\giacinput{CM:=[sqrt(2),sqrt(2)/2]}\\
\giacinput{cI:=[2,3]}\\
\giacinput{cU:=[sqrt(2)/2,sqrt(2)/2]}\\
\giacinput{cV:=[-sqrt(2)/52,sqrt(2)/2]}\\
\giacinput{ChangeXY2xy(CM,cI,cU)}\\
La figure avec {\tt Xcas} :\\
%\giacinputbig{O:=point(0);M:=point(cI+CM[0]*cU+CM[1]*cV);I:=point(cI);U:=point(cI+cU);V:=point(cI+cV);segment(I,U);segment(I,V);segment(I,M)}
\giacinputbig{O:=point(0);M:=point(cI+CM[0]*cU+CM[1]*cV);I:=point(cI);U:=point(cI+cU);V:=point(cI+cV);vecteur(I,U);vecteur(I,V);vecteur(I,M)}
\subsection{Exercices}
En se servant des programmes pr\'ec\'edents, faire les programmes :
\begin{enumerate}
\item calculant les coordonn\'ees $c_C$ du sommet $C$ d'un triangle 
\'equilat\'eral direct $ABC$ connaissant les coordonn\'ees $c_A$ de $A$ 
et $c_B$  de $B$, 
\item calculant les coordonn\'ees $c_C$ et $c_D$ 
des sommets $C$ et $D$ d'un 
carr\'e  direct $ABCD$ connaissant les coordonn\'ees 
$c_A$ de $A$ et $c_B$ de $B$.
\end{enumerate}
{\bf Solution}\\
1/
Soit un triangle \'equilat\'eral direct $ABC$. Dans le rep\`ere 
orthonorm\'e $Oxy$, $A$ a pour coordonn\'ees $ c_A:=[x_A,y_A]$ et $B$  a pour
coordonn\'ees $ c_B:=[x_B,y_B]$.\\
Cherchons les coordonn\'ees $ C_C=[X_C,Y_C]$ du point $C$ dans le
rep\`ere d'origine $A$ et d'axe des $X$ dirig\'e selon le vecteur $AB$.
On pose~:
$$ l:=\sqrt{(x_B-x_A)^2+(y_B-y_A)^2} $$
On a :
$$ c_U:=[\frac{x_B-x_A}{l},\frac{y_B-y_A}{l}], \quad
 C_C:=[\frac{l}{2},\frac{l\sqrt{3}}{2}] $$
Et les coordonn\'ees de $C$ dans le rep\`ere orthonorm\'e $Oxy$ sont :\\
{\tt ChangeXY2xy(CC,cA,cU)} (fonction \'ecrite pr\'ec\'edemment cf
 \ref{sec:ChangeXY2xy}).\\
On tape :
\begin{giacprog}
fonction Coordequi(cA,cB)
 local xA,yA,xB,yB,cU,l,CC;
 xA:=cA[0];
 yA:=cA[1];
 xB:=cB[0];
 yB:=cB[1];
 l:=sqrt((xB-xA)^2+(yB-yA)^2);
 cU:=[(xB-xA)/l,(yB-yA)/l];
 CC:=[l/2,l*sqrt(3)/2];
 retourne ChangeXY2xy(CC,cA,cU);
ffonction:;
\end{giacprog}
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[-1,-3]}\\
\giacinput{cC:=Coordequi(cA,cB)}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{A:=point(cA);B:=point(cB);T:=triangle_equilateral(A,B);}
V\'erifions avec {\tt Xcas} :\\
\giacinput{normal(coordonnees(sommets(T)[2]))}\\
2/ 
Soit un carr\'e direct $ABCD$, avec $A$ de coordonn\'ees
$c_A:=[x_A,y_A]$ et  $B$ de coordonn\'ees $c_B:=[x_B,y_B]$
 dans le rep\`ere 
orthonorm\'e $Oxy$.\\
Cherchons les coordonn\'ees $C_C:=[X_C,Y_C]$ 
du point $C$ et $C_D:=[X_D,Y_D]$
des points $C$ et $D$ dans le rep\`ere d'origine $A$ et d'axe des $X$ dirig\'e 
selon le vecteur $AB$. On pose~:
$$ l:=\sqrt{(x_B-x_A)^2+(y_B-y_A)^2} $$
On a :
$$ c_U:=[\frac{x_B-x_A}{l},\frac{y_B-y_A}{l}], \quad
c_C=[l,l], \quad c_D=[0,l] $$
Donc les coordonn\'ees de $C$ dans le rep\`ere orthonorm\'e $Oxy$ sont :\\
{\tt ChangeXY2xy(CC,cA,cU)}\\
les coordonn\'ees de $D$ dans le rep\`ere orthonorm\'e $Oxy$ sont :\\
{\tt ChangeXY2xy(CD,cA,cU)} (fonction \'ecrite pr\'ec\'edemment cf 
\ref{sec:ChangeXY2xy}).
\begin{giacprog}
fonction Coordcarre(cA,cB)
 local xA,yA,xB,yB,CC,CD,cU,l;
 xA:=cA[0];
 yA:=cA[1];
 xB:=cB[0];
 yB:=cB[1];
 l:=sqrt((xB-xA)^2+(yB-yA)^2);
 cU:=[(xB-xA)/l,(yB-yA)/l];
 CC:=[l,l];
 CD:=[0,l];
 retourne ChangeXY2xy(CC,cA,cU),ChangeXY2xy(CD,cA,cU);
ffonction:;
\end{giacprog}
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[-1,-3]}\\
\giacinput{cC:=Coordcarre(cA,cB)[0]}\\
\giacinput{cD:=Coordcarre(cA,cB)[1]}\\
On fait la figure avec {\tt Xcas} :\\
\giacinput{A:=point(cA);B:=point(cB);K:=carre(A,B)}
On v\'erifie avec {\tt Xcas} :\\
\giacinput{normal(coordonnees(sommets(K)[2],sommets(K)[3]))}

\section{Cercles, Tangentes \`a un cercle}
\subsection{\'Equation d'un cercle d\'efini par son centre et son rayon}
Le cercle $C$ d\'efini par son centre $A$ de coordonn\'ees 
$[x_A,y_A]$ et de rayon $r$ a pour \'equation :
$$(x-x_A)^2+(y-y_A)^2=r^2$$ 
ou encore
$$x^2+y^2-2x_Ax-2y_Ay+x_A^2+y_A^2-r^2=0$$
On va \'ecrire une proc\'edure Cercle qui renvoie une liste constitu\'ee des
coordonn\'ees de son centre, de son rayon et de son \'equation.\\
On tape :
\begin{giacprog}
fonction Cercle1(cA,r)
 //cercle defini par son centre et son rayon
 local xA,yA;
 xA:=cA[0];
 yA:=cA[1];
 retourne [cA,r,x^2+y^2-2*xA*x-2*yA*y+xA^2+yA^2-r^2=0];
ffonction:;
\end{giacprog}
\subsection{\'Equation d'un cercle d\'efini par son diam\`etre}
Si les points $A$ et $B$ ont pour coordonn\'ees $[x_A,y_A]$ et 
$[xB,yB]$, le cercle $C$ de diam\`etre $AB$ a pour \'equation :\\
si {\tt M:= Milieu(A,B)}, si {\tt xM:=M[0]}, si {\tt yM:=M[1]} et si 
{\tt r:=Longueur(A,B)/2} :\\
{\tt (x-xM)\verb|^|2+(y-yM)\verb|^|2=r\verb|^|2} ou encore\\
{\tt x\verb|^|2+y\verb|^|2-2*xM*x-2*yM*y+xM\verb|^|2+yM\verb|^|2-r\verb|^|2=0}\\
On va \'ecrire une proc\'edure Cercle qui renvoie une liste constitu\'ee des
coordonn\'ees de son centre, de son rayon et de son \'equation.\\
On tape :
\begin{giacprog}
fonction Cercle2(cA,cB)
 //cercle d\'efini par son diam\`etre
 local xA,xB,xM,yA,yB,yM,M,r;
 xA:=cA[0];
 yA:=cA[1];
 xB:=cB[0];
 yB:=cB[1];
 cM:=Milieu(cA,cB):
 xM:=cM[0];
 yM:=cM[1];
 r:=Longueur(cA,cB):
 retourne [cM,r,x^2+y^2-2*xM*x-2*yM*y+xM^2+yM^2-r^2=0];
ffonction:;
\end{giacprog}
\subsection{\'Equation d'un cercle d\'efini par son centre et son rayon ou par son diam\`etre}\label{sec:Cercle}
On peut reunir les 2 programmes en un seul en testant la dimension du 
deuxi\`eme param\`etre de {\tt Cercle} qui est soit 
une liste de dimension 2 (cercle d\'efini par son diam\`etre),
soit un r\'eel (cercle d\'efini par centre et rayon).\\
On tape :
\begin{giaconload}
fonction Cercle(cA,L)
 local cB,xA,xB,xM,yA,yB,yM,cM,r;
 xA:=cA[0];
 yA:=cA[1];
 si type(L)==vecteur alors 
   xB:=L[0];
   yB:=L[1];
   cB:=[xB,yB]
   cM:=Milieu(cA,cB);
   xM:=cM[0];
   yM:=cM[1];
   r:=Longueur(cA,cB)/2;
   retourne  [cM,r,x^2+y^2-2*xM*x-2*yM*y+xM^2+yM^2-r^2=0];
 sinon
   r:=L;
   retourne [cA,r,x^2+y^2-2*xA*x-2*yA*y+xA^2+yA^2-r^2=0];
 fsi;
ffonction:;
\end{giaconload}
\giacinput{cA:=[1,2]}\\
\giacinput{cB:=[-1,-3]}\\
\giacinput{r:=2}\\
\giacinput{Cercle(cA,cB)}\\
\giacinput{Cercle(cA,r)}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{A:=point(cA);B:=point(cB);C1:=cercle(A,B);C2:=cercle(A,r)}
On v\'erifie avec {\tt Xcas} :\\
\giacinput{normal(equation(C1));normal(equation(C2))}
\subsection{Centre et rayon d'un cercle donn\'e par son \'equation}
On utilise ici les commandes {\tt Xcas}
{\tt gauche, droit ,coeff, subst}\\
On tape :
\begin{giacprog}
fonction Centrerayon(Eq)
 local k,a,b,c;
 Eq:=gauche(Eq)-droit(Eq);
 k:=coeff(Eq,x,2);
 si k!=coeff(Eq,y,2) alors retourne "ce n'est pas un cercle";fsi;
 Eq:=Eq/k;
 a:=-coeff(Eq,x,1)/2;
 b:=-coeff(Eq,y,1)/2;
 c:=subst(Eq,[x,y],[0,0]);
 retourne [a,b], normal(sqrt(a^2+b^2-c));
ffonction:;
\end{giacprog}
\giacinput{Centrerayon(2x^2+2y^2-4x+2y=0)}\\
On v\'erifie avec {\tt Xcas} :\\
\giacinputbig{coordonnees(centre(2x^2+2y^2-4x+2y=0)),rayon(2x^2+2y^2-4x+2y=0)}

\subsection{Construire la tangente \`a un cercle en l'un de ses points}
Soit $ C$ un cercle de centre $ I$ de coordonn\'ees 
$ c_I=[x_I,y_I]$ et de rayon $ r$.\\
Soit $ A$ un point de $ C$ de coordonn\'ees $c_A=[x_A,y_A]$.
la tangente au cercle $ C$ en $ A$ est perpendiculaire \`a $ IA$, donc
a pour pente $ m=-(x_A-x_I)/(y_A-y_I)$\\
L'\'equation de cette tangente est donc : {\tt Droite(cA,m)} (fonction 
{\tt Droite} a \'et\'e \'ecrite pr\'ec\'edemment cf \ref{sec:Droite}).\\
On utilise aussi, ici, les fonctions {\tt Longueur} (cf \ref{sec:Longueur}) et 
{\tt Cercle} (cf \ref{sec:Cercle}).\\
On tape :
\begin{giacprog}
fonction Tangent1(C,cA)
 local I,r,m,xI,yI,xA,yA,cI;
 cI:=C[0];
 r:=C[1];
 si Longueur(cA,cI)!=r alors retourne "A n'est pas sur C"; fsi;
 xI:=cI[0];
 yI:=cI[1];
 xA:=cA[0];
 yA:=cA[1];
 si yA!=yI alors 
   m:=-(xA-xI)/(yA-yI);
   retourne Droite(cA,m);
 fsi
 retourne x=xA; 
ffonction:;
\end{giacprog}
\giacinput{cI:=[0,1]}\\
\giacinput{cA:=[1,0]}\\
\giacinput{r:=sqrt(2)}\\
\giacinput{C:=Cercle(cI,r)} \\
\giacinput{T1:=Tangent1(C,cA);}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{I:=point(cI);c:=cercle(I,r);A:=point(cA);droite(T1);}
On v\'erifie avec {\tt Xcas} :\\
\giacinput{t:=tangent(c,A):;equation(t)}

\subsection{Construire les tangentes \`a un cercle passant par un point}
Soit $ C$ un cercle de centre $ I$ de coordonn\'ees 
$ c_I:=[x_I,y_I]$ et de rayon $ r$.\\
Soit $ A$ un point du plan de coordonn\'ees $ c_A:=[x_A,y_A]$.\\
Si $ A$ est \`a l'int\'erieur de $ C$ il n'y a pas de tangente \`a $ C$
passant par $ A$.

\subsubsection{Le cas simple}
On suppose qu'on a choisi comme rep\`ere, le rep\`ere $IXY$
d'origine le centre $ I$ du cercle $C$  et
tel que $A$ est sur l'axe des $X$ (i.e. de coordonn\'ees $[X_A,0]$) et 
\`a l'ext\'erieur de $C$.\\
On peut mener par $A$, 2 tangentes $ T_1$ et $ T_2$ \`a $ C$.\\
Soient $ M_1$ et $ M_2$ les 2 points de tangeance de $ T_1$ et $ T_2$.\\
Les triangles $ IAM_1$ (resp $ IAM_2$) sont rectangles en $ M_1$ 
(resp $ M_2$) et $ M_1M_2$ est perpendiculaire \`a $ AI$.\\
Soit $ H$ l'intersection de $ M_1M_2$ avec $ AI$.\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{I:=point(0);C:=cercle(I,1);A:=point(2,0);T:=tangent(C,A);M1:=inter_unique(C,T[0]);M2:=inter_unique(C,T[1]);droite(M1,M2);M12:=droite(M1,M2):;H:=inter_unique(M12,droite(A,I))}
On a :
$$ r^2=IM_1^2=IM_2^2=IA \times IH$$
Donc dans le rep\`ere $IXY$, 
$A$ a pour abscisse $X_A=\mbox{Longueur(cI,cA)}$ et pour ordonn\'ee 0.\\
$H$ a pour abscisse $\frac{r^2}{X_A}$ et pour ordonn\'ee 0.\\
$ M_1$ et $ M_2$ ont la m\^eme  abscisse :
$$ X_{M_1}=X_{M_2}=\frac{r^2}{X_A}$$
$ M_1$ et $ M_2$ ont des ordonn\'ees oppos\'ees :\\
$$Y_{M_1}>0,\quad Y_{M_1}^2=r^2-\frac{r^4}{X_A^2}=r^2(1-\frac{r^2}{X_A^2}), \quad Y_{M_2}=-Y_{M_1}$$
$$ Y_{M_1}=r\frac{\sqrt{X_A^2-r^2}}{X_A}, \quad Y_{M_2}=-Y_{M_1} $$
Les tangentes sont donc :
\begin{center}
$ \mbox{Droite}([X_A,0], [X_{M_1},Y_{M_1}])$ et $ \mbox{Droite}([X_A,0], [X_{M_2},Y_{M_2}])$
\end{center}
Si $ A$ est sur $ C$ (i.e. $ X_A==r$) alors on peut mener par $ A $,
 une tangente $ T_1$ \`a $ C$ qui est $ \mbox{Droite}(x=X_A)$.

\subsubsection{Le cas g\'en\'eral}
On se ram\`ene au cas pr\'ec\'edent par changement de rep\`ere.\\
Soit $Oxy$ le rep\`ere.
Dans le rep\`ere $Oxy$, $I$ (resp $A$) a pour coordonn\'ees $c_I$ (resp $c_A$).\\
On fait un changement de rep\`ere en prenant le centre $I$ du cercle
 comme origine et $ IA$ comme axe des $ X$.\\
On note $ X_M$ et $ Y_M$ les coordonn\'ees d'un point $ M$ ou d'un 
vecteur $ M$ dans le nouveau rep\`ere $IXY$ et 
$ x_M$ et $ y_M$ les coordonn\'ees de $M$ dans le rep\`ere $Oxy$.\\
Dans le rep\`ere $IXY$, $A$ a pour abscisse $X_A=\mbox{Longueur}(c_A,c_I)$  et 
pour ordonn\'ee 0.\\
$H$ a pour abscisse $\frac{r^2}{X_A}$ et pour ordonn\'ee 0.\\
Si $ U$ est le vecteur unitaire de $ IX$ on a :\\
$ x_U:=(x_A-x_I)/X_A$ et $ y_U:=(y_A-y_I)/X_A$ avec $ X_A:=\mbox{Longueur}(c_A,c_I)$.\\
On a vu que (cf \ref{sec:Changexy2XY}) :
$$ x_M=x_I+X_Mx_U+Y_Mx_V, \quad  y_M=y_I+X_My_U+Y_My_V $$
$$ x_V:=-y_U, \quad y_V:= x_U$$
Donc :\\
$$ x_M=x_I+X_Mx_U-Y_My_U, \quad y_M=y_I+X_My_U+Y_Mx_U$$
En rempla\c{c}ant $ x_U$ et $ y_U$ par leur valeur, on a :\\
$$ x_M=x_I+\frac{X_M(x_A-x_I)-Y_M(y_A-y_I)}{\mbox{Longueur}(c_A,c_I)}
\quad
y_M=y_I+\frac{X_M(y_A-y_I)+Y_M(x_A-x_I)}{\mbox{Longueur}(c_A,c_I)}$$
Dans le rep\`ere $IXY$ les coordonn\'ees de $ M_1$ et $ M_2$ sont :\\
$$ X_{M_1}=X_{M_2}=r^2/x_A$$
$$ Y_{M_1}=r\frac{\sqrt{X_A^2-r^2}}{X_A}, \quad Y_{M_2}=-Y_{M_1} $$
%$$Y_{M_1}>0,\quad , Y_{M_1}^2=r^2(1-\frac{r^2}{x_A}), \quad Y_{M_2}=-Y_{M_1}$$
%$$y_{M_1}=r\sqrt{1-\frac{r^2}{x_A}}, \quad y_{M_2}=-r\sqrt{1-\frac{r^2}{x_A}}$$
Donc :
\begin{eqnarray*}
 x_{M_1}&=&x_I+\frac{r^2/x_A(x_A-x_I)-r\sqrt{1-r^2/x_A}(y_A-y_I)}{\mbox{Longueur}(c_A,c_I)} \\
y_{M_1}&=&y_I+\frac{r^2/x_A(y_A-y_I)+r\sqrt{1-r^2/x_A}(x_A-x_I)}{\mbox{Longueur}(c_A,c_I)}, \\
x_{M_2}&=&x_I+\frac{r^2/x_A(x_A-x_I)+r\sqrt{1-r^2/x_A}(y_A-y_I)}{\mbox{Longueur}(c_A,c_I)},\\
y_{M_2}&=&y_I+\frac{r^2/x_A(y_A-y_I)-r\sqrt{1-r^2/x_A}(x_A-x_I)}{\mbox{Longueur}(c_A,c_I)}
\end{eqnarray*}
On \'ecrit la fonction {\tt Tangent(C,cA)} qui renvoie une liste 
(\'eventuellement vide) contenant la ou les \'equations des tangentes au cercle 
{\tt C} passant par le point $A$ de coordonn\'ees {\tt cA}, en utilisant 
{\tt Milieu} (cf \ref{sec:Milieu}), {\tt Longueur} (cf \ref{sec:Longueur}), 
{\tt Droite}(cf \ref{sec:Droite}) et {\tt Cercle} (cf \ref{sec:Cercle}).\\
On tape  :
\begin{giacprog}
fonction Tangent(C,cA)
 local cI,r,xI,yI,xA,yA,XM1,YM1,xM1,yM1,XM2,YM2,xM2,yM2,l;
 cI:=C[0];
 xI:=cI[0];
 yI:=cI[1];
 r:=C[1];
 l:=Longueur(cA,cI);
 xA:=cA[0];
 yA:=cA[1];
 si l < r alors 
   print("A n'est pas a l'exterieur de C");
   retourne [];
 fsi;
 si l==r et yA==yI alors 
   retourne [x-xA=0]; 
 fsi;
 si l==r et (yA-yI)!=0 alors 
   retourne [normal(Droite([xA,yA],-(xA-xI)/(yA-yI)))];
 fsi;
 XM1:=r^2/l;
 YM1:=r*sqrt(1-r^2/l^2);
 xM1:=normal(xI+(XM1*(xA-xI)-YM1*(yA-yI))/l);
 yM1:=normal(yI+(XM1*(yA-yI)+YM1*(xA-xI))/l);
 XM2:=r^2/l;
 YM2:=-r*sqrt(1-r^2/l^2);
 xM2:=normal(xI+(XM2*(xA-xI)-YM2*(yA-yI))/l);
 yM2:=normal(yI+(XM2*(yA-yI)+YM2*(xA-xI))/l);
 retourne [Droite([xM1,yM1],[xA,yA]),Droite([xM2,yM2],[xA,yA])];
ffonction:;
\end{giacprog}
\giacinput{cI:=[0,1]}\\
\giacinput{cA:=[2,1]}\\
\giacinput{r:=sqrt(2);}\\
\giacinput{C1:=Cercle(cI,r)} \\
\giacinput{T1:=Tangent(C1,cA)}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{I:=point(cI);A:=point(cA);c1:=cercle(I,r);droite(T1[0]);droite(T1[1])}
\giacinputbig{C2:=Cercle([1,2],2);T2:=Tangent(C2,[1+sqrt(2),2+sqrt(2)])}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{J:=point(1,2);B:=point(1+sqrt(2),2+sqrt(2));c2:=cercle(J,2);droite(T2[0]);}
On v\'erifie avec  {\tt Xcas} :\\
%equation(T2)
\giacinput{equation(tangent(c1,A))}\\
\giacinput{equation(tangent(c2,B))}\\

On peut  utiliser non seulement {\tt Milieu} (cf \ref{sec:Milieu}), 
{\tt Longueur} (cf \ref{sec:Longueur}), {\tt Droite}(cf \ref{sec:Droite}) et 
{\tt Cercle} (cf \ref{sec:Cercle}), mais aussi le programme de changement de 
rep\`ere \'ecrit pr\'ecedemment {\tt ChangeXY2xy} (cf \ref{sec:ChangeXY2xy} :
\begin{giacprog}
fonction Tangentes(C,cA)
 local cI,r,xI,yI,xA,yA,XA,CM1,CM2,cM1,cM2,cU;
 cI,r:=C; 
 xI,yI:=cI;
 xA,yA:=cA;
 XA:=Longueur(cA,cI);
 cU:=[xA-xI,yA-yI]/XA;
 si XA >r alors
   CM1:=[r^2/XA,r*sqrt(1-r^2/XA^2)];
   CM2:=[r^2/XA,-r*sqrt(1-r^2/XA^2)];
   cM1:=ChangeXY2xy(CM1,cI,cU);
   cM2:=ChangeXY2xy(CM2,cI,cU);
   retourne [Droite(cM1,[xA,yA]),Droite(cM2,[xA,yA])];
 fsi;
 si XA==r alors 
   CM1:=[r,1];
   cM1:=ChangeXY2xy(CM1,cI,cU);
   retourne [Droite(cM1,[xA,yA])];
 fsi
 retourne [];
ffonction:;
\end{giacprog}
\giacinput{cI:=[0,1]}\\
\giacinput{cA:=[2,1]}\\
\giacinput{r:=sqrt(2);}\\
\giacinput{C:=Cercle(cI,r)} \\
\giacinput{Tangentes(C,cA)}\\
\giacinput{Tangentes(Cercle([1,2],1),[1,3])}\\
On v\'erfie avec {\tt Xcas} :\\
\giacinputbig{equation(tangent(cercle(point(cI),r),point(cA)))}\\
\giacinputbig{equation(tangent(cercle(point([1,2]),1),point([1,3])))}
\subsection{Solution analytique des tangentes \`a un cercle}
On peut aussi faire une r\'esolution analytique pour construire la (ou les) 
tangente(s) \`a un cercle  $C$ passant par un point $A$.\\
On pourra se servir des programmes \'ecrits pr\'ec\'edement : {\tt Longueur} 
(cf \ref{sec:Longueur}), {\tt Droite}(cf \ref{sec:Droite}), {\tt Cercle} 
(cf \ref{sec:Cercle}) et {\tt Solution12} (cf \ref{sec:Solution12}).

On consid\`ere un rep\`ere orthonorm\'e dans lequel le centre $I$ du cercle 
$C$ de rayon $r$ a pour  coordonn\'ees $[x_I,y_I]$.\\
$ C$ a pour \'equation $(x-x_I)^2+(y-y_I)^2=r^2$ soit
$$x^2+y^2-2x_Ix-2y_Iy+x_I^2+y_I^2-r^2=0$$
Soit $ A$ un point de coordonn\'ees $ [x_A,y_A]$.\\
Si $ A$ se trouve \`a l'ext\'erieur du cercle $ C$, on peut mener par 
$ A$, deux tangentes. Les points de contact $ M_1$ et $ M_2$ de ces 
tangentes  avec $ C$ sont aussi les points d'intersection de $ C$ et du 
cercle de diam\`etre $ IA$.\\ 
Le cercle de diam\`etre $ IA$ a pour centre $ K$ et rayon $R$
o\`u $K$ est le milieu de $ IA$
de coordonn\'ees $ [x_K,y_K]=c_K$=Milieu$(cI,cA)$ et
$ R=$Longueur$(cI,cA)/2$.
Ce cercle a donc comme \'equation $(x-x_K)^+(y-y_K)^2=R^2$ i.e.\\
$$x^2+y^2-2x_Kx-2y_Ky+x_K^2+y_K^2-R^2=0$$
Il faut donc r\'esoudre le syst\`eme d'inconnues $x,y$
\begin{eqnarray*}
x^2+y^2-2xIx-2yIy+xI^2+yI^2-r^2&=&0\\
x^2+y^2-2x_Kx-2y_Ky+x_K^2+y_K^2-R^2&=&0
\end{eqnarray*}
qui est \'equivalent \`a :
\begin{eqnarray*}
x^2+y^2-2xIx-2yIy+xI^2+yI^2-r^2&=&0 \\
2(xI-x_K)x+2(yI-y_K)y+x_K^2+y_K^2+r^2-xI^2-yI^2-R^2&=&0
\end{eqnarray*}
On a $2(xI-x_K)=(xI-x_A)$ et $2(yI-y_K)=(yI-y_A)$\\
Or $ A\neq I$ donc $x_A\neq x_I \neq x_K$ ou $y_A \neq y_I \neq y_K$.
Si $(yI-y_K) \neq 0$ (resp $(xI-x_A) \neq $) alors on conna\^{\i}t $y$ 
(resp $x$) en fonction 
de $x$ (resp $y$) et il faut r\'esoudre une \'equation 
de degr\'e 2 en $x$ (res $y$).\\
Si $ A$ est sur le cercle $ C$, on peut mener par 
$ A$, une tangente 
(c'est une droite passant par $ A$ et qui est perpendiculaire \`a $ IA$. \\
Si $ A$ est \`a l'int\'erieur du cercle $ C$, il n'y a  pas de 
tangente passant par $ A$.\\
On  utilise encore {\tt Longueur} (cf \ref{sec:Longueur}), {\tt Droite}
(cf \ref{sec:Droite}) et {\tt Cercle} (cf \ref{sec:Cercle}), mais aussi le 
programme  {\tt Solution12} \'ecrit pr\'ecedemment  (cf \ref{sec:Solution12} :
On tape :
\begin{giacprog}
fonction Tangenteq(C,cA)
 local cI,r,l,xI,yI,xA,yA,xK,yK,Eq,xM,yM,xM1,yM1,xM2,yM2,R,m;
 cI:=C[0];
 xI:=cI[0];
 yI:=cI[1];
 r:=C[1];
 l:=Longueur(cA,cI);
 xA:=cA[0];
 yA:=cA[1];
 R:=l/2;
 si l >r alors
  xK:=(xI+xA)/2;
  yK:=(yI+yA)/2;
  si (yI-yA)!=0 alors 
    yM:=(xK^2+yK^2+r^2-xI^2-yI^2-R^2+2*(xI-xK)*x)/(yA-yI);
    Eq:=x^2+yM^2-2xI*x-2yI*yM+xI^2+yI^2-r^2=0;
    [xM1,xM2]:=Solution12(Eq,x);
    yM1:=subst(yM,x=xM1);
    yM2:=subst(yM,x=xM2);
  sinon
    xM:=(xK^2+yK^2+r^2-xI^2-yI^2-R^2+2*(yI-yK)*y)/(xA-xI);
    Eq:=xM^2+y^2-2xI*xM-2yI*y+xI^2+yI^2-r^2=0;
    [yM1,yM2]:=Solution12(Eq,y)
    xM1:=subst(xM,y=yM1);
    xM2:=subst(xM,y=yM2);
  fsi;
 retourne [Droite(cA,[xM1,yM1]),Droite(cA,[xM2,yM2])];
 fsi;
 si l==r alors
   si (yI-yA)!=0 alors
     m:=normal(-(xA-xI)/(yA-yI));
     retourne [Droite([xA,yA],m)];
   sinon
     retourne [Droite([xA,yA],[xA,yA+1])];
   fsi;
 fsi;
 retourne [];
ffonction:;
\end{giacprog}
\giacinput{cI:=[0,1]}\\
\giacinput{cA:=[2,1]}\\
\giacinput{r:=sqrt(2);}\\
\giacinput{C:=Cercle(cI,r)} \\
\giacinput{Tangenteq(C,cA)}\\
\giacinput{Tangenteq(Cercle([1,2],1),[1,3])}\\
On v\'erifie avec {\tt Xcas} :\\
\giacinputbig{equation(tangent(cercle(point([0,1]),r),point(cA)))}\\
\giacinputbig{equation(tangent(cercle(point([1,2]),1),point([1,3])))}
\chapter{Quelques tests g\'eom\'etriques}
\section{Test d'alignement de 3 points}
\'Etablir que trois points sont align\'es ou non align\'es.\\
Si les 3 points sont confondus {\tt Estaligne(A,B,C)} renvoie 2 \\
Si les 3 points sont align\'es {\tt Estaligne(A,B,C)} renvoie 1\\
Si les 3 points ne sont pas align\'es {\tt Estaligne(A,B,C)} renvoie 0\\
On tape :
\begin{giacprog}
fonction Estaligne(cA,cB,cC)
 local xA,yA,xB,yB,xC,yC;
 si cA==cB et cA==cC alors retourne 2; fsi;
 si cA==cB ou cA==cC alors retourne 1; fsi;
 xA:=cA[0];
 yA:=cA[1];
 xB:=cB[0];
 yB:=cB[1];
 xC:=cC[0];
 yC:=cC[1];
 si normal((xB-xA)*(yC-yA)-(xC-xA)*(yB-yA))==0 alors 
   retourne 1;
 fsi; 
 retourne 0;

ffonction:;
\end{giacprog}
\giacinput{Estaligne([1,2],[1,2],[1,2])}\\
\giacinput{Estaligne([1,2],[3,6],[1,2])}\\
\giacinput{Estaligne([1,2],[3,6],[-1,-2])}\\
\giacinput{Estaligne([1,2],[1,6],[-1,-2])}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{A:=point(1,2);B:=point(3,1);C:=point(3,6);D:=point(-1,-2);}
On v\'erifie avec {\tt Xcas} :\\
\giacinput{est_aligne([1,2],[3,6],[-1,-2])}\\
\giacinput{est_aligne([1,2],[3,1],[-1,-2])}
\section{Test de parall\'elisme de 2 droites}
Soient deux droites $D_1$ et $D_2$ d'\'equation :\\
$a_1x+b_1y+c_1=0$ et $a_2x+b_2y+c_2=0$\\
Ces 2 droites sont parall\`eles si $a_1b_2=a_2b_1$.\\
On utilise la fonction {\tt Coeffsdroite} (cf \ref{sec:Coeffsdroite} qui calcule
les coefficients {\tt a}, {\tt b} et {\tt c} de l'\'equation d'une droite 
{\tt ax+by+c=0}~:
On tape :
\begin{giacprog}
fonction Estparallele(d1,d2)
 local a1,a2,b1,b2,d,c1,c2;
 a1,b1,c1:=Coeffsdroite(d1);
 a2,b2,c2:=Coeffsdroite(d2);
 d:=normal(a2*b1-b2*a1);
 si d==0 alors retourne 1; fsi;
 retourne 0;
ffonction:;
\end{giacprog}
\giacinput{D1:=Droite(2*x-3*y=1)}\\
\giacinput{D2:=Droite(-4*x+6*y=23)}\\
\giacinput{Estparallele(D1,D2)}\\
\giacinput{D3:=Droite(-5*x+15*y=16)}\\
\giacinput{Estparallele(D1,D3)}\\
On fait la figure avec {\tt Xcas} :\\
\giacinputbig{d1:=droite(2*x-3*y=1);d2:=droite(-4*x+6*y=23);d3:=droite(-5*x+15*y=16)}
On v\'erifie avec {\tt Xcas} :\\
\giacinput{est_parallele(d1,d2)}\\
\giacinput{est_parallele(d1,d3)}

\section{Caract\'eriser alignement et parall\'elisme par la colin\'earit\'e} 
Trois points $A$, $ B$ et $ C$ sont align\'es si les vecteurs 
$ AB$ et $ AC$ sont colin\'eaires.\\
Deux droites $ AB$ et $ CD$ sont parall\`eles si les vecteurs $ AB$ et 
$ CD$ sont colin\'eaires.

\chapter{Statistiques} \label{chap:stats}
\section{Calcul de moyenne et \'ecart-type}
{\bf Exercice~:} \'Ecrire une fonction prenant en argument la liste des 
donn\'ees et renvoyant sa moyenne et son \'ecart-type, au
moyen d'une boucle \verb|pour| (sans utiliser \verb|mean| ou \verb|stddev| qui 
sont les commandes {\tt Xcas} pour moyenne et \'ecart-type).
\begin{giacprog}
fonction Stats(L)
  local j,Lj,n,s,s2;
  n:=dim(L);
  s:=0; s2:=0;
  pour j de 0 jusque n-1 faire
    Lj := L[j];
    s := s+Lj 
    s2 := s2+Lj^2;
  fpour
  retourne s/n,sqrt(s2/n-(s/n)^2);
ffonction:;
\end{giacprog}
\giacinput{L:=[7,9,11,10,7,14,11];}\\
\giacinput{Stats(L);}\\
On v\'erifie avec {\tt Xcas} :\\
\giacinput{ mean(L); stddev(L);}\\
{\bf Exercice~:} \'Ecrire une fonction prenant en argument la liste des 
donn\'ees et renvoyant sa m\'ediane.\\
{\bf Indication :} Pour d\'eterminer une m\'ediane, il faut au pr\'ealable 
trier les donn\'ees, ce qui est la partie difficile de l'algorithme, le reste
de l'algorithme est simple. Au niveau du lyc\'ee on peut
utiliser la commande {\tt Xcas} \verb|sort|  qui trie une liste par ordre 
croissant, puis on renvoie l'\'el\'ement d'indice la taille de la liste/2.
\begin{giacprog}
fonction Median(L)
  local n;
  n:=dim(L);
  L:=sort(L);
  si irem(n,2)==1 alors 
    retourne L[(n-1)/2];
  sinon
    retourne (L[n/2-1]+ L[n/2])/2.;
  fsi;
ffonction:;
\end{giacprog}
\giacinput{L1:=[148,143,142,146,144,146,142,147,140];}\\
\giacinput{Median(L1)}\\
\giacinput{L2:=[143,142,146,144,146,142,147,140];}\\
\giacinput{Median(L2)}\\
On v\'erifie avec {\tt Xcas} :\\
\giacinput{median(L1)}\\
{\bf Exercice~:} \'Ecrire une fonction qui calcule la moyenne et l'\'ecart-type 
et qui a comme argument soit la liste alternant valeur et effectif soit 
2 listes.
\begin{giacprog}
fonction Statexo1(L)
  local j,lj,n,n1,s,s2,vj,ej;
  n:=dim(L);
  si type(n)!=vecteur alors retourne "erreur"; fsi;
  s:=0; 
  s2:=0;
  n1:=n[0];
  n:=sum(col(L,1));
  pour j de 0 jusque n1-1 faire
    lj := L[j];
    vj := lj[0];
    ej := lj[1];
    s := s+vj*ej 
    s2 := s2+vj^2*ej;
  fpour;
  retourne s/n,sqrt(s2/n-(s/n)^2);
ffonction:;
fonction Statexo2(L1,L2)
  local j,vj,ej,n,n1,n2,s,s2;
  n1:=dim(L1);
  n2:=dim(L2);
  si n1!=n2 alors retourne "erreur"; fsi;
  n:=sum(L2);
  s:=0; 
  s2:=0;
  pour j de 0 jusque n1-1 faire
    vj := L1[j];
    ej := L2[j];
    s := s+vj*ej 
    s2 := s2+vj^2*ej;
  fpour;
  retourne s/n,sqrt(s2/n-(s/n)^2);
ffonction:;
\end{giacprog}
On a mesur\'e la taille en cm (arrondie \`a l'entier le plus proche) de 200 
fossiles de la m\^eme esp\`ece. On a obtenu pour {\tt k=0..12} une taille 
{\tt L1[k]} d'effectif de {\tt L2[k]}.\\
Calculer la moyenne et l'\'ecart-type de cette distribution.\\
\giacinput{L1:=[0,1,2,3,4,5,6,7,8,9,10,11,12]}\\
\giacinput{L2:=[1,16,31,37,41,30,23,13,6,1,0,1,0]}\\
\giacinput{L12:=seq([L1[k],L2[k]],k,0,12)}\\
\giacinput{Statexo1(L12)}\\
On a mesur\'e la taille en cm (arrondie \`a l'entier le plus proche) d'une autre
esp\`ece de fossiles. On a obtenu pour {\tt k=0..12} une taille 
{\tt L1[k]} d'effectif de {\tt L3[k]}.\\
Calculer la moyenne et l'\'ecart-type de cette distribution.\\
\giacinput{L1:=[0,1,2,3,4,5,6,7,8,9,10,11,12]}\\
\giacinput{L3:=[2,11,21,52,64,77,62,46,41,11,8,5,0]}\\
\giacinput{Statexo2(L1,L3)}\\
On v\'erifie avec {\tt Xcas} :\\
\giacinput{mean(L1,L2),stddev(L1,L2)}\\
\giacinput{mean(L1,L3),stddev(L1,L3)}

\section{Simulation d'un \'echantillon}\label{sec:Simu}
{\bf Exercice~:} G\'en\'erer al\'eatoirement $n$ valeurs 0 ou 1,
la probabilit\'e d'avoir 1 \'etant fix\'ee \`a $p$
(pour faire cela, on comparera avec $p$ le r\'esultat de la commande {\tt Xcas}
\verb|alea(0,1)| qui renvoie un r\'eel entre 0 et 1). 
Calculer la fr\'equence de 1 observ\'ee.
\begin{giaconload}
fonction Simu(n,p)
  local j,a,n1;
  n1:=0;
  pour j de 1 jusque n faire
    a:=alea(0,1);
    si a<=p alors n1:=n1+1; fsi;
  fpour
  retourne n1/n;
ffonction:;
\end{giaconload}
\giacinput{L:=seq(Simu(20.,.4),k,1,10);}
On peut visualiser les fr\'equences obtenues avec la commande 
{\tt plotlist([y0,...,yn])} de {\tt Xcas} qui trace la ligne polygonale reliant 
les points d'abscisse {\tt k} et d'ordonn\'ee {\tt yk} pour {\tt k=0..n}.\\
\giacinput{plotlist(L);droite(y=0.4-1/sqrt(20)); droite(y=0.4+1/sqrt(20))}

Commandes {\tt Xcas} permettant de faire le calcul directement :\\
\giacinputbig{n:=20.; p:=.4; v:=randvector(n,binomial,1,p); sum(v)/n;}\\
La commande \verb|randvector| g\'en\`ere ici $n$ valeurs al\'eatoires
selon la loi binomiale de param\`etres 1 et $p$, on en fait ensuite
la moyenne. On peut bien sur utiliser d'autres lois que la loi binomiale,
par exemple la loi uniforme (\verb|uniform|), la loi normale
(\verb|normald|), la loi exponentielle (\verb|exponential|), ...

\section{Intervalle de fluctuation}
\'Ecrire un algorithme effectuant $N$ simulations d'\'echantillons,
en utilisant la fonction pr\'ec\'edente, renvoyer la liste
des fr\'equences ainsi que la proportion
de fr\'equences situ\'ees en-dehors de l'intervalle 
$[p-1/\sqrt{n},p+1/\sqrt{n}]$.

Rappelons qu'on s'int\'eresse \`a cet intervalle, 
parce qu'une simulation suit une loi binomiale de moyenne $np$ et 
d'\'ecart-type $\sigma=\sqrt{n p (1-p)}$ donc 
les fr\'equences suivent une loi binomiale de moyenne $p$ et 
d'\'ecart-type $\tilde{\sigma}=\sigma/n=\sqrt{p (1-p)/n}$. Or
$$4p(1-p)=1-(2*p-1)^2 \Rightarrow 4p(1-p)\leq 1$$ 
donc
$$2\tilde{\sigma}=2\frac{\sigma}{n}=
\sqrt{\frac{4p(1-p)}{n}} \leq \frac{1}{\sqrt{n}}$$
Pour $n$ grand, la loi binomiale s'approche d'une loi normale
ayant cet \'ecart type.

On utilise la fonction {\tt Simu} \'ecrite pr\'ec\'edemment 
(cf \ref{sec:Simu}).
\begin{giacprog}
fonction Fluctuat(N,n,p)
  local j,L,out;
  L:=[];
  out:=0;
  pour j de 0 jusque N-1 faire
    L[j]:=Simu(n,p);
    si abs(L[j]-p)>1/sqrt(n) alors out:=out+1; fsi;
  fpour;
  retourne out/N,L;
ffonction:;
\end{giacprog}
On lance 20 fois une pi\`ece de de monnaie mal \'equilibr\'ee, la 
probabilit\'e d'obtenir face \'etant \'egale \`a 0.4.\\
{\tt Simu(20,0.4)} renvoie donc la fr\'equence du nombre de faces observ\'ees.
On effectue plusieurs fois 100 simulations :
\giacinput{L:=Fluctuat(100.,20,.4);L1:=L[1]:;}\\
\giacinput{LL:=Fluctuat(100.,20,.4);LL1:=LL[1]:;}\\
\giacinput{LLL:=Fluctuat(100.,20,.4);LLL1:=LLL[1]:;}\\
On peut visualiser la r\'epartition de ces fr\'equences :\\
\giacinputbig{gl_y=0..1;purge(x,y);
plotlist(L1,affichage=vert);
plotlist(LL1,affichage=rouge);
plotlist(LLL1,affichage=bleu);
droite(y=0.4-1/sqrt(20)); 
droite(y=0.4+1/sqrt(20))}

{\bf Avec les commandes de  {\tt Xcas}}\\
On g\'en\`ere une s\'equence de $N$ moyennes de vecteurs de $n$
valeurs al\'eatoires selon la loi binomiale de param\`etres 1 et $p$~:\\
\giacinputbig{N:=100.; n:=20; p:=.4;l:=seq(sum(randvector(n,binomial,1,p))/n,j,1,N);}\\
On compte les moyennes dont l'\'ecart \`a $p$ est plus grand que $1/\sqrt{n}$ :\\
\giacinput{count(x->abs(x-p)>1/sqrt(n),l)/N;}\\
On peut acc\'el\'erer le calcul en utilisant le g\'en\'erateur
al\'eatoire selon la loi binomiale
de param\`etres $n$ et $p$
\giacinputbig{N:=100.; n:=20; p:=.4;l:=randvector(N,binomial,n,p)/n;}\\
\giacinput{count(x->abs(x-p)>1/sqrt(n),l)/N;}

On peut enfin tracer le graphe de l'\'evolution de la 
proportion de fr\'equences en-dehors
de l'intervalle $[p-1/\sqrt{n},p+1/\sqrt{n}]$ lorsque $N$ augmente.
On g\'en\`ere une liste de fr\'equences~:
\giacinputbig{N:=10000.; n:=20; p:=.4;l:=randvector(N,binomial,n,p)/n:;}
puis on compte les fr\'equences en-dehors de l'intervalle et on
stocke les fr\'equences dans une liste
\giacinputbig{L:=[]; compteur:=0; a:=p-1/sqrt(n); b:=p+1/sqrt(n);
pour j de 0 jusque N-1 faire 
  si l[j]&lt;a ou l[j]>b alors compteur++; fsi;
  L[j]:=compteur/(j+1);
fpour;
gl_y=0..0.1;plotlist(L)}

%Visualisation de la r\'epartition des fr\'equences\\
%\giacinput{plotlist(l);droite(y=p-1/sqrt(n)); droite(y=p+1/sqrt(n))}
La probabilit\'e th\'eorique d'\^etre dans l'intervalle 
$[p-1/\sqrt{n},p+1/\sqrt{n}]$ est donn\'ee par la commande
{\tt Xcas}~:\\
\giacinputbig{binomial_cdf(n,p,n*(p-1/sqrt(n)),n*(p+1/sqrt(n)))}
Il y a donc une probabilit\'e faible (de l'ordre de 4\%) 
de ne pas \^etre dans l'intervalle de fluctuation.\\
La probabilit\'e d'\^etre dans l'intervalle plus pr\'ecis
$[np-\sigma/\sqrt{n},np+\sigma/\sqrt{n}]$ est donn\'ee par~:\\
\giacinputbig{sigma:=stddev(binomial(n,p));
binomial_cdf(n,p,n*p-2*sigma,n*p+2*sigma)}
Elle est ici identique parce que les bornes de l'intervalle ont la m\^eme 
partie enti\`ere.

\section{\'Evolution d'une fr\'equence.}
On illustre l'\'evolution d'une fr\'equence vers sa moyenne th\'eorique
(esp\'erance).

Exp\'erience~: on tire un d\'e \`a 6 faces, si le r\'esultat est 1 on
renvoie 1, si c'est 2 \`a 4 on renvoie 2, si c'est 5 ou 6 on renvoie 4.
Simulation, en utilisant la fonction \verb|piecewise|~: 
\begin{giaconload}
fonction experience()
  local a;
  a:=alea(6)+1; // simule un de 6
  return piecewise(a<2,1,a<5,2,4);
ffonction:;
\end{giaconload}

On effectue $N$ exp\'eriences et on regarde l'\'evolution de la moyenne
des r\'esultats.
\begin{giaconload}
fonction evolutionmoyenne1(N)
  local l,s,j,a;
  l:=[];
  s:=0;
  pour j de 1 jusque N faire
    s:=s+experience();
    l:=append(l,s/j);
  fpour;
  return l;
ffonction:;
\end{giaconload}
\giacinput{purge(x,y);droite(y=2.5,couleur=rouge);
gl_y=0..4;plotlist(evolutionmoyenne1(1000))}
Dans la version HTML interactive, 
cliquez plusieurs fois sur le bouton ok pour voir diff\'erents 
comportements.

On peut \'ecrire une fonction plus g\'en\'erale en passant 
la fonction \verb|experience| en argument
\begin{giaconload}
fonction evolutionmoyenne(experience,N)
  local l,s,j,a;
  l:=[];
  s:=0;
  pour j de 1 jusque N faire
    s:=s+experience();
    l:=append(l,s/j);
  fpour;
  return l;
ffonction:;
\end{giaconload}

\section{Triangles de spaghettis}\index{spaghetti}
On prend un spaghetti qu'on casse en 3 morceaux, peut-on construire
un triangle avec ces 3 morceaux~?
On fixe l'unit\'e de longueur au spaghetti entier. On a donc
3 longueurs $a$, $b$ et $c=1-a-b$ et il faut v\'erifier
les in\'egalit\'es triangulaires $a<b+c, b<a+c, c<a+b$ (voir
la section \ref{sec:trisolv}).

Premi\`ere m\'ethode de coupe~: on tire au hasard $x$ et $y$ entre 0 et 1.
Si $x<y$, on pose $a=x, b=y-x$ (et donc $c=1-y$) sinon on \'echange $x$ et $y$
($a=y$, $b=x-y$ et $c=1-x$).
Simulation, \verb|correct| v\'erifie l'in\'egalit\'e triangulaire,
\verb|spag1| renvoie 1 si on peut faire un triangle et 0 sinon~:
\begin{giaconload}
correct(a,b,c):=a<b+c et b<a+c et c<a+b:;

fonction spag1()
  local x,y,c;
  x:=alea(0,1);
  y:=alea(0,1);
  si y>x alors 
    return correct(x,y-x,1-y); 
  sinon 
    return correct(y,x-y,1-x); 
  fsi;
ffonction:;

fonction spagn(n)
  local L,s;
  L:=[]; // liste des frequences de succes
  s:=0; // nombre de succes
  pour j de 1 jusque n faire
    si spag1() alors s++ fsi; 
    L:=append(L,s/j); 
  fpour;
  return L;
ffonction:;
\end{giaconload}
\giacinput{gl_y=0..1;plotlist(spagn(5000))}
{\bf Exercice~:} modifier \verb|spag1| pour
couper le spaghetti en prenant au hasard, puis en coupant le
morceau le plus long au hasard.
\begin{giacprog}
fonction spag1()
  local x,y,c;
  x:=alea(0,1);
  si x>1/2 alors
    y:=x; // on casse x
    x:=x*alea(0,1); 
  sinon // on casse 1-x
    y:=x+(1-x)*alea(0,1);
  fsi;
  return correct(x,y-x,1-y); 
ffonction:;
\end{giacprog}
Voir l'\'etude \`a la fin du manuel Algorithmes
et simulation de {\tt Xcas}.

\section{Les aiguilles de Buffon}\label{sec:buffon}\index{Buffon}
Le naturaliste Buffon, en 1777 a pos\'e le probl\`eme de l'aiguille en ces 
termes : "Je suppose que dans une chambre, dont le parquet est simplement 
divis\'e par des joints parall\`eles, on jette en l'air une baguette et que 
l'un des joueurs parie que la baguette ne croisera aucune des parall\`eles du
parquet..."

On peut mod\'eliser le probl\`eme en supposant 
que la distance entre les parall\'eles est de 1, 
et que les parall\`eles sont horizontales,
d'\'equations $y=k, k \in \mathbb{Z}$.
On suppose que la longueur de l'aiguille est $l$. Lorsqu'elle tombe sur 
le parquet, on suppose qu'une de ses extr\'emit\'es est en $(x,y)$ 
et qu'elle fait un angle $\theta$ avec l'horizontale, son autre
extr\'emit\'e est donc en $(x+l\cos(\theta),y+l\sin(\theta))$. Elle
coupe une des parall\`ele si l'intervalle $[y,y+l\sin(\theta)]$ contient
un entier c'est-\`a-dire si la partie enti\`ere de $y$ diff\`ere 
de celle de $y+l\sin(\theta)$. 
On observe que la valeur de $x$ n'a pas d'importance, et que
la valeur de $y$ modulo 1 non plus. 
Pour effectuer la simulation, on suppose donc que $y$ est un r\'eel
al\'eatoire selon la loi uniforme entre 0 et 1, et $\theta$ un r\'eel
al\'eatoire selon la loi uniforme entre $-\frac{\pi}{2}$ et $\frac{\pi}{2}$
\begin{giaconload}
fonction buffonpi(l)
  local y,theta;
  y:=alea(0,1);
  theta:=alea(-.5,.5)*pi;
  si floor(y+l*sin(theta))!=0 alors return 1; sinon return 0; fsi;
ffonction:;
\end{giaconload}
Tests pour quelques valeurs de $l$
\giacinputbig{experience():=buffonpi(0.7);
gl_y=0..1;plotlist(evolutionmoyenne(experience,1000))}
\giacinputbig{experience():=buffonpi(1);
gl_y=0..1;plotlist(evolutionmoyenne(experience,1000))}
\giacinputbig{experience():=buffonpi(2.5);
gl_y=0..1;plotlist(evolutionmoyenne(experience,1000))}

On peut aussi g\'en\'erer la direction al\'eatoire {\bf sans utiliser le
nombre $\pi$} en tirant au hasard deux r\'eels entre 0 et 1 et si le point 
obtenu est dans le disque unit\'e, on prend la direction obtenue.
\begin{giaconload}
fonction buffonsanspi(l)
  local y,X,Y;
  y:=alea(0,1); 
  repeter X:=alea(0,1); Y:=alea(0,1) jusqua X*X+Y*Y<=1;
  si floor(y+l*Y/sqrt(X^2+Y^2))!=0 alors return 1; sinon return 0; fsi;
ffonction:;
\end{giaconload}
\giacinputbig{experience():=buffonsanspi(0.7);
gl_y=0..1;plotlist(evolutionmoyenne(experience,1000))}

On peut enfin d\'efinir alg\'ebriquement 
\giacinputbig{buffon(l):=floor(alea(0,1)+l*sin(pi*alea(-.5,.5)))!=0;
experience():=buffon(0.7);
gl_y=0..1;plotlist(evolutionmoyenne(experience,1000))}

Pour conjecturer le comportement de la probabilit\'e en fonction de $l$
on va l'estimer par la fr\'equence observ\'ee au bout de $N$
d'exp\'eriences, par exemple on prendra $N=1000$ (pour \'eviter
un temps d'ex\'ecution trop long)
\begin{giaconload}
fonction probabuffon(l,N)
  local s,j;
  s:=0;
  pour j de 1 jusque N faire
    s := s+buffonpi(l);
  fpour;
  return s/N;
ffonction:;
\end{giaconload}
\giacinput{plot('probabuffon(l,1000)',l=0..2,xstep=0.04)}
Pour $l$ petit, le comportement est lin\'eaire, pour $l$ grand
on observe une asymptote horizontale (qui est $y=1$ car lorsque
la taille $l$ de l'aiguille est de plus en plus grande,
la probabilit\'e de ne pas couper une horizontale tend vers 0
puisque la direction $\theta$ doit \^etre de plus en plus proche). 
On peut d\'emontrer que
le coefficient de proportionnalit\'e pour $l$ petit vaut $\frac{2}{\pi}$,
(cf. le manuel Exercices de {\tt Xcas} pour $l=1$).

Pour obtenir un trac\'e plus pr\'ecis sans attendre trop longtemps,
il faut trouver une astuce pour acc\'el\'erer le calcul dans
\verb|probabuffon|.
Pour cela on part de la version alg\'ebrique de \verb|buffon| qui
se pr\^ete au calcul appliqu\'e en parall\`ele \`a une liste
(\verb|sin| appliqu\'e \`a une liste renvoie la liste des sinus
des \'el\'ements de la liste, \verb|+| effectue la somme composante
par composante, etc.).
On doit renvoyer 0 si 
le nombre de parall\`eles travers\'ees
est nul et 1 sinon, donc si on fait $N$ exp\'eriences,
la proportion est donn\'ee par~:\\
\giacinput{Buffon(l,N):=1-count_eq(0,floor(randvector(N,uniform,0,1)+l*sin(pi*randvector(N,uniform,-.5,.5))))/N;}
On peut maintenant tracer le graphe de mani\`ere plus pr\'ecise,
par exemple avec $N=5000$ et un pas de 0.03 sur $[0,3]$, sans patienter
trop longtemps~:\\
\giacinput{seq(point(l,Buffon(l,5000)),l,0,3,0.03)}
Ce type d'optimisation est fr\'equent dans les langages interpr\'et\'es,
on essaie d'utiliser les commandes natives du logiciel pour effectuer
les boucles les plus internes au lieu de les faire ex\'ecuter par
l'interpr\'eteur, forc\'ement plus lent que les commandes natives qui
sont compil\'ees.

\section{Marche al\'eatoire \`a 1 dimension.}\index{marche al\'eatoire}
Un marcheur ivre se d\'eplace sur un trottoir, en faisant
un pas al\'eatoirement vers la droite ou vers la gauche.
On simule sa position apr\`es $n$ pas (on suppose qu'il part de l'origine).
\begin{giaconload}
fonction marche(n)
  local j,x;
  x:=0;
  pour j de 1 jusque n faire
    si alea(2)==1 alors x++; sinon x--; fsi;
  fpour;
  return x;
ffonction:;
\end{giaconload}
On effectue $N$ marches al\'eatoires et on trace l'histogramme des
positions, par exemple pour $n=100$ et $N=3000$\\
\giacinputbig{histogram(seq(marche(100),3000),-50,2)}
On peut aussi s'int\'eresser au nombre de passage par l'origine.
\begin{giaconload}
fonction retour(n)
  local j,x,r;
  x:=0; r:=0;
  pour j de 1 jusque n faire
    si alea(2)==1 alors x++; sinon x--; fsi;
    si x==0 alors r++; fsi;
  fpour;
  return r;
ffonction:;
\end{giaconload}
et conjecturer son esp\'erance par observation d'un nombre important
de marches\\
\giacinput{experience():=retour(100);
plotlist(evolutionmoyenne(experience,3000))}
On peut aussi observer l'esp\'erance en fonction du nombre de pas.
Pour cela, on approche l'esp\'erance par exemple par la moyenne de
1000 nombre de retours.
\begin{giaconload}
fonction moyenneretour1(n)
  local s,j;
  s:=0;
  pour j de 1 jusque 1000 faire
    s := s+retour(n);
  fpour;
  return s/1000;
ffonction:;
\end{giaconload}
\giacinput{plot('moyenneretour1(n)',n=20..200,xstep=20)}

Comme pour les aiguilles de Buffon, le temps de calcul est long (c'est
pour cela que l'on a mis un pas de 20 dans la commande pr\'ec\'edente),
mais il est possible d'acc\'el\'erer en faisant plusieurs optimisations~:
\begin{itemize}
\item au lieu de d\'ecaler de 1 ou -1, on peut d\'ecaler de 1 ou 0
en d\'ecidant que l'origine se d\'ecale elle-m\^eme de 1/2.
\item le passage par l'origine ne peut s'effecteur qu'apr\`es un nombre
pair de pas, on peut donc faire 2 pas \`a la fois avant
de tester. \`A chaque it\'eration, on fait 
donc deux pas de valeur 1 ou 0 et l'origine
est d\'ecal\'ee de 1.
\item on remplace les boucles les plus internes
par du calcul sur des listes.
\end{itemize}
\begin{giaconload}
fonction moyenneretour(N,n) // N experiences, marche de n
  local k,pos,r;
  pos:=seq(0,N); // N marcheurs a l'origine
  r:=0;
  n:=iquo(n,2);
  pour k de 1 jusque n faire
    pos:=pos+randvector(N,2)+randvector(N,2); 
    r:=r+count_eq(k,pos); // nombre de passage origine translatee
  fpour;
  retourne r/N;
ffonction:;
\end{giaconload}
On peut maintenant faire le trac\'e avec une bonne pr\'ecision en
quelques secondes~:\\
\giacinput{seq(point(n,moyenneretour(2000,n)),n,1,200)}

\section{Les urnes de Polya}\index{Polya}
On place dans une urne $r$ boules rouges et $b$ boules bleues, indiscernables
au toucher.
On tire une boule, on note sa couleur, et on remet dans l'urne cette boule 
ainsi qu'une boule de m\^eme couleur (le nombre total de boules
augmente donc de 1). On recommence, on effectue en tout $n$ tirages.

On fait une simulation, on va renvoyer 
la liste des proportions de boules rouges
dans l'urne au cours de l'exp\'erience.
Il y a $r$ boules rouges parmi $r+b$, on convient donc que
la boule tir\'ee est rouge si un tirage d'entier dans $[0,r+b[$
est strictement inf\'erieur \`a $r$.
\begin{giaconload}
fonction polya(r,b,n)
  local L,j;
  L:=[r/(r+b)];
  pour j de 1 jusque n faire
    si alea(r+b)<r alors r++; sinon b++; fsi;
    L[j]:=r/(r+b);
  fpour;
  return L;
ffonction:;
\end{giaconload}
{\bf Exemple~:}\\
Simulation avec 1000 tirages et 1 boule rouge et 1 boule bleue au d\'ebut~:
\giacinput{gl_y=0..1;plotlist(polya(1,1,1000))}
Dans la version HTML, si on clique plusieurs fois, on observe que la valeur
limite est tr\`es variable.
On peut s'int\'eresser \`a la r\'epartition de cette proportion limite
de boules rouges (obtenue ici au bout de 1000 \'etapes). On modifie
la fonction pr\'ec\'edente pour ne renvoyer que la derni\`ere proportion.
\begin{giaconload}
fonction polya1(r,b,n)
  local j;
  pour j de 1 jusque n faire
    si alea(r+b)<r alors r++; sinon b++; fsi;
  fpour;
  return r/(r+b);
ffonction:;
\end{giaconload}
Puis on fait l'histogramme des fr\'equences pour $N$ exp\'eriences
\giacinput{N:=100;histogramme(seq(polya1(1,1,1000),N),0,0.1);}
Le temps de calcul commence
\`a s'allonger, on peut essayer d'optimiser un peu. On observe
que le nombre total de boules augment\'e de 1 \`a chaque tirage, 
il suffit donc de suivre la valeur de $r$
\begin{giaconload}
fonction polya2(r,b,n)
  local j,total,totalalafin;
  totalalafin:=r+b+n-1;
  pour total de r+b jusque totalalafin faire
    si alea(total)<r alors r++; fsi;
  fpour;
  return r/(total-1);
ffonction:;
\end{giaconload}
\giacinput{N:=1000;histogramme(seq(polya2(1,1,1000),N),0,0.1);}
Une autre fa\c{c}on d'optimiser consiste \`a observer que \verb|j|
ne sert pas dans la boucle \verb|pour| de \verb|polya1|.
\begin{giaconload}
fonction polya3(r,b,n)
  seq(when(alea(r+b)<r,r++, b++),n);
  return r/(r+b);
ffonction:;
\end{giaconload}
\giacinput{N:=1000;histogramme(seq(polya3(1,1,1000),N),0,0.1);}
Pour $N=1000$, on s'aper\c{c}oit que
la distribution semble uniforme. Ceci n'est plus le cas pour
d'autres valeurs de $r$ et $b$, dans la version HTML, vous pouvez
tester diverses valeurs initiales, par exemple 5,5 ou 1,5.
\giacinput{N:=1000;histogramme(seq(polya3(1,5,1000),N),0,0.1);}

\chapter{Les algorithmes du document ressource Python d'eduscol}
On propose dans ce chapitre des versions {\tt Xcas} de programmes
Python donn\'es dans ce
\footahref{http://cache.media.eduscol.education.fr/file/Mathematiques/73/3/Algorithmique\_et\_programmation\_787733.pdf}{document}

Pour les statistiques, voir le chapitre \ref{chap:stats}. 

Pour la dichotomie, voir \ref{sec:dichotomie}.

\section{Arithm\'etique}
On renvoie au manuel de programmation de {\tt Xcas} (menu Aide, Manuels), on
donne ici rapidement les \'equivalents {\tt Xcas} du document eduscol.

\subsection{Euclide}
On calcule le PGCD de $a$ et $b$ en observant que si $b$ est nul c'est $a$,
sinon c'est le PGCD de $b$ et du reste de la division euclidienne de $a$ par
$b$ (\verb|irem(a,b)|)
\begin{giaconload}
fonction pgcd(a,b)
  tantque b!=0 faire 
    a,b:=b,irem(a,b);
  ftantque;
  return a;
ffonction:;
\end{giaconload}
\giacinputbig{pgcd(25,15)}

\subsection{\'Ecriture en base 2}
L'\'ecriture de $n$ en base 2 est l'\'ecriture de $n/2$ \`a laquelle
on ajoute le reste de la division $n$ par 2.
\begin{giaconload}
fonction base2(n)
  local l;
  l:=[];
  tantque n>0 faire
    l:=append(l,irem(n,2));
    n:=iquo(n,2);
  ftantque;
  return revlist(l);
ffonction:;
\end{giaconload}
Il faut inverser l'ordre des \'el\'ements dans la liste 
avant de la renvoyer, parce qu'on calcule
en premier le dernier bit de l'\'ecriture de $n$ en base 2.
\giacinputbig{l:=base2(12345)}

L'op\'eration inverse se fait en utilisant le m\^eme principe~: lorsqu'on
ajoute un bit \`a la fin de l'\'ecriture de $n$ en base 2, cela revient
\`a multiplier $n$ par 2 et lui ajouter la valeur de ce bit.
\begin{giaconload}
fonction base10(l)
  local n,x;
  n:=0;
  pour x in l faire
    n=2*n+x;
  fpour;
  return n;
ffonction:;
\end{giaconload}
\giacinputbig{base10(l)}

La taille de l'\'ecriture en base 2 s'obtient par \verb|dim(l)|
ou directement par le programme suivant
\begin{giaconload}
fonction taille2(n)
  local l;
  l:=0;
  tantque n>0 faire
    n:=iquo(n,2);
    l++;
  ftantque;
  return l;
ffonction:;
\end{giaconload}
\giacinputbig{taille2(12345)}

\subsection{Test na\"if de primalit\'e}
On teste si $n$ est divisible par un entier $d\leq \sqrt{n}$.
\begin{giaconload}
fonction estpremier(n)
  local d;
  si n<2 alors return false; fsi;
  d:=2;
  tantque d*d<=n faire
    si irem(n,d)=0 alors return false; fsi;
    d++;
  ftantque;
  return true;
ffonction:;
\end{giaconload}
\giacinputbig{estpremier(1234567); isprime(1234567);}

\subsection{Factorisation na\"ive}
Au lieu de s'arr\^eter et d'indiquer que le nombre n'est pas premier
lorsqu'on a une division exacte par $d$, on ajoute $d$
\`a la liste des facteurs et on divise $n$ par $d$.
Lorsqu'on sort de la boucle ext\'erieure, $n$ vaut 1 ou est premier, 
il ne faut pas oublier de l'ajouter \`a la liste des facteurs.
\begin{giaconload}
fonction facto(n)
  local l,d;
  l:=[]; d:=2;
  tantque d*d<=n faire
    tantque irem(n,d)=0 faire
      l:=append(l,d);
      n:=n/d;
    ftantque;
    d++;
  ftantque;
  si n>1 alors l:=append(l,n); fsi;
  return l;
ffonction:;
\end{giaconload}
\giacinputbig{facto(12345); ifactor(12345)}
{\bf Exercice~:}\\
 Comparer l'efficacit\'e de l'algorithme pr\'ec\'edent avec l'algorithme du 
document eduscol~:
\begin{giaconload}
fonction facto1(n)
  local l,d;
  l:=[]; d:=2;
  tantque n>1 faire
    si irem(n,d)=0 alors
      tantque irem(n,d)=0 faire
        l:=append(l,d);
        n:=n/d;
      ftantque;
    fsi;
    d++;
  ftantque;
  return l;
ffonction:;
\end{giaconload}
\giacinputbig{facto1(1234567); facto(1234567); time(facto1(1234567)); time(facto(1234567))}
On pourra compter le nombre d'it\'erations si $n$ est premier.

\section{Longueur d'un arc de courbe}
On cherche la longueur approch\'ee d'un arc de courbe d'\'equation
$y=f(x)$ entre les points d'abscisses $a$ et $b$. Pour cela
on approche l'arc de courbe par une ligne polygonale compos\'ee
de $n$ petits segments reliant les points de la courbe d'abscisses $a+kh$ 
et $a+(k+1)h$ pour $k \in [0,n-1]$ et $h=\frac{b-a}{n}$.
\begin{giaconload}
fonction longueurcourbe(f,a,b,n)
  local l,k,h;
  h:=evalf((b-a)/n);
  l:=0;
  pour k de 0 jusque n-1 faire
    l:=l+distance(point(a+k*h,f(a+k*h)),point(a+(k+1)*h,f(a+(k+1)*h)));
  fpour;
  return l;
ffonction:;
\end{giaconload}
\giacinputbigmath{f(x):=sqrt(1-x^2); longueurcourbe(f,0,1,100)}

{\bf Exercice~:} \\
Cette fonction {\tt longueurcourbe} est relativement inefficace, car on calcule 
plusieurs fois les m\^emes quantit\'es. Utilisez des variables locales
pour la rendre plus efficace.

{\bf Solution~:}
\begin{giacprog}
fonction longueurcourbe(f,a,b,n)
  local l,k,h,x,M,N;
  h:=evalf((b-a)/n);
  l:=0;
  x:=a;
  M:=point(x,f(x));
  pour k de 0 jusque n-1 faire
    x:=x+h;
    N:=point(x,f(x));
    l:=l+distance(M,N);
    M:=N;
  fpour;
  return l;
ffonction:;
\end{giacprog}
\giacinputbigmath{f(x):=sqrt(1-x^2); longueurcourbe(f,0,1,100)}

{\bf Remarque~:} $h$ est approch\'e, donc en effectuant la boucle on
va accumuler des erreurs d'arrondis. Si l'erreur est faite par
exc\`es, la derni\`ere valeur de $x$ risque d'\^etre un peu 
sup\'erieure \`a 1, et $f(x)$ devient alors complexe, avec
une partie imaginaire tr\`es petite. Ceci n'a pas d'importance
dans {\tt Xcas}, car l'instruction \verb|point(x,y)| renvoie
le point d'affixe $x+iy$. Dans d'autres langages, par exemple Python,
cela peut provoquer une erreur.

{\bf Exercice~:} \\
Faire afficher la ligne polygonale dont on calcule la longueur.

{\bf Solution~:}
\begin{giacprog}
fonction approxcourbe(f,a,b,n)
  local L,k,h,x,M,N;
  h:=evalf((b-a)/n);
  x:=a;
  M:=point(x,f(x));
  L:=[M];
  pour k de 0 jusque n-1 faire
    x:=x+h;
    N:=point(x,f(x));
    L:=append(L,N);
    M:=N;
  fpour;
  return polygone_ouvert(L);
ffonction:;
\end{giacprog}
\giacinputbig{f(x):=sqrt(1-x^2); plot(f(x),x=0..1,affichage=rouge);approxcourbe(f,0,1,10)}

\section{R\'efraction et recherche de minimas}
On se donne une courbe d'\'equation $y=f(x)$ 
s\'eparant deux milieux d'indices $n_1$ et
$n_2$ et on cherche le chemin lumineux reliant deux points $A(x_A,y_A)$
et $B(x_B,y_B)$ situ\'es de part et d'autre de la courbe, 
il s'agit de deux segments de droite $AM$ et $BM$ o\`u $M$
est le point de la courbe tel que la somme
$n_1AM+n_2BM$ est minimal. Comme $M$ a pour coordonn\'ees $(x,f(x))$,
on peut calculer cette somme en fonction de $x$
$$ g(x)=n_1\sqrt{(x-x_A)^2+(f(x)-y_A)^2}+n_2\sqrt{(x-x_B)^2+(f(x)-y_B)^2}$$
Il s'agit donc de d\'eterminer le minimum de la fonction $g$
(en supposant connue la fonction $f$).

\subsection{Minimum d'une fonction}
On commence par la recherche approch\'ee du minimum d'une fonction $g$.
On se donne un point de d\'epart $x$ et un pas $h$, on regarde si on
diminue la valeur de $g$ en se d\'epla\c{c}ant vers la gauche.
Si c'est le cas, on continue \`a se d\'eplacer vers la gauche
jusqu'\`a ce que $g$ ne diminue plus, on a alors atteint un
minimum local relativement \`a la discr\'etisation choisie.
Si ce n'est pas le cas, on essaie de se d\'eplacer vers la 
droite.\footnote{Cette m\'ethode se g\'en\'eralise en dimension plus grande,
on cherche la direction de plus grande pente et on se d\'eplace dans
cette direction d'un pas constant}
\begin{giaconload}
fonction minih(g,x,h) 
  // recherche d'un minimum local de g a partir de x en se deplacant
  // par pas de h vers la gauche ou vers la droite
  si g(x-h)<g(x) alors
    tantque g(x-h)<g(x) faire x:=x-h; ftantque;
  sinon
    tantque g(x+h)<g(x) faire x:=x+h; ftantque;
  fsi;
  retourne x;
ffonction:;
\end{giaconload}
{\bf Exemple~:}\\
 Recherche du minimum de la fonction $(x^2-2)^2$ en partant
de 2.0 (prendre le carr\'e d'une expression, ici $x^2-2$, et en chercher
le minimum est une m\'ethode de recherche d'une solution approch\'ee)
\giacinputbig{g(x):=(x^2-2)^2:; minih(g,1.0,0.1)}
{\bf Attention !} ce programme peut tourner en boucle ind\'efiniment si $g$ 
d\'ecroit ind\'efiniment. Un programme plus robuste fixera un nombre
maximal d'it\'erations, par exemple ici 1000 par d\'efaut.
\begin{giacprog}
fonction minih(g,x,h,N=1000) 
  local j;
  si g(x-h)<g(x) alors
    pour j de 1 jusque N faire 
      si g(x-h)>g(x) alors return x; fsi;
      x:=x-h;
    fpour;
  sinon
    pour j de 1 jusque N faire 
      si g(x+h)>g(x) alors return x; fsi;
      x:=x+h;
    fpour;
  fsi;
  retourne "non trouve";
ffonction:;
\end{giacprog}
{\bf Exercice~:}\\
 Am\'eliorer ce programme pour calculer $g$ une seule
fois par it\'eration.

{\bf Solution~:}\\
Pour avoir une valeur de $x$ avec une pr\'ecision fix\'ee \`a l'avance,
on commence avec un pas de $h$ (par d\'efaut 0.1) et on divise le pas
par 10.
\begin{giaconload}
fonction mini(g,x,h=0.1,eps=1e-10) 
  // recherche d'un minimum local avec une precision de eps
  tantque h>eps faire
    x:=minih(g,x,h);
    h:=h/10;
  ftantque;
  retourne minih(g,x,h);
ffonction:;
\end{giaconload}
On effectue un dernier appel \`a \verb|minih| pour assurer que la 
pr\'ecision est meilleure que \verb|1e-10|.
\giacinputbig{g(x):=(x^2-2)^2:; mini(g,1.0)}
{\bf Exercice~:} \\
expliquer pourquoi il est plus rapide d'appeler 
\verb|mini(g,1.0,0.1,1e-10)| que \verb|minih(g,1.0,1e-10)|.

\subsection{Application \`a la r\'efraction}
Appliquons maintenant au probl\`eme de la r\'efraction.
La fonction \verb|refraction|
prend en arguments la fonction $f$ d\'efinissant la courbe s\'eparatrice,
les points $A$ et $B$ et les indices de r\'efraction, elle
renvoie le point $M$. 
\begin{giaconload}
fonction refraction(f,A,B,n1,n2)
  local g,x,tst;
  si f(abscisse(A))<ordonnee(A) ou f(abscisse(B))>ordonnee(B) alors 
    return "A et B sont du meme cote du graphe!"; 
  fsi;
  g(x):=n1*distance(A,point(x,f(x)))+n2*distance(B,point(x,f(x))); 
  x:=mini(g,abscisse(milieu(A,B)));
  return point(x,f(x));
ffonction:;
\end{giaconload}
Illustration avec une fonction lin\'eaire $1-2x$, 
la s\'eparatrice est la droite $D$ d'\'equation $y=1-2x$
\giacinputbig{f(x):=1-2x;
gl_ortho=true;D:=plot(f(x),x=0..1,couleur=vert);
A:=point(0,0); B:=point(1,1); M:=refraction(f,A,B,2.5,1);
segment(A,M,couleur=rouge); segment(M,B,couleur=rouge)}
Pour tester avec une courbe non lin\'eaire, par
exemple avec la fonction $f(x)=\cos(5x)$, il suffit de modifier la d\'efinition
de $f$~:
\giacinputbig{f(x):=cos(5x);
gl_ortho=true;D:=plot(f(x),x=0..1,couleur=vert);
A:=point(0,0); B:=point(1,1); M:=refraction(f,A,B,2.5,1);
segment(A,M,couleur=rouge); segment(M,B,couleur=rouge)}


\subsection{Discussion}
L'application \`a la r\'efraction
est certainement trop difficile pour des \'el\`eves d\'ebutants, on 
d\'efinit en effet ici une fonctionnelle (fonction dont un argument
est une fonction), et on d\'efinit une fonction dans une 
autre fonction (la fonction $g$). De plus la d\'efinition
de $g$ ci-dessus n'est pas recommand\'ee, car elle
d\'epend de la valeur de param\`etres $n_1,n_2, A$ et $B$ qui
ne sont pas pass\'es en argument
($g$ n'est pas une fonction
pure, i.e. ind\'ependante du contexte).
Pour rendre $g$ ind\'ependante du contexte, il faut remplacer 
dans son expression
\verb|n1*distance(A,M)+n2*distance(B,M)|\\ 
$n_1,n_2,A,B$ par leurs valeurs. Dans {\tt Xcas}, on peut le faire 
en utilisant le moteur de calcul formel. On utilise une variable
symbolique \verb|x| pour calculer l'expression de $g$,
c'est le r\^ole de la commande \verb|purge(x)| ci-dessous, 
et on utilise la commande \verb|unapply| qui permet de d\'efinir
une fonction \`a partir d'une expression.
\begin{giacprog}
fonction refraction(f,A,B,n1,n2)
  local g,M,x,tst,xM;
  tst:=(f(abscisse(A))-ordonnee(A))*(f(abscisse(B))-ordonnee(B));
  si tst>=0 alors return "A et B sont du meme cote du graphe!"; fsi;
  purge(x);
  M:=point(x,f(x));
  g:=unapply(n1*distance(A,M)+n2*distance(B,M),x);
  xM:=mini(g,abscisse(milieu(A,B)));
  return point(xM,f(xM));
ffonction:;
\end{giacprog}
On a aussi am\'elior\'e le test que les deux points $A$ et 
$B$ sont bien de part
et d'autre de la courbe
en introduisant une variable locale \verb|tst|
qui doit \^etre n\'egative.

Dans des langages non formels, pour faire les choses proprement, il
faut passer explicitement les param\`etres \verb|A,B,n1,n2| \`a la
fonction \verb|g|, en les regroupant (dans une liste dans un langage
de script, par un pointeur vers une structure en C).
Le prototype de la fonction \verb|g| est alors \verb|g(x,params)|,
celui des fonctions \verb|mini| est \verb|mini(g,param,x,h,eps)|. Mais
ceci complique bien sur la pr\'esentation au niveau du lyc\'ee.

\subsection{Autre m\'ethode de recherche de minimum}
On suppose ici qu'on cherche le minimum d'une fonction $g$ sur
un intervalle $[a,b]$ avec $g$ d'abord d\'ecroissante puis croissante.
On suppose donc qu'on a un triplet $a,c,b$ tel que 
$g(c)$ est plus petit que $g(a)$ et $g(b)$
$$ a<c<b, \quad  g(c)<g(a), g(c)<g(b)$$
On effectue ensuite une sorte de dichotomie. On se fixe une pr\'ecision
$\epsilon$
\begin{enumerate}
\item On effectue une boucle tant que $b-a>\epsilon$
\item On calcule la valeur de $g$ au milieu $u$ de $[a,c]$.
Si $g(u)$ est plus petit que $g(a)$ et $g(c)$ on peut utiliser
le nouveau triplet $a,u,c$, on passe \`a l'it\'eration suivante.
\item Sinon, on calcule la valeur de $g$ au milieu $v$ de $[c,b]$.
Si $g(v)$ est plus petit que $g(c)$ et $g(b)$ on peut utiliser
le nouveau triplet $c,v,b$, on passe \`a l'it\'eration suivante.
\item Sinon, $g(u)$ est plus grand que $g(c)$ ou que $g(a)$ donc
est plus grand que $g(c)$ puisque $g(c)<g(a)$, et de m\^eme $g(v)$
est plus grand que $g(c)$, donc on utilise le nouveau triplet $u,c,v$
et on passe \`a l'it\'eration suivante.
\end{enumerate}
Le programme se termine (En effet, si on applique la troisi\`eme r\`egle,
$b-a$ est divis\'e par 2. Si on applique uniquement la 1\`ere et la
2\`eme r\`egle, si on applique deux fois de suite la premi\`ere r\`egle
$b$ est remplac\'e par $c$ puis par le $u$ pr\'ec\'edent donc
on gagne un facteur 2, de m\^eme pour la deuxi\`eme r\`egle, si
on applique la premi\`ere puis la deuxi\`eme $b$ est remplac\'e par $c$
et $a$ par $u$ donc on gagne aussi un facteur 2).
\begin{giaconload}
fonction mini2(g,a,b,c,eps=1e-10)
  local u,v;
  si c<=a ou c>=b alors return "erreur"; fsi;
  si g(c)>=g(a) ou g(c)>=g(b) alors return "erreur"; fsi;
  tantque b-a>eps faire
    u:=(a+c)/2;
    si g(u)<g(a) et g(u)<g(c) alors a,c,b:=a,u,c; continue; fsi;
    v:=(b+c)/2;
    si g(v)<g(c) et g(v)<g(b) alors a,c,b:=c,v,b; continue; fsi;
    a,c,b:=u,c,v;
  ftantque;
  return a,b,c;
ffonction:;
\end{giaconload}
\giacinputbig{mini2(cos,1.0,6.0,3.0)}
{\bf Exercice~:} \\
Rendre ce programme plus efficace en calculant le moins de fois
possible les images par $g$ de $a,b,c,u,v$.

\section{Solveur de triangle} \label{sec:trisolv}
On cherche \`a construire un triangle $ABC$ dont les cot\'es sont
donn\'es par $a=BC,b=AC,c=AB$ o\`u $a,b,c$ 
v\'erifient les in\'egalit\'es triangulaires
$$ a<b+c, \quad b<a+c, \quad c<a+b$$
On peut par translation se ramener au cas o\`u $A$ est l'origine, puis
par rotation \`a $B(c,0)$, il s'agit donc de d\'eterminer les
coordonn\'ees $(x,y)$ de $C$. 
\begin{giaconload}
c:=3; x:=1; y:=2;
A:=point(0,0,legende="A(0,0)"); 
B:=point(c,0,legende="B(c,0)"); 
C:=point(x,y,legende="C(x,y)");
triangle(A,B,C);
\end{giaconload}
On a deux \'equations
$$ a^2=BC^2=(x-c)^2+y^2, \quad b^2=AC^2=x^2+y^2$$
En en faisant la diff\'erence, on obtient 
$$ a^2-b^2=(x-c)^2-x^2=-2cx+c^2$$
d'o\`u l'on tire la valeur de $x$
$$ x=\frac{c^2-(a^2-b^2)}{2c}$$
puis la deuxi\`eme \'equation nous donne deux valeurs pour $y$ (correspondant
\`a deux triangles sym\'etriques)
$$ y=\pm \sqrt{b^2-x^2}$$
{\bf Remarque :}\\
Puisque $a,b,c$ v\'erifient les in\'egalit\'es triangulaires
$ a<b+c, \quad b<a+c, \quad c<a+b$ si $x=\frac{c^2-(a^2-b^2)}{2c}$ alors 
$b^2-x^2\geq 0$, en effet :\\
$4c^2x^2=(b^2+c^2-a^2)^2$ donc \\
$4c^2(b^2-x^2)=(2cb)^2-(b^2+c^2-a^2)^2=(2cb+b^2+c^2-a^2)(2cb-b^2-c^2+a^2)$.\\
Donc $b^2-x^2$ a le m\^eme signe que $((b+c)^2-a^2)(a^2-(b-c)^2)$.\
Ce signe est positif puisque d'apr\`es les in\'egalit\'es triangulaires on a :\\
 $0<a<b+c$ donc $a^2<(b+c)^2$ et\\
 $ b-c<a$  et $c-b<a$ donc $|b-c|<a$ donc $(b-c)^2<a^2$.
\begin{giaconload}
fonction trisolve(a,b,c)
  local x,y;
  x:=(c^2+b^2-a^2)/(2*c);
  y:=sqrt(b^2-x^2);
  return point(0,0),point(c,0),point(x,y);
ffonction:;
\end{giaconload}
\giacinputbig{A,B,C:=trisolve(3,4,5); triangle(A,B,C)}

{\bf Remarque~:} \\
Le document ressource Python eduscol utilise une m\'ethode
de r\'esolution approch\'ee pour d\'eterminer le triangle. Cela nous
semble peu adapt\'e, car la r\'esolution exacte est accessible
au niveau lyc\'ee et est beaucoup plus simple.

\chapter{Aide}
\section{Les fonctions usuelles avec {\tt Xcas}}
\noindent{\tt abs} : valeur absolue ou le module de l'argument.\\
{\tt ceil} : renvoie le plus petit entier >= \`a l'argument.\\
{\tt cos} : renvoie le cosinus de l'argument.\\
{\tt Digits} : pseudo-variable pour modifier le nombre {\tt n} de chiffres 
significatifs (par ex {\tt Digits:=n}).\\
{\tt evalf} : \'evaluation num\'erique du premier argument (le nombre de digits 
peut \^etre donn\'e comme second argument).\\
{\tt floor} : renvoie la partie enti\`ere de l'argument (le plus grand entier 
<= \`a l'argument.\\
{\tt frac} : partie fractionnaire de l'argument.\\
{\tt max} : renvoie le maximum des \'el\'ements d'une s\'equence ou d'une liste de r\'eels.\\
{\tt min} : renvoie le minimum des \'el\'ements d'une s\'equence ou d'une liste de r\'eels.\\
{\tt +} : renvoie la concat\'enation de 2 cha\^ines ou addition terme \`a terme 
de 2 expressions ou 2 listes (op\'erateur infix\'e).\\
{\tt round} : renvoie l'argument r\'eel arrondi \`a l'entier (ou le d\'ecimal)
le plus proche. \\
{\tt sin} : renvoie le sinus de l'argument.\\
{\tt sign} : renvoie le signe (-1,0,+1) de l'argument.\\
{\tt sqrt} : renvoie la racine carr\'ee de l'argument.\\
{\tt tan} : renvoie la tangente de l'argument.
\section{Les fonctions {\tt Xcas} de calcul formel utilis\'ees}
\noindent{\tt coeff(P,var,[n]} : renvoie la liste des coefficients d'un polynôme
{\tt P} par rapport \`a la variable {\tt Var} ou le coefficient de 
degr\'e {\tt n}.\\
{\tt count(f,L)} : applique la fonction {\tt f} aux \'el\'ements de la liste 
{\tt L} et en renvoie la somme.\\
{\tt degree(P,var} : renvoie le degr\'e du polynôme {\tt P} par rapport à la 
variable {\tt var}.\\
{\tt dim} : renvoie la longueur d'une liste, d'une s\'equence ou d'une cha\^ine de caract\`eres.\\
{\tt droit} : renvoie le c\^ot\'e droit d'une \'equation, d'un intervalle, 
d'une liste ou d'une cha\^ine .\\
{\tt fsolve} ou {\tt resoudre\_numerique} : renvoie la solution num\'erique d'une \'equation. \\
{\tt gauche} : renvoie le c\^ot\'e gauche d'une \'equation, d'un intervalle, 
d'une liste ou d'une cha\^ine.\\
{\tt iquo} : renvoie le quotient euclidien de 2 entiers. \\
{\tt iquorem} : renvoie la liste du quotient et du reste euclidien de 2
entiers.\\
{\tt irem} : renvoie le reste euclidien de 2 entiers.\\
{\tt normal} : renvoie une simplification de l'argument.\\
{\tt purge(a)} : enl\`eve la valeur stock\'ee dans la variable {\tt a}.\\
{\tt simplify} ou {\tt simplifier} : renvoie une simplification de l'argument.\\
{\tt solve} ou {\tt resoudre} : renvoie la solution d'une \'equation.\\
{\tt sommets} : renvoie la liste des sommets d'un polygone.\\
{\tt subst} ou {\tt substituer} : remplace dans une expression, une variable non affect\'ee par 
une valeur.\\
{\tt sum} ou {\tt somme} : somme des \'el\'ements d'une liste (ou s\'equence).\\
{\tt subtype} : renvoie 1 pour une s\'equence, 2 pour un ensemble, 10 pour un 
polyn\^ome et 0 sinon ce qui d\'efinit le sous-type de l'argument.\\
{\tt type} : renvoie $n$ dans [1..12] d\'efinissant le type de l'argument.

\section{Les fonctions {\tt Xcas} de g\'eom\'etrie utilis\'ees}
\noindent{\tt affichage} : employ\'e comme option de commandes graphiques permet
 de faire des dessins en couleur (par ex 
{\tt A:=point([1,1],affichage=rouge)}).\\
{\tt carre} : renvoie et dessine le carr\'e direct donn\'e par 2 
points.\\
{\tt centre} : renvoie et dessine le centre du cercle donn\'e en argument.\\
{\tt cercle} : renvoie et dessine le cercle donn\'e par 1 point et 1 r\'eel (son
 centre et son rayon) ou par 2 points (son diam\`etre) ou par son \'equation.\\
{\tt demi\_droite} : renvoie et dessine la demi-droite donn\'ee par son origine
 et 1 point ou par son origine et son vecteur directeur [1,m].\\
{\tt droite} : renvoie et dessine la droite donn\'ee par 2 points ou par 1 point
 et son vecteur directeur [1,m].\\
{\tt est\_aligne} : renvoie 1 si les points sont align\'es, 2 si les points sont
 confondus et 0 sinon.\\
{\tt est\_parallele} : renvoie 1 si 2 droites sont parall\`eles et 0 sinon.\\
{\tt equation} : renvoie l'\'equation de l'argument.\\
{\tt inter} dessine et renvoie la liste des points d'intersection de 2 objets g\'eom\'etriques.\\
{\tt inter\_unique} renvoie et dessine un des points d'intersection de 2 objets g\'eom\'etriques.\\
{\tt longueur} : renvoie la longueur du segment d\'efini par 2 points 
ou par les coordonn\'ees de ces points.
{\tt norm} : renvoie la norme l2 d'un vecteur :\\
{\tt norm}$([x_1,..x_n])$ : renvoie $\sqrt(x_1^2+...x_n^2)$\\
{\tt point}  : renvoie et dessine le point de coordonn\'ees l'argument.\\
{\tt polygone} : renvoie et dessine le polygone donn\'e par une liste de 
points.\\
{\tt polygone\_ouvert} : renvoie et dessine la ligne polygonale donn\'ee par une
 liste de points.\\
{\tt rayon} :renvoie le rayon du cercle donn\'e en argument.\\
{\tt segment}  : renvoie et dessine soit le segment donn\'e par 2 points ou 
le vecteur donn\'e par un point et son vecteur directeur. {\bf Bien voir} la 
diff\'erence entre {\tt segment(point(cA),point(cB))} (c'est le segment (A,B)) 
et {\tt segment(cA,cB)} qui est aussi {\tt segment(point(cA),point(cA+cB))}.\\
{\tt sommets} : renvoie la liste des sommets du polygone donn\'e en argument et les dessine.\\ 
{\tt translation(B-A,C)} : renvoie et dessine le translat\'e de {\tt C} dans la 
translation de vecteur {\tt AB}.\\
{\tt triangle} : renvoie et dessine le triangle donn\'e par 3 points.\\
{\tt vecteur} : renvoie et dessine le vecteur donn\'e par 2 points ou par un 
point et son vecteur directeur. {\bf Bien voir} la 
diff\'erence entre {\tt vecteur(point(cA),point(cB))}(c'est le vecteur (A,B)) et
{\tt vecteur(cA,cB)} qui est aussi {\tt vecteur(point(cA),point(cA+cB))}.
\section{Les fonctions {\tt Xcas} de programmation utilis\'ees}
\noindent{\tt break} : pour interrompre une boucle (tantque <cond> faire inst1; 
si <cond> alors inst2;break;fsi;ftantque;).\\
{\tt fpour}\\
{\tt fsi}\\
{\tt ftantque}\\
{\tt jusque}\\
{\tt local}\\
{\tt pas}\\
{\tt pour <k> de <k1> jusque <k2> faire  <instructions> pas <p> fpour}\\
{\tt quand}\\
{\tt retourne}\\
{\tt si <condition> alors <instructions1> sinon <instructions2> fsi}\\
{\tt tantque <condition> faire  <instructions> ftantque}

\section{Les fonctions {\tt Xcas} utilis\'ees en statistiques}
\noindent{\tt alea(n1,n2)} : renvoie un r\'eel al\'eatoire de [n1,n2[.\\
{\tt alea(n)}~: renvoie un entier al\'eatoire entre 0 et {\tt n-1}.
\\
{\tt binomial} : peut \^etre employ\'e comme option de la commande {\tt randvector}.\\
{\tt binomial\_cdf(n,p,x1,x2)} : renvoie Proba(x1<=X<=x2) quand X suit la loi 
binomiale B(n,p).\\
{\tt mean} : renvoie la moyenne d'une liste ou d'une liste pond\'er\'ee par le 
deuxi\`eme argument.\\
{\tt median} : renvoie la m\'ediane d'une liste ou d'une liste pond\'er\'ee par 
le deuxi\`eme argument.\\ 
{\tt plotlist} : lorsque l'argument est $L=[y_0,...,y_n]$, trace la ligne 
polygonale reliant les points d'abscisse $k$ et d'ordonn\'ee $y_k$ pour 
$k=0..n$.\\
{\tt randvector} : renvoie une liste de nombres al\'eatoires de taille $n$ 
constitu\'ee d'entiers al\'eatoires distribu\'es selon la loi indiqu\'ee.\\
{\tt stddev} : renvoie l'\'ecart-type d'une liste ou d'une liste pond\'er\'ee
 par le deuxi\`eme argument.\\

\appendix \label{sec;python}

\chapter{Xcas, Python et Javascript.}

\section{Le mode de compatibilit\'e Python de Xcas} \label{sec:python}
Xcas accepte une syntaxe compatible avec le langage {\tt Python}. 
La principale diff\'erence entre la programmation en fran\c{c}ais
et Python, c'est qu'il n'y a
pas de fin de bloc explicite en Python, c'est l'indentation qui joue
ce r\^ole. L'indentation consiste \`a ajouter au d\'ebut de chaque 
ligne d'un m\^eme bloc le m\^eme nombre d’espaces.
Il est recommand\'e d'indenter les programmes en mode Xcas, en
mode Python c'est obligatoire.
Il faut donc faire attention :
\begin{itemize}
\item lorsqu'on copie un programme {\tt Python} avec un copier-coller : cela 
risque de modifier l'indentation,
\item lorsqu'on \'ecrit un texte contenant un programme {\tt Python}
de faire en sorte que ce programme apparaisse sur une seule page (ce qui n'est pas toujours possible pour un programme contenant beaucoup d'instructions !).
\end{itemize}
Attention, le mode de compatibilit\'e Python de Xcas n'est pas identique
\`a Python. Seules les constructions de base sont accept\'ees (pas de
programmation orient\'ee objet)~ :
\begin{itemize}
\item {\tt def} pour d\'efinir une fonction,
\item {\tt if} pour un test, 
\item {\tt for} pour une boucle pour, 
\item {\tt while} pour une boucle tantque.
\end{itemize}
Certaines commandes Xcas sont compatibles avec Python, par exemple
{\tt range}, {\tt assert}, {\tt random}, etc.
Notez que~:
\begin{itemize}
\item on doit d\'eclarer explicitement les variables
 locales (avec {\tt local <nom-var>}). 
 Ainsi une faute de frappe dans un nom de
 variable est d\'etect\'ee et
 un avertissement est affich\'e.
\item les cha\^{\i}nes de caract\`eres sont d\'elimit\'ees par {\tt "} car 
dans {\tt Xcas} on r\'eserve {\tt '} pour quoter un argument c'est \`a dire 
pour ne pas \'evaluer un argument, par exemple :\\
{\tt "a"} d\'esigne la lettre {\tt a} (c'est une cha\^{\i}ne de 1 caract\`ere),
 et si {\tt a:=2+2} (ou en  Python {\tt a=2+2})
{\tt a} renvoie {\tt 4} alors que {\tt 'a'} d\'esigne la 
variable {\tt a} non \'evalu\'ee et donc {\tt 'a'} renvoie le nom {\tt a} de la 
variable {\tt a} (ce n'est pas une cha\^{\i}ne de 1 caract\`ere, c'est un 
identificateur).\\
On aura par exemple :\\
{\tt "a"+3} renvoie {\tt "a3"} mais\\
si {\tt a:=4} alors {\tt 'a'+3} renvoie {\tt 3+a} et {\tt a+3} renvoie {\tt 7}\\
{\tt type("a")} renvoie {\tt string} (cha\^{\i}ne de caract\`eres)\\
{\tt type(a)} renvoie {\tt integer} ({\tt a} contient un entier)\\
{\tt type('a')} renvoie {\tt identifier} ({\tt 'a'} est un nom de variable).
\item les commandes graphiques des librairies Python 
ne sont pas implent\'ees, il faut utiliser les commandes de Xcas
(par exemple \verb|plot|, \verb|plotlist|, \verb|histogram|, ...)
\end{itemize}

{\bf Exemple}~:
On veut faire un programme qui teste si un 
nombre est parfait : un entier naturel $n$ est parfait si il est \'egal \`a la 
somme de ses diviseurs (1 compris, $n$ non compris).

On \'ecrit la fonction {\tt Parfait} qui a comme argument un entier {\tt n}.\\
On d\'efinit les variables locales \`a la fonction~:
\begin{itemize}
\item {\tt s} qui recevra la somme des diviseurs de {\tt n}.
au d\'ebut {\tt s} est nul.
\item {\tt j} qui parcourt les diviseurs potentiels, 
\end{itemize}
Pour tous les entiers {\tt j} entre {\tt 1} et {\tt n-1} on teste si 
{\tt j} divise {\tt n} et pour cela on cherche le reste de la division
de {\tt n} par {\tt j}, c'est {\tt irem(n,j)} ou {\tt n\%j} 
qui renvoie ce reste.
Si le reste est nul, c'est que {\tt j} divise {\tt n} donc on ajoute
{\tt j} \`a {\tt s}.
Quand {\tt j} a parcouru tous les entiers jusque {\tt n-1} (i.e. quand la 
boucle {\tt pour} est termin\'ee), on teste si {\tt s} 
est \'egal \`a {\tt n}. Si il y a \'egalit\'e alors {\tt n} est parfait, sinon 
{\tt n} n'est pas parfait.

Une impl\'ementation en syntaxe Xcas en fran\c{c}ais :
\begin{giacprog}
fonction Parfait(n)
  local j,s;
  "Parfait(n) renvoie vrai si n est la somme de ses diviseurs";
  s:=0;
  pour j de 1 jusque n-1 faire
    si irem(n,j)==0 alors
      s:=s+j; // j divise n, on l'ajoute a la somme
    fsi;
  fpour;
  si s==n alors // on pourrait aussi recrire return s==n
    retourne vrai;
  sinon
    retourne faux;
  fsi;
ffonction:;  
\end{giacprog}
\giacinput{Parfait(6)}
L'indentation permet de visualiser facilement la forme du programme, ici on a 
3 instructions : 1 affectation, 1 boucle {\tt pour} qui contient une instruction
(1 test si) et 1 test si/sinon.
L'indentation sert aussi \`a contr\^oler qu'on n'a pas fait
de faute de syntaxe (non-fermeture d'une parenth\`ese par exemple).
En syntaxe compatible Python, le programme {\tt Parfait} 
pr\'ec\'edent s'\'ecrit :
\begin{giacprog}
def Parfait(n):
  local j,s
  '''Parfait(n) determine si l'entier n est la somme de ses diviseurs'''
  s=0
  for j in range(1,n):
    if n%j==0: 
      s=s+j # j divise n, on l'ajoute
  if s==n:
    return True
  else:
    return False 
\end{giacprog}
\giacinput{Parfait(24)}
En Python natif, il faut enlever la ligne \verb|local j,s|.


\section{Xcas et Javascript}
Javascript\index{Javascript} est le langage des navigateurs, il est donc
extr\^emement r\'epandu et peut \^etre utilis\'e
sans installation sur PC/Mac. De ce fait, un programme
\'ecrit en javascript pourra facilement 
\^etre int\'egr\'e dans une petite interface
utilisateur en HTML (voir l'exemple ci-dessous), 
et ex\'ecut\'e depuis n'importe
quel autre navigateur, ce qui peut \^etre assez 
motivant. \\
Du point de vue des types
de variables utilisables, on dispose entre autres
de nombres approch\'es,
de chaines de caract\`eres et de listes, il n'y a pas de type
particulier pour les entiers. Les structures de controle ont une
syntaxe proche du langage C, point-virgule en fin d'instruction,
d\'elimiteurs de blocs explicites \verb|{}|,  test en 
\verb|if () { ... } else { ... }| et boucle en
\verb|for(init;condition;incrementation){...}| 
ou \verb|while(condition){...}|, d\'eclaration de variable
par \verb|var| et retour de fonction par \verb|return|. \\
Si vous connaissez javascript, vous pouvez utiliser une syntaxe tr\`es
proche dans {\tt Xcas}. Exemple, syntaxe utilisable dans les
deux langages pour le calcul du $n$-i\`eme nombre de Fibonacci~:
\begin{giacprog}
function fibo(n){
  var u,v,w,j;
  u=1; v=1;
  if (n<2) return 1;
  for (j=2;j<=n;j++){
    w=u+v; u=v; v=w; // ou en Xcas (u,v)=(v,u+v);
  }
  return v;
}
\end{giacprog}
Pour avoir une interface HTML minimaliste pour cette fonction,
on cr\'ee un fichier nomm\'e disons \verb|fibo.html| (que l'on
consultera depuis un navigateur) contenant~:
\begin{verbatim}
<script>
function fibo(n){
  var u,v,w,j;
  u=1; v=1;
  if (n<2) return 1;
  for (j=2;j<=n;j++){
    w=u+v; u=v; v=w; 
  }
  return v;
}
</script>
Le 
<textarea cols="5" rows="1" id="input" 
onkeypress="if (event.keyCode!=13) return true; 
document.getElementById('output').value=fibo(eval(value)); 
return false;">5</textarea>
i&egrave;me nombre de Fibonacci est
<textarea rows="1" id="output"></textarea>
\end{verbatim}
On peut utiliser les commandes de {\tt Xcas} depuis Javascript, c'est exactement
ce que fait l'interface {\tt Xcas} pour Firefox.

\section{Xcas et Python}
Python\index{Python} est un langage assez populaire
dans les milieux scientifiques et est facile \`a installer.
Il poss\`ede un type sp\'ecifique pour les entiers. 
Sa principale diff\'erence par rapport aux autres langages est
que les structures de controle n'ont pas de d\'elimiteur explicite
de fin de bloc, c'est l'indentation qui joue ce role. L'obligation
d'indenter correctement a certes des vertus p\'edagogiques, mais 
pas l'absence de d\'elimiteur explicite de fin de bloc. Ceci rend aussi
l'\'echange de code source Python avec des applications orient\'ees
texte (copier/coller, mail, forums, traitement de texte) 
plus fragile\footnote{Ainsi, l'exercice
de sp\'ecialit\'e du sujet de bac S
2017 centres etrangers demande aux candidats d'interpr\'eter un algorithme
\'ecrit \`a la Python sans d\'elimiteurs de blocs explicites ... et
l'un des blocs est mal indent\'e, tr\`es probablement au cours
d'un passage par un logiciel de traitement de texte}, 
ou m\^eme la lecture difficile si le code est affich\'e sur 
plus qu'une page.
De plus, la d\'eclaration
de variables locales dans une fonction
est implicite, ce qui n'est pas tr\`es p\'edagogique.
D'autre part, la syntaxe de la boucle
for en Python utilise des objets plus abstraits (it\'erateurs)
ou qui peuvent \^etre inutiles (liste d'entiers en Python 2), elle
s'\'eloigne de celle de la grande majorit\'e des
autres langages, y compris la traduction en langage machine.
Ainsi l'exemple de Fibonacci donne
\begin{verbatim}
def fibo(n):
  u=1 
  v=1
  if n<2:
    return 1
  for j in range(2,n+1):
    w=u+v 
    u=v 
    v=w 
  return v
\end{verbatim}

\section{Comparaison rapide}
La principale diff\'erence entre les 3 langages, c'est que {\tt Xcas}
est un logiciel de calcul formel et permet 
de travailler avec des variables symboliques et des
expressions. Dans {\tt Xcas}, une variable globale 
peut ne pas avoir de valeur (son \'evaluation la renvoie),
ce n'est pas le cas en Javascript ou en Python (l'\'evaluation
d'une variable non initialis\'ee renvoie une erreur). De ce fait,
il ne faut pas oublier de d\'eclarer les variables locales
d'une fonction pour \'eviter des erreurs. En contrepartie pour
r\'ealiser des fonctions comme la dichotomie ou la recherche
d'une valeur approch\'ee d'int\'egrale par la m\'ethode des 
rectangles,
on peut passer une expression symbolique en param\`etre et
l'\'evaluer en un point, ce qui est conceptuellement plus 
simple que de passer une
fonction en argument \`a une autre fonction.
Avec {\tt Xcas}, on peut aussi faire du calcul symbolique \`a l'int\'erieur
d'une fonction, par exemple d\'eriver une expression, calculer
des valeurs exactes ou approch\'ee, et dans ce dernier cas travailler
avec un nombre arbitraire de d\'ecimales.

Des trois langages, Javascript est le plus rapide,
puis Python puis {\tt Xcas}.

\chapter{Les biais des langages interpr\'et\'es}

Les ordinateurs n'ex\'ecutent pas directement les instructions
donn\'ees dans un langage comme {\tt Xcas}, Javascript, Python, C, Pascal, etc.,
ils ex\'ecutent uniquement du code machine sp\'ecifique au micro-processeur
de l'ordinateur. Il y a deux fa\c{c}ons de traduire le langage en
code machine~: soit une fois pour toutes lors d'une \'etape
appel\'ee compilation, soit au moment de l'ex\'ecution de l'instruction
du langage par l'interpr\'eteur (qui est lui-m\^eme un 
programme \'ecrit dans un langage compil\'e), on parle alors de langage 
interpr\'et\'e (en toute rigueur, il existe une
troisi\`eme possibilit\'e un peu interm\'ediaire qui consiste \`a compiler
au moment o\`u on ex\'ecute l'instruction du langage).

Les langages interpr\'et\'es sont par nature plus faciles \`a 
mettre en oeuvre (pas de compilation) et de ce fait
rendent l'apprentissage plus simple. Mais la traduction au moment
de l'ex\'ecution a bien entendu un impact sur le temps d'ex\'ecution,
parce que les boucles sont traduites autant de fois
qu'elles sont ex\'ecut\'ees (des optimisations peuvent
y rem\'edier plus ou moins, il est d'ailleurs fort possible
que la syntaxe de la boucle \verb|for| en Python soit li\'ee
\`a des consid\'erations d'optimisation).
De plus, les langages interpr\'et\'es
utilisent des variables dont le type est d\'etermin\'e
au moment de l'ex\'ecution du code, ce qui a un impact aussi
bien pour la taille occup\'ee par la variable que pour l'ex\'ecution
d'une op\'eration qui doit commencer par d\'eterminer le type des
arguments pour agir en cons\'equence. Enfin,
lorsqu'on utilise un langage compil\'e, on a acc\`es
aux types de donn\'ees directement manipulables par le 
microprocesseur, dont la place occup\'ee en m\'emoire est optimale 
et le temps d'ex\'ecution tr\`es rapide,
par exemple on peut multiplier deux entiers dont le produit est
inf\'erieur \`a $2^{63}$ en moins d'un milliardi\`eme de seconde.

Bien entendu, on peut am\'eliorer le temps d'ex\'ecution
avec un langage interpr\'et\'e si certaines taches r\'ep\'etitives
sont cod\'ees dans une instruction du langage, par exemple
l'instruction effectuant le produit de deux matrices n'est pas 
programm\'e dans le langage interpr\'et\'e lui-m\^eme mais est compil\'e
une fois pour toutes dans le code ex\'ecutable de l'interpr\'eteur. 
Le programmeur qui souhaite avoir un code suffisamment rapide va
donc adopter un style de programmation qui favorisera l'utilisation
de commandes du langage effectuant en une seule instruction ce
qui n\'ecessiterait une ou plusieurs boucles imbriqu\'ees
si on le programmait uniquement avec les
instructions de base d'un langage compil\'e. 
C'est pour cette raison
que les programmeurs exp\'eriment\'es travaillant avec un 
langage interpr\'et\'e \'ecrivent souvent dans un style
``alg\'ebrique'' avec le moins possible de structures de controle explicites
et des types de donn\'ees souvent assez complexes.
Par exemple pour \'ecrire un produit scalaire de deux listes en {\tt Xcas},
on utilisera la commande \verb|dot|, si elle n'existait pas, on
pourrait \'ecrire \verb|sum(x[j]*y[j],j,0,size(x)-1)| pour \'eviter
de faire une boucle \verb|pour|, le chapitre statistiques \ref{chap:stats} 
contient quelques exemples d'optimisation de ce type. 
Pour des commandes plus compliqu\'ees,
on utilisera sans doute des commandes \verb|seq| imbriqu\'ees au lieu
de boucles.
Mais ce style pr\'esente un risque, celui de calculer
plusieurs fois la m\^eme quantit\'e~: une expression alg\'ebrique
n'a pas de variables locales pour stocker de r\'esultats 
interm\'ediaires. 
Il faut donc prendre garde au biais de ne
pas calculer des quantit\'es interm\'ediaires.
Ce n'est pas le seul biais, 
il faut \'egalement faire attention à l'utilisation
d'instructions faisant des boucles implicitement et
à l'utilisation de types de donn\'ees puissants qui risquent de masquer
la complexit\'e des op\'erations n\'ecessaires et pourraient \^etre
remplac\'es par des types plus simples, par exemple
utiliser un dictionnaire (ou annuaire) 
alors qu'un tableau ferait l'affaire. 
D'ailleurs d'un point de vue
p\'edagogique il est toujours bon de savoir ce qu'il y a derri\`ere une boite
noire lorsque c'est accessible au niveau de l'\'el\`eve ou de l'\'etudiant. 
De plus le style alg\'ebrique
est certes compact, mais il est souvent plus difficile à maintenir 
(aussi bien à relire qu'à corriger), 
et il peut aussi g\'en\'erer une occupation m\'emoire inutile~: par
exemple en simulation, g\'en\'erer une grosse matrice de nombre al\'eatoires
alors qu'une boucle agissant sur des lignes de cette matrice g\'en\'er\'ees
une par une et effac\'ees apr\`es usage est incomparablement
moins gourmand en m\'emoire.

Enfin, l'optimisation d'un code destin\'e à \^etre vraiment utilis\'e
n\'ecessite souvent la compilation des parties critiques, et l'optimisation
de ces parties critiques se fait souvent de mani\`ere diff\'erente et
parfois oppos\'ee aux habitudes acquises en optimisant du code interpr\'et\'e.
Illustrons cela plus en d\'etails
sur un exemple tr\`es utile en math\'ematique: le produit
scalaire de deux vecteurs et le produit d'une matrice
par un vecteur. Il s'agit d'une boucle \verb|pour|
que l'on code par
\begin{verbatim}
fonction ps(u,v)
 local r,j,n
 r:=0;
 pour j de 0 jusque n-1 faire
  r:=r+u[j]*v[j];
 fpour;
 return r;
ffonction
\end{verbatim}
On peut optimiser en utilisant l'instruction d'incr\'ementation
\verb|r += u[j]*v[j];| au lieu de \verb|r:=r+u[j]*v[j];|.

Traduit dans un langage compil\'e, 
ce code n'est pas loin d'\^etre optimal, 
par exemple en C++~:
\begin{verbatim}
double ps(const vector<double> & u,const vector<double> & v){
  size_t j,n=u.size();
  double r=0;
  for (j=0;j<n;j++){
    r += u[j]*v[j];
  }
  return r;
}
\end{verbatim}
Les variables \verb|r,j,n| sont stock\'ees dans des r\'egistres
du microprocesseur. Par it\'eration, 
il y a 2 additions d'entiers 64 bits 
(adresse de base des vecteurs et valeur de l'indice), 2 lectures
en m\'emoire de 8 octets (\verb|u[j]| et \verb|v[j]|),
puis une multiplication de flottants, une addition de flottant,
une incr\'ementation d'entier 64 bits (l'indice), une comparaison
entre 2 entiers 64 bits, un branchement. Ce qui prend le plus de
temps c'est la lecture en m\'emoire des double des
vecteurs \verb|u| et \verb|v|
et le branchement/test de fin de boucle.

En langage interpr\'et\'e, ce code sera beaucoup plus lent, car \`a chaque 
it\'eration, pour d\'eterminer la valeur de \verb|u[j]| et \verb|v[j]|, 
il faut \'evaluer la variable d'indice \verb|j| (lue dans l'annuaire
des variables affect\'ees), de m\^eme pour les variables \verb|u|
et \verb|v|, s'apercevoir que ce sont bien des tableaux, comparer \verb|j|
\`a la taille de \verb|u| et de \verb|v| (erreur si l'indice est trop
grand), extraire la $j$-i\`eme case
du tableau. Ensuite on fait le produit, ce qui n\'ecessite de tester
le type des variables, on ajoute le r\'esultat \`a \verb|r| ce qui
n\'ecessite \`a nouveau de tester le type des arguments de \verb|+=|. 
Puis on incr\'emente \verb|j| de 1 et on compare \`a \verb|n| (qu'il
faut \'evaluer).
Pour diminuer les op\'erations de gestion de la boucle, 
certains langages interpr\'et\'es
ont une instruction de boucle sp\'ecifique pour it\'erer sur
les \'el\'ements d'une liste, par exemple si on veut afficher les
\'el\'ements d'une liste au lieu de faire
\begin{verbatim}
fonction aff(u)
 local j,n
 pour j de 0 jusque n-1 faire
  afficher(u[j]);
 fpour;
ffonction;
\end{verbatim}
on \'ecrira
\begin{verbatim}
fonction aff(u)
 local j;
 pour j in u faire
  afficher(j);
 fpour;
ffonction;
\end{verbatim}
Cette boucle est impl\'ement\'ee en interne par
une variable de longueur de la liste \verb|n|, une autre 
d'indice, disons \verb|k|,
et \verb|j| est \'evalu\'e par calcul de \verb|u[k]|, mais
les op\'erations de gestion de la boucle 
sont pr\'e-compil\'ees et donc plus rapides.
Dans ce type de boucle, le code est plus compact et ne pose aucun
probl\`eme de maintenance.
Par contre, pour le produit scalaire,
faire la m\^eme chose n\'ecessite d'introduire des objets plus
complexes~: on peut imaginer g\'en\'erer la liste des paires
\verb|u[j],v[j]|
puis it\'erer sur cette liste. Mais si on ne veut pas cr\'eer inutilement
en m\'emoire une liste de paires, cette liste doit \^etre g\'en\'er\'ee
de mani\`ere virtuelle (par exemple au moyen d'une paire de pointeurs
sur les tableaux \verb|u| et \verb|v|)
et il faut disposer d'une commande capable
de prendre en argument une liste virtuelle. Par exemple en Python 
on pourrait \'ecrire \verb|sum(i*j for i,j in zip(u,v))|. Un m\'ecanisme
de cr\'eation de liste virtuelle peut bien entendu avoir un int\'er\^et
intrins\`eque, mais il faut avoir conscience que les objets que
l'on manipule sont plus complexes que les listes (qui sont d\'ej\`a
des objets non triviaux), et que l'utilisation de cet objet dans l'exemple du
produit scalaire pour optimiser une boucle est un art\'efact
de langage interpr\'et\'e, et qu'il sera difficile d'optimiser plus avec
ce style de programmation. Il sera d'ailleurs plus facile d'optimiser
en langage compil\'e sans utiliser ce type d'objets.

Ainsi, il est possible d'optimiser la boucle du produit scalaire,
on peut pour $n$ grand regrouper plusieurs it\'erations,
et gagner du temps sur les parties test/branchement, par exemple 2 par 2
\begin{verbatim}
double ps(const vector<double> & u,const vector<double> & v){
  size_t j,n=u.size();
  double r=0;
  n--;
  for (j=0;j<n;j+=2){
    r += u[j]*v[j]+u[j+1]*v[j+1];
  }
  n++;
  for (;j<n;j++){
    r += u[j]*v[j];
  }
  return r;
}
\end{verbatim}

Et si on effectue le produit d'une matrice $M$ par un vecteur $v$, on peut
optimiser le temps d'ex\'ecution en mutualisant la lecture des coefficients
de $v$, on fait plusieurs produits scalaires avec $v$ simultan\'ement.
\begin{verbatim}
double ps(const vector<double> & u1,
  const vector<double> & u2,const vector<double> & v){
  size_t j,n=u1.size();
  double r1=0,r2=0;
  n--;
  for (j=0;j<n;j+=2){
    double vj=v[j],vj1=v[j+1];
    r1 += u1[j]*vj+u1[j+1]*vj1;
    r2 += u2[j]*vj+u2[j+1]*vj1;
  }
  n++;
  for (;j<n;j++){
    r1 += u1[j]*v[j];
    r2 += u1[j]*v[j];
  }
  return r;
}
\end{verbatim}
Ici en faisant 2 produits scalaires simultan\'ement, 
on fait 6 lectures en m\'emoire au lieu de 8 pour 2 it\'erations.

Il nous parait donc essentiel pour un scientifique d'apprendre aussi
un langage pas trop \'eloign\'e de la machine, ou au moins
d'\^etre capable de coder avec des objets de base.
\end{giacjshere}
\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





%% \ifhevea
%% \@print{<script type="text/x-mathjax-config">
%%   MathJax.Hub.Config({
%%     extensions: ["tex2jax.js"],
%%     jax: ["input/TeX","output/SVG","output/CommonHTML"],
%%     tex2jax: {inlineMath: [["\\(","\\)"]]},
%%     TeX: { equationNumbers: { autoNumber: "AMS" } },
%%   });
%% </script>
%% <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js"></script>
%% }
%% \fi


\begin{giacprog}
fonction Estaligne1(cA,cB,cC)
 local xA,yA,xB,yB,xC,yC;
si (cC-cA)==0 et (cB-cA)==0 alors retourne 2 fsi;
si (cC-cB)==0 alors retourne 1 fsi;
cB-cA)[0]
si (cC-cA)[0]==0 alors 
  si  (cB-cA)[0]==0 alors retourne 1;
  sinon retourne 0;
  fsi;
fsi;
si (cB-cA)[1]/(cB-cA)[0]==(cC-cA)[1]/(cC-cA)[0] alors 
  retourne 1 
fsi;
retourne 0;
ffonction:;
\end{giacprog}
{\bf Solution analytique}
\begin{itemize}
\item Si $a_1!=0$ on a 
$$x=\frac{-c_1-b_1y}{a_1}, \quad a_2\frac{-c_1-b_1y}{a_1}+b_2y+c_2=0$$
on d\'eveloppe~:
$$-a_2c_1-a_2b_1y+b_2a_1y+c_2a_1=0$$
Donc si $a_1b_2-a_2b_1!=0$,
\begin{eqnarray}
y&=&\frac{-a_1c_2+a_2c_1}{a_1b_2-a_2b_1}\\
x&=& -\frac{c_1+b_1y}{a_1}=-\frac1{a_1}\frac{c_1a_1b_2-c_1a_2b_1-b_1a_1c_2+b_1a_2c_1}{a_1b_2-a_2b_1}\\
x&=&\frac{-c_1b_2+b_1c_2}{a_1b_2-a_2b_1}
\end{eqnarray}
Finalement si $a_1b_2-a_2b_1!=0$ la solution est :
$$ x=\frac{-b_2c_1+c_2b_1}{a_1b_2-a_2b_1},
\quad y=\frac{-a_1c_2+a_2c_1}{b_2a_1-a_2b_1}$$
On obtient le m\^eme r\'esultat en \'echangeant $a_1,b_1$ et $a_2,b_2$.\\
On obtient le m\^eme r\'esultat en \'echangeant $x,a_1$ et $y,b_1$ ou
en \'echangeant $x,a_2$ et $y,b_2$.
\item
Si $a_1b_2==a_2b_1$\\
Si $a_1!=0$ alors $a_2!=0$ (car sinon on aurait $b_2=0$ ce que l'on a exclu).\\
Donc si il y a une solution, on a :
$$a_1x+b_1y+c_1=0, \quad a_2a_1x+b_2a_1y+c_2a_1=0 $$
$$a_1x+b_1y+c_1=0, \quad a_2a_1x+a_2b_1y+c_2a_1=a_2(a_1x+b_1y)+c_2a_1=0 $$
donc $-a_2c_1+c_2a_1=0$\\
Finalement si $a_1b_2==a_2b_1$ et $a_2c_1!=c_2a_1$ il n'y a pas de solution,\\
si $a_1b_2==a_2b_1$ et $a_2c_1==c_2a_1$ et $a_1!=0$,les solutions sont :\\
$x:=\frac{-c_1-b_1y}{a_1},y$. \\
On obtient la m\^eme chose en \'echangeant $x,a_1$ et $y,b_1$.
\end{itemize}
On tape :
\begin{giacprog}
fonction Solution(Eq1,Eq2,Var1,Var2)
 local a1,b1,c1,a2,b2,c2,d;
 Eq1:=normal(gauche(Eq1)-droit(Eq1));
 si degree(Eq1,x)>1 et degree(Eq1,y)>1 alors 
   retourne "pas de degr\'e 1"; 
 fsi;
 Eq2:=normal(gauche(Eq2)-droit(Eq2));
 si degree(Eq2,x)>1 et degree(Eq2,y)>1 alors 
   retourne "pas de degr\'e 1"; 
 fsi;
 a1:=coeff(Eq1,x,1);
 a2:=coeff(Eq2,x,1);
 b1:=coeff(Eq1,y,1);
 b2:=coeff(Eq2,y,1);
 si [a1,b1]==[0,0] ou [a2,b2]==[0,0] alors 
   retourne "Eq1 ou Eq2 est nulle"; 
 fsi;
 c1:=subst(Eq1,[x,y],[0,0]);
 c2:=subst(Eq2,[x,y],[0,0]);
 si normal(a1*b2-a2*b1)!=0 alors 
   retourne [normal((-b2*c1+b1*c2)/(a1*b2-a2*b1)),
             normal((a2*c1-a1*c2)/(a1*b2-a2*b1))];
 fsi ; 
 si a1!=0 et a2!=0 alors 
   si c1*a2-c2*a1==0 alors 
     retourne [normal(-c1/a1),y]; 
   sinon 
     retourne []; 
   fsi; 
 fsi;   
 si b1!=0 et b2!=0 alors 
   si c1*b2-c2*b1==0 alors 
     retourne [x,normal(-c1/b1)]; 
   sinon 
     retourne [];
   fsi;
 fsi;
ffonction:;
\end{giacprog}

\giacinput{Solution(x+y=3,2x-y=9,x,y)}\\
\giacinput{Solution(4x-2y+9=0,2x-y=3,x,y)}\\
\giacinput{d1:=droite(x+y=3);d2:=droite(2x-y=9);d3:=droite(-4x+2y=3)}

Voici le programme g\'en\'eral.\\
On tape (on suppose ici que les variables sont {\tt x} et {\tt y}) :
\begin{giacprog}
fonction Soleq(eq1,eq2)
local a1,a2,b1,b2,c1,c2,k;
eq1:=normal(gauche(eq1)-droit(eq1));
si degree(eq1,x) >1 et degree(eq1,y) >1 alors 
    retourne "pas de degr\'e 1"; 
fsi;
eq2:=normal(gauche(eq2)-droit(eq2));
si degree(eq2,x) >1 et degree(eq2,y) >1 alors 
   retourne "pas de degr\'e 1"; 
fsi; 
a1:=normal(coeff(eq1,x,1));
b1:=normal(coeff(eq1,y,1));
c1:=normal(subst(eq1,[x,y],[0,0]));
a2:=normal(coeff(eq2,x,1));
b2:=normal(coeff(eq2,y,1));
c2:=normal(subst(eq2,[x,y],[0,0]));
si normal(a1*b2-a2*b1)!=0 alors 
  retourne [normal((-b2*c1+b1*c2)/(a1*b2-a2*b1)),
            normal((a2*c1-a1*c2)/(a1*b2-a2*b1))];
fsi ;   
si normal(a1*b2)!=0 alors 
  si a1*c2==a2*c1 alors 
    retourne [normal((-b1*y-c1)/a1),y];
  sinon 
    retourne [];
  fsi;
fsi;
si a1==0 et b1==0 et a2==0 et b2==0 alors 
  si c1!=0 ou c2!=0 alors 
    retourne [];       
  sinon  
    retourne [x,y] 
  fsi;
fsi; 
si a1==0 et b1==0 et c1!=0  alors 
  retourne [];
fsi;
si a2==0 et b2==0 et c2!=0  alors 
  retourne [];
fsi; 
si a1==0 et b1==0 et a2!=0 alors 
  retourne [normal((-b2*y-c2)/a2),y];
fsi;
si a2==0 et b2==0 et a1!=0 alors 
  retourne [normal((-b1*y-c1)/a1),y];
fsi;
si a1==0 et b1==0 et b2!=0 alors 
  retourne [x,normal((-a2*x-c2)/b2)];
fsi;
si a2==0 et b2==0 et b1!=0 alors 
  retourne [x,normal((-a1*x-c1)/b1),y];
fsi;
si a1!=0 et a2!=0 alors 
  si c1*a2==c2*a1 alors 
    retourne [normal(-c1/a1),y]; 
  sinon 
    retourne []; 
  fsi;
fsi;
si b1!=0 et b2!=0 alors 
  si c1*b2==c2*b1 alors 
    retourne [x,normal(-c1/b1)]; 
  sinon 
    retourne [];
   fsi;
fsi;
ffonction:;
\end{giacprog}
\giacinput{Soleq(x+y=3,2x-y=9)}\\
\giacinput{Soleq(4x-2y+9=0,2x-y=3)}\\
\giacinputbig{d1:=droite(x+y=3);d2:=droite(2x-y=9);d3:=droite(-4x+2y=-5)}



{\bf Instructions en fan\c{c}ais}\\
\begin{center}
\begin{tabular}{|ll|}
\hline
\multicolumn{2}{|c|}
\hline\hline
<<<<<<< variant A
affectation & \verb|a:=2;| (\verb|a| prend la valeur 2) et \verb|purge(a);|
(\verb|a| redevient formelle)\\
>>>>>>> variant B
affectation& \verb|a:=2;|(\verb|a| prend la valeur 2) et \verb[purge(a);|(\verb|a| redevient formelle)\\
======= end
entr\'ee expression& \verb|saisir("a=",a);|\\
entr\'ee chaine& \verb|saisir_chaine("a=",a);|\\
sortie& \verb|afficher("a=",a);|\\
valeur retourn\'ee& \verb@retourne a;@\\
arr\^et de la boucle& \verb@break@;\\
alternative& \verb@si <condition> alors <inst> fsi;@ \\
           & \verb@si <condition> alors <inst1> sinon <inst2> fsi;@ \\
boucle pour& \verb@pour j de a jusque b faire <inst> fpour;@\\
           & \verb@pour j de a jusque b pas p faire <inst> fpour;@\\
boucle r\'ep\'eter& \verb@repeter <inst> jusqua <condition>;@\\
boucle tantque& \verb@tantque <condition> faire <inst> ftantque;@\\
boucle faire& \verb@faire<inst1>si(<condition>)break;<inst2>ffaire;@\\
debug&lance le debugueur pour une ex\'ecution au pas \`a pas de l'argument\\
\hline 
\hline
\multicolumn{2}{|c|}{\bf Signification des signes de ponctuation}\\
\hline\hline
\verb|.|& s\'epare la partie enti\`ere de la partie d\'ecimale\\
\verb|,|& s\'epare les \'el\'ements d'une liste ou d'une s\'equence \\
\verb|;|& termine chaque instruction d'un programme \\
\verb|:;|&  termine les instructions lorsqu'on ne veut pas l'affichage de la r\'eponse\\
\verb|!| & $n!$ est la factorielle de $n\in  \mathbb{N}$ et $!(b)$ est l'inverse logique du bool\'een $b$\\
\hline
\end{tabular}
\begin{tabular}{|ll|ll|}
\hline
\multicolumn{4}{|c|}{\bf Op\'erateurs}\\
\hline\hline
\verb@+@& addition&\verb@-@& soustraction \\
\verb@*@& mutiplication& \verb@/@& division\\
\verb@^ @& puissance& \verb@a mod p@& a modulo p\\
\verb@==@& teste l'\'egalit\'e&
\verb@!=@& teste la diff\'erence \\
\verb@<@& teste la stricte inf\'eriorit\'e &
\verb@<=@& teste l'inf\'eriorit\'e ou l'\'egalit\'e\\
\verb@>@& teste la stricte sup\'eriorit\'e &
\verb@>=@&  teste la sup\'eriorit\'e ou l'\'egalit\'e\\
\verb@||, ou@& op\'erateur bool\'een infix\'e ou&
\verb@&&, et@& op\'erateur bool\'een infix\'e et\\
\verb@non@& inverse logique de l'argument &
\verb@!(..)@& inverse logique de l'argument\\
\verb@vrai@& est le bool\'een vrai ou true ou 1&
\verb@faux@& est le bool\'een faux ou false ou 0\\
\hline
\verb|=|& permet de d\'efinir une \'equation&
\verb|:=|& affectation ($a:=2$)\\
\hline
\end{tabular}
\end{center}
\section{Exemples d'utilisation}
\subsection{Programmer un jeu}
On consid\`ere le jeu suivant :
\begin{itemize}
\item Le joueur tire au hasard un nombre entre 1 et 10. Ce nombre est son gain,
il peut le garder et la partie est finie.
\item Le joueur peut choisir d'abandonner ce gain et de recommencer. Il lui est
permis de tirer ainsi au plus 5 fois et son gain est le r\'esultat du dernier 
tirage lorsqu'il a abandonn\'e les gains des 4 tirages pr\'ec\'edents.
\end{itemize}
\begin{enumerate}
\item \'Ecrire un programme qui r\'ealise ce jeu, 
\item Le joueur choisit 4 nombres $n_1,n_2,n_3,n_4$ compris entre 1 et 10 et  
choisit comme strat\'egie de garder son gain du $j$i\`eme essai si celui-ci est
sup\'erieur ou \'egal \`a $n_j$ sinon il recommence (si $n_1$=9, $n_2$=8, 
$n_3$=6, $n_4$=5 avec le tirage 2,7,8, le gain est 8 mais avec le tirage 
8,7,5,4,2 le gain est 2).\\
Il joue 100 parties selon cette strat\'egie avec les m\^emes $n_j$.\\
\'Ecrire un programme donnant la moyenne des gains obtenus. A vous de jouer !.
\end{enumerate}
\begin{verbatim}
jeu1():={
 //repondre o pour dire oui
 local j,g,rep;
 pour j de 1 jusque 4 faire
   g:=alea(10)+1;afficher(g);
   lis_phrase(rep);
   si rep=="o" alors retourne g; fsi;
 fpour;
 retourne alea(10)+1;
}:;
\end{verbatim}
{\tt jeu2} a comme param\`etre  {\tt L} qui est la s\'equence $n_1,n_2,n_3,n_4$
puis $LL$ est la suite $n_1,n_2,n_3,n_4,0$ de fa\c{c}on \`a ce que $LL[j]$ 
soit d\'efinie pour $j=0..4$ ($LL[0]=n_1$).\\
{\tt jeu102} est la moyenne des gains de 100 parties faites avec {\tt jeu2}.
\begin{verbatim}
jeu2(L):={
 local j,g,LL;
 LL:=append(L,0);
 pour j de 0 jusque 4 faire
   g:=alea(10)+1;afficher(g);
   si g>=LL[j] alors break fsi;
 fpour;
 retourne g;
}:;
jeu102(L):={
 local g,j;
 g:=0;
 pour j de 1 jusque 100 faire
   g:=g+jeu2(L);
 fpour;
 retourne evalf(g/100);
}:;
\end{verbatim}
\subsection{Des triangles \'equilat\'eraux emboi\'es}
\`A partir d'un triangle \'equilat\'eral direct $ABC$ on construit les points 
$A_1,B_1,C_1$ v\'erifiant :
$\displaystyle \overrightarrow{AA_1}=\frac{4}{3}\overrightarrow{AB}$, 
$\displaystyle \overrightarrow{BB_1}=\frac{4}{3}\overrightarrow{BC}$,
$\displaystyle \overrightarrow{CC_1}=\frac{4}{3}\overrightarrow{CA}$.
Interpr\'eter $A_1$ comme le barycentre de $(A,a)$ et $(B,b)$ et
montrer que le triangle $A_1B_1C_1$ est \'equilat\'eral.\\
On recommence la m\^eme construction \`a partir de $A_1B_1C_1$.
\'Ecrire la proc\'edure r\'ecursive qui r\'ealise le dessin des $n$ triangles
obtenus par cette construction.\\
% (en tout $n+1$ triangles $ABC$ + les autres).\\
On a :
$\displaystyle \overrightarrow{AA_1}=\frac{4}{3}\overrightarrow{AB}-\frac{1}{3}\overrightarrow{AA}$.
Donc $A_1$ est le barycentre de $(A,-1)$ et $(B,4)$. \\
$B_1$ est le barycentre de $(B,-1)$ et $(C,4)$. $C_1$ est le barycentre de $(C,-1)$ et $(A,4)$.\\
La rotation $r$ de centre $O$, le centre de $ABC$, et d'angle 
$\displaystyle \frac{2\pi}{3}$ 
transforme $A$ en $B$, $B$ en $C$ et $C$ en $A$ donc $r$ transforme le 
barycentre de $(A,-1)$ et $(B,4)$ en le barycentre de $(B,-1)$ et $(C,4)$ c'est \`a dire transforme $A_1$ en $B_1$ et  $r$ transforme le 
barycentre de $(B,-1)$ et $(C,4)$ en le barycentre de $(C,-1)$ et $(A,4)$ i.e. transforme $B_1$ en $C_1$.
Donc le triangle $A_1B_1C_1$ est \'equilat\'eral.\\
\ \\
\begin{minipage}[h]{8cm}
On tape dans l'\'editeur de programmes :
\begin{verbatim}
triangles(A,B,n):={
  local L,C;
  L:=triangle_equilateral(A,B,C);
  si n>0 alors 
    A:=barycentre([A,B],[-1,4]);
    B:=barycentre([B,C],[-1,4]);
    L:=L,triangles(A,B,n-1);
  fsi;
  return L;
}:;
\end{verbatim}
\end{minipage}
%\hspace{0.1cm} 
\begin{minipage}[h]{5cm}
On compile ($F9$). Dans une\\ 
ligne de commandes,
on tape  :\\
{\tt triangles(0,1,5)}\\
On obtient :\\

%\includegraphics[width=4.5cm]{triangles1}
\end{minipage}
\subsection{Les nombres amiables}
\'Ecrire un programme qui pour un entier $n$, donne la suite des couples 
amiables $(a,b)$ ($a\leq b\leq n$).
Deux nombres $a$ et $b$ sont {\bf amiables}, si l'un est \'egal \`a la 
somme des diviseurs propres de l'autre (sauf lui-m\^eme) et inversement.

On utilise l'instruction {\tt idivis(a)} qui renvoie la liste des diviseurs 
de l'entier {\tt a} et l'instruction {\tt sum(L)} qui renvoie la somme de la
liste {\tt L}. On tape (on rajoute le test {\tt si j<=a} pour avoir les couples 
amiables $(j,a)$ avec $j\leq a\leq n$).

\begin{verbatim}
amiable(n):={
  local j,a,b,L:=NULL;
  pour j de 2 jusque n faire
    a:=sum(idivis(j))-j;
    b:=sum(idivis(a))-a;
    si b==j et j<=a alors L:=L,[j,a]; fsi;
  fpour;
  retourne L;
}:;
\end{verbatim}
{\tt amiable(500)} renvoie {\tt [6,6],[28,28],[220,284],[496,496]}\\
Les nombres parfaits $a$ sont les nombres amiables $(a,a)$.
_______________________________________________________________________

\begin{giacprog}
fonction Estparallele(d1,d2)
local a1,a2,b1,b2,x,y,gd1,gd2,d;
purge(x);purge(y);
gd1(x,y):=gauche(d1);
gd2(x,y):=gauche(d2);
a1:=derive(gd1(x,y),x);
b1:=derive(gd1(x,y),y);
a2:=derive(gd2(x,y),x);
b2:=derive(gd2(x,y),y);
d:=a2*b1-b2*a1;
si d==0 alors retourne 1;
sinon retourne 0;
fsi;
ffonction:;
\end{giacprog}
% a supprimer ? car faire cet exo avec le chgt de reperes
%%B Trop dur en seconde et meme probablement en TS
{\bf Exercices}\\
Faire les programmes :
\begin{enumerate}
\item d'un triangle \'equilat\'eral direct $ABC$ connaissant $A$ et $B$,\\ 
\item d'un carr\'e  direct $ABCD$ connaissant $A$ et $B$.\\
\end{enumerate}
{\bf Solution}
\begin{enumerate}
\item Soit un triangle \'equilat\'eral direct $ABC$
Cherchons tout d'abord les coordonn\'ees du point $C$ lorsque $A:=[0,0]$ et 
$B:=[xB,yB]$.\\
Soit $\beta$ (resp $\gamma$) l'angle que fait $AB$ (resp $AC$) avec l'axe des 
$x$. On a $\tan(\beta)=yB/xB$ et $\gamma=\beta+\pi/3$ et donc :\\
$ \tan(\gamma)=\tan(\beta+\pi/3)=\frac{yB+\sqrt 3 xB}{xB-\sqrt 3 yB}$ 
\'Equation de la droite $AB$ : $y=yB*x/xB$ \\
\'Equation de la droite $AC$ : $y=\frac{(yB+\sqrt 3 xB)*x}{xB-\sqrt 3 yB}$ \\
Donc $yC=\frac{(yB+\sqrt 3 xB)*xC}{xB-\sqrt 3 yB}$.\\
On a de plus $AC^2=AB^2=xB^2+yB^2=xC^2+yC^2$.\\
Donc :\\
$xC^2+yC^2=xB^2+yB^2=xC^2+xC^2\frac{(yB+\sqrt 3 xB)^2}{(xB-\sqrt 3 yB)^2}=$\\
$(xB^2+yB^2)*(xB-\sqrt 3 yB)^2=xC^2((xB^2+3yB^2+yB^2+3xB^2)=4*xC^2*(xB^2+yB^2)$\\
Donc :\\
$xC^2=(xB-\sqrt 3 yB)^2/4$ et $yC^2=(yB+\sqrt 3 xB)^2/4$\\
On veut que le triangle $ABC$ soit direct donc $xC>0$ si $xB>\sqrt 3 yB$
$xC=(xB-\sqrt 3 yB)/2$ et $yC=(yB+\sqrt 3 xB)/2$\\

Si le point $A:=[xA,yA]$ il suffit de faire une translation du rep\`ere et on 
obtient :\\
$xC=xA+(xB-xA-\sqrt 3*(yB-YA))/2$ et $yC=YA+(yB-YA+\sqrt 3 *(xB-XA))/2$
Apr\`es simplification, on obtient :\\
$C=[(-yB*sqrt(3)+yA*sqrt(3)+xB+xA)/2,(yB+yA+xB*sqrt(3)-xA*sqrt(3))/2]$
\begin{giacprog}
fonction Trianglequi(A,B)
local xA,yA,xB,yB,C;
xA:=A[0];
yA:=A[1];
xB:=B[0];
yB:=B[1];
C:=[(-yB*sqrt(3)+yA*sqrt(3)+xB+xA)/2,(yB+yA+xB*sqrt(3)-xA*sqrt(3))/2];
//retourne Triangle(A,B,C);
retourne segment(A,point(B)),segment(B,point(C)),segment(C,point(A));
ffonction:;
\end{giacprog}
\item Soit un carr\'e direct $ABCD$
Cherchons tout d'abord les coordonn\'ees des points $C$ et $D$
lorsque $A:=[0,0]$ et $B:=[xB,yB]$.\\
On a :\\
$xC=xB-yB$ et $yC=xB+yB$\\
$xD=-yB$ et $yD=xB$\\
Si le point $A:=[xA,yA]$ il suffit de faire une translation du rep\`ere et on 
obtient :\\
$xC=xA+xB-xA-(yB-yA)=xB-yB+yA$ et $yC=yA+yB-yA+xB-xA=xB+yB-xA$\\
$xD=xA-yB+yA$ et $yD=yA+xB-xA$\\
\begin{giacprog}
fonction Carre(A,B)
local xA,yA,xB,yB,C,D;
C:=[xB-yB+yA,yB+xB-xA];
D:=[-yB+yA+xA,yA+xB-xA];
retourne segment(A,B-A),segment(B,C-B),segment(C,D-C),segment(D,A-D);
ffonction:;
\end{giacprog}
\end{enumerate}

Extrait du programme de seconde (cf mathprog2nde ds casdoc)
Les d\'efinitions formelles d’une fonction croissante, d’une fonction 
d\'ecroissante, sont progressivement d\'egag\'ees. Leur maîtrise est un objectif
 de fin d’ann\'ee.\\
 M\^eme si les logiciels traceurs de courbes permettent d’obtenir rapidement
la repr\'esentation graphique d’une fonction d\'efinie par une formule alg\'ebrique,
il est int\'eressant, notamment pour les fonctions d\'efinies par morceaux, de
faire \'ecrire aux \'el\`eves un algorithme de trac\'e de courbe.
• Mettre un probl\`eme en \'equation.
• R\'esoudre une \'equation se ramenant au premier degr\'e.
Encadrer une racine d’une,\'equation grâce à un algorithme de dichotomie.
• R\'esoudre graphiquement et alg\'ebriquement un syst\`eme de deux \'equations du 
premier degr\'e à deux inconnues.
• Rep\'erer un point donn\'e du plan, placer un point connaissant ses coordonn\'ees.
• Calculer la distance de deux points connaissant leurs coordonn\'ees.
• Calculer les coordonn\'ees du milieu d’un segment.
Configurations du plan Triangles, quadrilat\`eres, cercles. 
Pour r\'esoudre des probl\`emes :
• Utiliser les propri\'et\'es des triangles, des quadrilat\`eres, des cercles.
• Utiliser les propri\'et\'es des sym\'etries axiale ou centrale.
Tangente à un cercle. 
• Construire la tangente à un cercle en l’un de ses points.
Les activit\'es des \'el\`eves prennent appui sur les propri\'et\'es \'etudi\'ees au coll\`ege 
et peuvent s’enrichir des apports de la g\'eom\'etrie rep\'er\'ee.
 Le cadre de la g\'eom\'etrie rep\'er\'ee offre la possibilit\'e de traduire num\'erique-
ment des propri\'et\'es g\'eom\'etriques et permet de r\'esoudre certains probl\`emes
par la mise en œuvre d’algorithmes simples.
Tracer une droite dans le plan rep\'er\'e.
Droite comme courbe
• Interpr\'eter graphiquement le repr\'esentative d’une fonction affine.
- coefficient directeur d’une droite.
Droites
\'Equations de droites.
Droites parall\`eles, s\'e-
cantes.
• Caract\'eriser analytiquement une droite.
• \'Etablir que trois points sont align\'es, non align\'es.
• Reconnaître que deux droites sont parall\`eles, s\'ecantes.
• D\'eterminer les coordonn\'ees du point d’intersection de deux droites s\'ecantes.
• Connaître les coordonn\'ees d’un vecteur (xB-xA,yB-yA) du vecteur AB
• Calculer les coordonn\'ees de la somme de deux vecteurs dans un rep\`ere.
• Construire g\'eom\'etriquement  la somme de deux vecteurs.
• Caract\'eriser alignement et parall\'elisme par la colin\'earit\'e 

Notion d’\'echantillon.
Un \'echantillon de taille est constitu\'e des r\'esultats de r\'ep\'etitions ind\'epen-
dantes de la m\^eme exp\'erience.
R\'ealisation d’une simulation.
À l’occasion de la mise en place d’une simulation, on peut :
• utiliser les fonctions logiques d’un tableur ou d’une calculatrice, mettre en place des instructions conditionnelles dans un algorithme.
L’objectif est d’amener les \'el\`eves à un questionnement lors des 
activit\'es sui-vantes :
• l’estimation d’une proportion inconnue à partir d’un \'echantillon ;
• la prise de d\'ecision à partir d’un \'echantillon.
CONTENUS
Variables et instructions \'el\'ementaires
CAPACIT\'ES ATTENDUES• choisir ou d\'eterminer le type d’une
variable (entier, flottant ou chaîne de caract\`eres) ;
• concevoir et \'ecrire des affectations
à des variables ;
• \'ecrire une formule permettant un
calcul combinant des variables. 
COMMENTAIRES
On commence par consolider les notions de variables, de boucles et 
d’instructions conditionnelles introduites au cycle 4 en compl\'etant la 
programmation par blocs par l’utilisation d’un langage de programmation textuel.

CONTENUS
Boucle et it\'erateur,instruction conditionnelle
CAPACIT\'ES ATTENDUES
• programmer une instruction conditionnelle ;
• programmer une boucle born\'ee ;
• programmer une boucle non born\'ee.
COMMENTAIRES
On formalise les notions de boucle born\'ee (for) et de boucle non born\'ee (while) 
et on introduit la notion nouvelle de fonction dans un langage de programmation.

CONTENUS Notion de fonction
CAPACIT\'ES ATTENDUES
• programmer des fonctions simples, ayant un petit nombre d’arguments.
COMMENTAIRES
Il est int\'eressant de confronter les fonctions dans un langage de programmation
avec les fonctions d’un tableur.


\begin{giaconload}
fonction moyenneretour(N,n) // N experiences, marche de n
  local k,pos,r;
  pos:=seq(0,N); // N marcheurs a l'origine
  r:=0;
  pour k de 1 jusque n faire
    pos:=pos+(2*randvector(N,2).-1); // 2*0-1=-1 ou 2*1-1=1
    r:=r+count_eq(0,pos); // on ajoute le nombre de 0 (passage origine)
  fpour;
  retourne r/N;
ffonction:;
\end{giaconload}
\giacinput{seq(point(n,moyenneretour(1000,n)),n,1,200)}
\item {\tt Xcas} admet aussi les commandes du langage {\tt Python} sur les 
listes.\\
On affecte une liste \`a une variable <nom-var> (par exemple {\tt L}
Les commandes sont de la forme <nom-var>.<nom-de-commande>() cela a pour effet
de modifier selon la commande <nom-de-commande>la liste contenue dans 
<nom-var>.\\
On a :\\
\begin{itemize}
\item {\tt L.append} .\\
On tape :\\
{\tt L=[1,2,3,4]}\\
On tape :\\
{\tt L.append(5)}\\
On obtient  la nouvelle valeur de {\tt L}:\\
{\tt [1,2,3,4,5]}\\
{\tt L.append(5)} est \'equivalent \`a {\tt L:=append(L,5)}
\item {\tt L.prepend} \\
On tape :\\
{\tt L=[1,2,3,4]}\\
On tape :\\
{\tt L.prepend(0)}\\
On obtient  la nouvelle valeur de {\tt L}:\\
{\tt [0,1,2,3,4]}\\
{\tt L.prepend(0)} est \'equivalent \`a {\tt L:=preppend(L,0)}
\item {\tt L.rotate}\\ 
On tape :\\
{\tt L=[1,2,3,4]}\\
On tape :\\
{\tt L.rotate()}\\
On obtient la nouvelle valeur de {\tt L} :\\
{\tt [4,1,2,3]}\\
{\tt L.rotate()}  est \'equivalent \`a {\tt L:=rotate(L)}
\item {\tt L.shift} \\
On tape :\\
{\tt L=[1,2,3,4]}\\
On tape :\\
{\tt L.shift()}
On obtient la nouvelle valeur de {\tt L} :\\
{\tt [0,1,2,3]}\\
{\tt L.shift()} est \'equivalent \`a {\tt L:=shift(L)}\\
On tape :\\
{\tt L=[1,2,3,4]}\\
On tape :\\
{\tt L.shift(-2)}\\
On obtient la nouvelle valeur de {\tt L} :\\
{\tt [0,0,1,2]}\\
{\tt L.shift(-2)} est \'equivalent \`a {\tt L:=shift(L,-2)}\\
On tape :\\
{\tt L=[1,2,3,4]}\\
On tape :\\
{\tt L.shift(2)}\\
On obtient la nouvelle valeur de {\tt L} :\\
{\tt [3,4,0,0]}\\
{\tt L.shift(2)} est \'equivalent \`a {\tt L:=shift(L,2)}\\
\item {\tt L.suppress} 
On tape :\\
{\tt L=[1,2,3,4]}\\
On tape :\\
{\tt L.suppress(2)}\\
On obtient la nouvelle valeur de {\tt L} car les indices commencent par 0 :\\
{\tt [1,2,4]}\\
{\tt L.suppress(2)}  est \'equivalent \`a {\tt L:=suppress(L,2)}
\item {\tt L.reverse} 
On tape :\\
{\tt L=[1,2,3,4]}\\
On tape :\\
{\tt L.reverse()}\\
On obtient la nouvelle valeur de {\tt L} car les indices commencent par 0 :\\
{\tt [4,3,2,1]}\\

{\tt L.reverse()}  est \'equivalent \`a {\tt L:=reverse(L)}
\subsection{Les fonctions al\'eatoires compatibles avec le langage {\tt Python}}
Voici les générateurs pseudo-aléatoires les plus fréquents :
\begin{itemize}
\item {\tt random.random()} ou {\tt random()} ou {\tt rand()} renvoie un nombre 
r\'eel (pseudo)-al\'eatoire de l’intervalle semi-ouvert $[0,1[$.
\item {\tt random.choice(L)} ou {\tt random.random(L)} ou {\tt random(L)} 
renvoie un \'el\'ement tir\'e au sort parmi les \'el\'ements de la liste 
{\tt L}.
\item {\tt random.randint(a,b)} ou {\tt randint(a,b)} renvoie un nombre entier 
(pseudo)-al\'eatoire compris entre {\tt a} et {\tt b} (bornes incluses),\\
{\tt random.shuffle(L)} qui applique une permutation al\'eatoire \`a la liste 
{\tt L}.
\item {\tt random.shuffle(L)} ou {\tt shuffle(L)} qui applique une permutation 
al\'eatoire \`a la liste {\tt L}.
\item {\tt random.sample(L,n)} ou {\tt sample(L,n)} ou {\tt rand(n,L)} renvoie 
si {\tt n<=size(L)} {\tt n} \'el\'ements tir\'es sans
 remise et au hasard parmi les \'el\'ements de la liste {\tt L} et sinon renvoie
 une erreur.
On tape :
\begin{giaconload}
def testrand() :
  local L1,L2,L3,n1,n2,a1,a2;
  n1=random.random()
  n2=random()
  a1=random.randint(1,10)
  a2=randint(1,10)
  L1=sample([1,2,3,4,5,6],3)
  L2=random.sample([1,2,3,4,5,6],3)
  L3=shuffle([1,2,3,4,5,6])
  return n1,n2,a1,a2,L1,L2,L3 
\end{giaconload}
\giacinput{testrand()}
\end{itemize}
On tape :\\
{\tt testrand()}\\
On obtient par exemple :\\
{\tt 0.203235476278,0.6425425536,4,3,[1,3,6],[5,1,2],[5,6,1,2,3,4]}
\end{itemize}
\end{enumerate}
\section{Compatibilit\'e de {\tt Python} et de {\tt Python} avec {\tt Xcas}}
Voici les commandes qui se diff\'erencient  selon le langage utilis\'e :
 {\tt xcas} ou {\tt Python}.


\subsection{Les listes}\index{append}\index{prepend}\index{concat}\index{rotate}\index{shift}\index{suppress}\index{reverse}\index{revlist}
Avec {\tt Xcas}, voici les fonctions les plus fréquentes utilis\'ees avec les 
listes :

{\tt append}\\
{\tt append(L,a)} renvoie la liste o\`u l'\'el\'ement {\tt a} \`a \'et\'e
rajout\'e \`a la fin de la liste {\tt L}.\\
On tape :\\
\giacinput{append[1,2,3],4)}\\
\giacinput{L:=[1,2,3];append(L,4);L}\\
{\bf Attention}\\
Pour ajouter {\tt 4} \`a la fin de la liste {\tt L} on tape :\\
\giacinput{L:=[1,2,3];L:=append(L,4);L}\\
ou\\
\giacinput{L:=[1,2,3];L.append(4);L}

{\tt prepend}\\
{\tt prepend(L,a)} renvoie la liste o\`u l'\'el\'ement {\tt a} \`a \'et\'e
rajout\'e au d\'ebut de la liste {\tt L}.\\
On tape :\\
\giacinput{prepend([1,2,3],0)}\\
\giacinput{L:=[1,2,3];prepend(L,0);L}\\
{\bf Attention}\\
Pour ajouter {\tt 0} au d\'ebut de la liste {\tt L} on tape :\\
\giacinput{L:=[1,2,3]; L:=prepend(L,0);L}\\
ou\\
\giacinput{L:=[1,2,3]; L.prepend(0);L}\\

{\tt concat}\\
{\tt concat(L1,L2)} renvoie la concat\'enation des deux listes {\tt L1} et 
{\tt L2)}.\\
On tape :\\
\giacinput{ concat([1,2,3],[4,5,6,7])}\\
\giacinput{L:=[1,2,3];concat([L,[4,5,6,7]);L}\\
{\bf Attention}\\
Pour ajouter {\tt 4,5,6,7} \`a la fin de la liste {\tt L} on tape :\\
\giacinput{L:=[1,2,3];L:=concat(L,[4,5,6,7]);L}\\
ou\\
\giacinput{L:=[1,2,3];L.concat([4,5,6,7]);L}

{\tt rotate}\\
{\tt rotate(L)} (resp {\tt rotate(L,n)}) renvoie la liste obtenue en mettant le dernier \'el\'ement (resp la fin de la liste à partir du {\tt n}-i\`eme 
\'el\'ement) en premier (par d\'efaut n=-1).\\
On tape :\\
\giacinput{rotate([0,1,2,3])}\\
\giacinput{L:=[0,1,2,3];rotate(L)}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=rotate(L);L}\\
ou\\
\giacinput{L:=[0,1,2,3];L.rotate();L}\\
On tape :\\
\giacinput{rotate([0,1,2,3],2)}\\
\giacinput{ L:=[0,1,2,3];rotate(L,2);L}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=rotate(L,2);L}\\
ou\\
\giacinput{L:=[0,1,2,3]; L.rotate(2);L}

{\tt shift}\\
{\tt shift(L,n)} : si {\tt n>0} on remplace les {\tt n} premiers 
\'el\'ements de la liste par des {\tt 0} et on renvoie ces {\tt 0} \`a la fin de
la liste,\\
si {\tt n<0} renvoie la liste obtenue  en rempla\c{c}ant les 
{\tt -n} derniers \'el\'ements de la liste par {\tt 0} et on renvoie ces {\tt 0} au d\'ebut de la liste, puis on renvoie la liste ainsi obtenue.
(par défaut n=-1 ce qui signifie que le dernier \'el\'ement de la liste est 
supprim\'e et on met un {\tt 0} au d\'ebut de la liste).
On tape :\\
\giacinput{shift([1,2,3,4])}\\
\giacinput{L:=[0,1,2,3];shift(L)}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=shift(L);L}\\
ou\\
\giacinput{L:=[0,1,2,3];L.shift();L}
On tape :\\
\giacinput{shift([1,2,3,4],2)}\\
\giacinput{L:=[0,1,2,3];shift(L,2)}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=shift(L,2);L}\\
ou\\
\giacinput{L:=[0,1,2,3];L.shift(2);L}
On tape :\\
\giacinput{shift([1,2,3,4],-2)}\\
\giacinput{L:=[0,1,2,3];shift(L,-2)}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=shift(L,-2);L}\\
ou\\
\giacinput{L:=[0,1,2,3];L.shift(-2);L}

{\tt suppress}\\
{\tt suppress(L,n)} renvoie {\tt L} sans son \'el\'ement d'indice 
{\tt n}.\\
On tape (attention les indices commencent \`a 0) :\\
\giacinput{suppress([0,1,2,3],2)}\\
\giacinput{L:=[0,1,2,3];suppress(L,2)}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[0,1,2,3];L:=suppress(L,2);L}\\
ou\\
\giacinput{L:=[0,1,2,3];L.suppress(2);L}

{\tt reverse}\\
{\tt reverse(L)} ou {\tt revlist(L)} renvoie la liste {\tt L} invers\'ee.\\
On tape :\\
\giacinput{reverse([1,2,3])}\\
\giacinput{L:=[1,2,3];reverse(L)}\\
{\bf Attention}\\
Pour modifier le contenu de {\tt L}, on tape :\\
\giacinput{L:=[1,2,3];L:=reverse(L);L}\\
ou\\
\giacinput{L:=[1,2,3];L.reverse();L}\\

%\item {\tt Xcas} admet aussi les commandes du langage {\tt Python} sur les listes.\\


\subsection{Les fonctions al\'eatoires}\index{srand}\index{randseed}\index{RandSeed}\index{rand}\index{randint}\index{random}\index{choice}\index{shuffle}\index{sample}

Nous donnons ci-apr\`es les fonctions al\'eatoires les plus fr\'equentes : pour 
des raisons de compatibilité avec le langage {\tt Python} chacune des fonctions 
ci-dessous peuvent \^etre pr\'efix\'ee par {\tt random.} (par exemple on peut 
\'ecrire {\tt random.randint()} ou {\tt randint()})

{\tt srand randseed RandSeed}\\
{\tt srand} ou {\tt  randseed} initialise la suite des nombres al\'eatoires : 
{\tt srand}  ou {\tt  randseed}renvoie un entier qui a servi \`a cette 
initialisation.
On tape :\\
\giacinput{srand}

{\tt RandSeed}\\
{\tt RandSeed(n)} initialise les nombres al\'eatoires selon la valeur de 
l'entier {\tt n}
On tape :\\
\giacinput{RandSeed(321)}

{\tt random rand}\\
{\tt random()} ou {\tt rand()} renvoie un nombre r\'eel 
(pseudo)-al\'eatoire de l’intervalle semi-ouvert $[0,1[$.\\
On tape :\\
\giacinput{random()}

{\tt choice}\\
{\tt choice(L)} ou {\tt random(L)} ou {\tt rand(L)} renvoie un \'el\'ement
 tir\'e au hasard parmi les \'el\'ements de la liste {\tt L}.\\
On tape :\\
\giacinput{choice([1,2,3,4,5,6])}

{\tt randint}\\
{\tt randint(a,b)} renvoie un nombre entier (pseudo)-al\'eatoire 
compris entre {\tt a} et {\tt b} (bornes incluses).\\
On tape :\\
\giacinput{randint(1,10)}

{\tt shuffle}\\
{\tt shuffle(L)} applique une permutation al\'eatoire \`a la liste {\tt L}.\\
On tape :\\
\giacinput{shuffle([1,2,3,4,5,6])}

{\tt sample}\\
{\tt sample(L,n)} ou {\tt rand(n,L)} renvoie si {\tt n<=size(L)} {\tt n} 
\'el\'ements tir\'es au hasard et sans remise parmi les \'el\'ements de la 
liste {\tt L} et sinon renvoie une erreur. \\
On tape :\\
\giacinput{sample([1,2,3,4,5,6,7,8,9,10],3)}\\
{\bf Remarque} {\tt sample(L,len(L))} ou {\tt rand(size(L),L)} est identique 
\`a {\tt shuffle(L)}.

On tape :
\begin{giaconload}
def testrand() :
  local L1,L2,L3,n1,n2,a1,a2;
  n1=random.random()
  n2=random()
  a1=random.randint(1,10)
  a2=randint(1,10)
  L1=sample([1,2,3,4,5,6],3)
  L2=random.sample([1,2,3,4,5,6],3)
  L3=shuffle([1,2,3,4,5,6])
  return n1,n2,a1,a2,L1,L2,L3 
\end{giaconload}
\giacinput{testrand()}

\section{Compatibilit\'e de {\tt Python} et de {\tt Python} avec {\tt Xcas}}
Voici les commandes qui peuvent \^etre utilis\'ees dans {\tt Xcas} quelquesoit 
le langage de programmation choisi entre le langage {\tt xcas} et le langage 
{\tt Python}.
\subsection{D\'efinition d'une fonction sans lui donner un nom}\index{->}\index{lambda}
Avec {\tt Xcas}, on peut d\'efinir une fonction comme en Math\'ematiques sans 
avoir besoin de lui donner un nom.\\
\begin{enumerate}
\item langage {\tt xcas}\\
Par exemple pour d\'efinir la fonction $x->x^2+1$, on \'ecrit simplement :\\
{\tt x->x\verb|^|2+1}.\\
On tape :\\
{\tt  (x->x\verb|^|2+1)(5)}
ou on donne un nom \`a la fonction, on tape :\\
{\tt  f(x):=x\verb|^|2+1}\\
 puis, on tape :\\
{\tt f(5)}\\
On obtient :\\
{\tt 26}\\
\item langage {\tt Python}\\
Par exemple pour d\'efinir la fonction $x->x^2+1$, on \'ecrit :\\
{\tt lambda x  : x*x+1}.\\
Le logiciel {\tt Xcas} le traduit en $x->x^2+1$
On tape :\\
{\tt (lambda x  : x*x+1)(5)}\\
ou on donne un nom \`a la fonction, on tape :\\
{\tt  def f(x):}\\
$\quad ${\tt   return x*x+1}\\
 puis, on tape :\\
{\tt f(5)}\\
On obtient :\\
{\tt 26}\\
\end{enumerate}
{\bf Remarque : pas de risques de confusion !} \\
Si vous avez une variable {\tt lambda} qui est affect\'ee, l'\'ecriture :\\
{\tt (lambda x  : x*x+1)(5)}, ne modifie pas cette variable.\\
On tape pour d\'efinir la fonction {\tt lambda} :\\
{\tt lambda(x):=x+1}
On tape pour d\'efinir une fonction sans nom :\\
{\tt lambda x :=x*x+1}\\
{\tt (lambda x :=x*x+1)(5)} renvoie {\tt 26}\\
On a bien :\\
{\tt lambda(5)} renvoie {\tt 6}

===================================
===================================
def f(x):
    2*x+3

def testrand(NULL):
    # local L1,L2,L3,n1,n2,a1,a2
    n1=('random') . (random(NULL))
    n2=random(NULL)
    a1=('random') . (randint(1,10))
    a2=randint(1,10)
    L1=sample([1,2,3,4,5,6],3)
    L2=('random') . (sample([1,2,3,4,5,6],3))
    L3=shuffle([1,2,3,4,5,6])
    return(n1,n2,a1,a2,L1,L2,L3)

def f1(x):
    x^2+1

def f1(x):
    return(x^2+1)

def f2(x,y):
    x^2+y^2

def f2(x,y):
    x^2+y^2

def f(x,equal(y,1)):
    x^2+y^2

def f(x,equal(y,1)):
    x^2+y^2

def g(a,b):
    iquorem(a,b)

def g(a,b):
    return(iquorem(a,b))

def lambda(x):
    x+1

def Abs1(x):
    ((x>1)? x-2 : -x)

def Abs1(x):
    return(((x>1)? x-2 : -x))

def Delta(a,b,c):
    "Delta(a,b,c) calcule b^2-4ac"
    return(b^2-4*a*c)

def Delta(a,b,c):
    return(b^2-4*a*c)

def Abs(x):
    if x>0 :
        return(x)
    return(-x)

def h0(a,b):
    return(a/gcd(a,b),b/gcd(a,b))

def h(a,b):
    # local c
    c=gcd(a,b)
    return(a/c,b/c)

def Simpair(n):
    # local S,k
    S=0
    k=1
    while k<=n :
        S=S+2*k-1
        k=k+1
    return(S)

def Ticketcaisse(L):
    # local S,n,k
    n=dim(L)
    S=0
    k=0
    while k<=(n-2) :
        S=S+L[k]*L[k+1]
        k=k+2
    return(S)

def Prix(n,P):
    # local S
    if n>=3 :
        S=n*P*0.9
    else :
        S=n*P
    return(S)

def Ticketengros(L):
    # local S,n,k
    n=dim(L)
    S=0
    k=0
    while k<=(n-2) :
        S=S+Prix(L[k],L[k+1])
        k=k+2
    return(S)

def Somme(L):
    # local n,j,S
    n=dim(L)
    S=0
    j=0
    while j<=(n-1) :
        S=S+L[j]
        j=j+1
    return(S)

def Somme1(L):
    # local n,j,S
    n=dim(L)
    S=0
    j=0
    while j<=(n-1) :        
        S=S+L[j]
        j=j+1
    return(S)

def Somme2(L):
    # local n,j,S
    n=dim(L)
    j=0
    S=L[0]
    while j<(n-1) :        
        j=j+1
        S=S+L[j]
    return(S)

def Ticketfindemois(L,a):
    # local S,n,k,Lfin,La
    S=Somme(L)
    if S<=a :
        return(L,[],S)
    n=dim(L)
    k=0
    S=L[0]
    while S<=a :        
        k=k+1
        S=S+L[k]
    La=gauche(L,k)
    Lfin=droit(L,n-k)
    return(La,Lfin,S-(L[k]))

def Ticketfindemois1(L,a):
    # local S,n,k,Lfin,La
    S=Somme(L)
    if S<=a :
        return(L,[],S)
    n=dim(L)
    S=0
    k=0
    while S<=a :        
        S=S+L[k]
        k=k+1
    La=gauche(L,k-1)
    Lfin=droit(L,n-k+1)
    return(La,Lfin,S-(L[k-1]))

def Ticketfindemois2(L,a):
    # local S,n,k,La,Lfin,P
    n=dim(L)
    k=0
    S=L[0]
    while (S<=a) and (k<(n-1)) :        
        k=k+1
        S=S+L[k]
    if S<=a :
        return(L,[],S)
    La=gauche(L,k)
    Lfin=droit(L,n-k)
    P=S-(L[k])
    return(La,Lfin,P)

def Ticketfindemois3(L,a):
    # local k,n,S,La,Lfin
    n=dim(L)
    S=0
    k=0
    while k<=(n-1) :        
        if (S+L[k])>a :
            La=gauche(L,k)
            Lfin=droit(L,n-k)
            return(La,Lfin,S)
        S=S+L[k]
        k=k+1
    return(L,[],S)

def Ticketdimanche(L,a,r):
    # local S,n,k,Lfin,La
    n=dim(L)
    S=0
    k=0
    while (k<n) and (S<a) :        
        S=S+L[k]*L[k+1]
        k=k+2
    La=gauche(L,k)
    Lfin=droit(L,n-k)
    if S<a :
        r=0
    return(La,Lfin,S,S-r)

def Ticketdimanche1(L,a,r):
    # local S,n,k,Lfin,La
    n=dim(L)
    S=0
    k=0
    while k<=(n-1) :        
        S=S+L[k]*L[k+1]
        if S>=a :
            La=gauche(L,k+2)
            Lfin=droit(L,n-k-2)
            return(La,Lfin,S,S-r)
        k=k+2
    return(L,[],S,S)

def Ticketdimgros(L,a,r):
    # local S,n,k,Lfin,La
    n=dim(L)
    S=0
    k=0
    while (k<n) and (S<a) :        
        S=S+Prix(L[k],L[k+1])
        k=k+2
    La=gauche(L,k)
    Lfin=droit(L,n-k)
    if S<a :
        r=0
    return(La,Lfin,S,S-r)

def Ticketdimgros1(L,a,r):
    # local S,n,k,Lfin,La
    n=dim(L)
    S=0
    k=0
    while k<=(n-1) :        
        S=S+Prix(L[k],L[k+1])
        if S>=a :
            La=gauche(L,k+2)
            Lfin=droit(L,n-k-2)
            return(La,Lfin,S,S-r)
        k=k+2
    return(La,[],S,S)

def Graphe(f,a,b,n):
    # local L,h,k
    L=NULL
    h=(b-a)/n
    k=0
    while k<=(n-1) :        
        L=L,segment(point(a,f(a)),point(a+h,f(a+h)))
        a=a+h
        k=k+1
    return(L)

def f(x):
    x^2+1

def g(x):
    (x+1)/(x-1)

def Dichotomie0(f,a,b,n):
    # local c
    if (f(a)*f(b))>0 :
        return([])
    if ((f(a))==0) :
        return([a])
    if ((f(b))==0) :
        return([b])
    if (f(a))>0 :
        a,b=b,a
    while (abs(b-a))>(10^(-n)) :        
        c=evalf(a+b)/2
        if ((f(c))==0) :
            return([c])
        if (f(c))<0 :
            a=c
        else :
            b=c
    return([c])

def f(x):
    x^2-2

def g(x):
    cos(x)-x

def Dichotomie1(f,a,b,n):
    # local c,fc,eps
    if (f(a)*f(b))>0 :
        return([])
    if ((f(a))==0) :
        return([a])
    if ((f(b))==0) :
        return([b])
    if (f(a))>0 :
        a,b=b,a
    if n>12 :
        n=12
    eps=10^(-n)
    while (abs(b-a))>eps :        
        c=evalf(a+b)/2
        fc=f(c)
        if (fc==0) :
            return([c])
        if fc<0 :
            a=c
        else :
            b=c
    return([c])

def g(x):
    cos(x)-x

def Dichotomie(f,a,b,n):
    # local c,eps
    if (f(a)*f(b))>0 :
        return([])
    if (f(a))>0 :
        a,b=b,a
    if n>12 :
        n=12
    eps=10^(-n)
    while (abs(b-a))>eps :        
        c=evalf(a+b)/2
        if (f(c))<=0 :
            a=c
        else :
            b=c
    return([c])

def Dichotomie2(f,a,b,n):
    # local c,k,eps
    eps=10^(-n)
    if (f(a)*f(b))>0 :
        return([])
    k=1
    while k<=2100 :        
        c=(a+b)/2.0
        if (b-a)<eps :
            return([c])
        if (f(a)*f(c))<=0 :
            b=c
        else :
            a=c
        k=k+1
    return([c])

def g(x):
    cos(x)-x

def Dichotomie3(f,a,b,n):
    # local c,k,N
    if (f(a)*f(b))>0 :
        return([])
    N=ceil(ln((b-a)/10^(-n))/ln(2))
    if N>2100 :
        N=2100
    k=1
    while k<=N :        
        c=(a+b)/2.0
        if (f(a)*f(c))<=0 :
            b=c
        else :
            a=c
        k=k+1
    return([c])

def g(x):
    cos(x)-x

def Dichotomie4(f,a,b,n):
    # local c,k,N,fa,fb,fc
    fa=f(a)
    fb=f(b)
    if (fa*fb)>0 :
        return([])
    if (fa==0) :
        return([a])
    if (fb==0) :
        return([b])
    N=ceil(ln((b-a)/10^(-n))/ln(2))
    if N>2100 :
        N=2100
    k=1
    while k<=N :        
        c=(a+b)/2.0
        fc=f(c)
        if (fc==0) :
            return([c])
        if (fa*fc)<0 :
            b=c
        else :
            a=c
            fa=fc
        k=k+1
    return([c])

def g(x):
    cos(x)-x

def Dichotomie5(f,a,b,n):
    # local c,k,N
    if (f(a)*f(b))>0 :
        return([])
    N=ceil(ln(abs(b-a)/10^(-n))/ln(2))
    if N>2100 :
        N=2100
    if (f(a))>0 :
        a,b=b,a
    k=1
    while k<=N :        
        c=(a+b)/2.0
        if (f(c))<=0 :
            a=c
        else :
            b=c
        k=k+1
    return([c])

def g(x):
    cos(x)-x

def Solution12(Eq,Var):
    # local a,b,c,d
    Eq=normal(gauche(Eq)-droit(Eq))
    if ((degree(Eq,Var))==0) :
        if (Eq==0) :
            return("infinite de solution")
        else :
            return("pas de solution")
    if ((degree(Eq,Var))==1) :
        b=subst(Eq,equal(Var,0))
        a=subst(Eq,equal(Var,1))-b
        return(normal([(-b)/a]))
    if ((degree(Eq,Var))==2) :
        c=subst(Eq,equal(Var,0))
        d=subst(Eq,equal(Var,1))
        b=(d-subst(Eq,equal(Var,-1)))/2
        a=d-b-c
        d=b^2-4*a*c
        if d>0 :
            return(simplify([(-b+sqrt(d))/(2*a),(-b-(sqrt(d)))/(2*a)]))
        if (d==0) :
            return(simplify([(-b)/(2*a)]))
        return([])
    return("degree >2")

def Intersection1(Eq1,Eq2,Var1,Var2):
    # local a1,b1,c1,a2,b2,c2
    Eq1=normal(gauche(Eq1)-droit(Eq1))
    Eq2=normal(gauche(Eq2)-droit(Eq2))
    a1=coeff(Eq1,Var1,1)
    a2=coeff(Eq2,Var1,1)
    b1=coeff(Eq1,Var2,1)
    b2=coeff(Eq2,Var2,1)
    if ((normal(a1*b2-a2*b1))==0) :
        return("Cas non traite : Eq1 ou Eq2 n'est pas une  "+"equation de droite ou droites paralleles")
    c1=subst(Eq1,[Var1,Var2],[0,0])
    c2=subst(Eq2,[Var1,Var2],[0,0])
    print("droites concourantes")
    return([normal(((-b2)*c1+b1*c2)/(a1*b2-a2*b1)),normal((a2*c1-a1*c2)/(a1*b2-a2*b1))])

def Intersection2(Eq1,Eq2,Var1,Var2):
    # local a1,b1,c1,a2,b2,c2,d
    Eq1=normal(gauche(Eq1)-droit(Eq1))
    Eq2=normal(gauche(Eq2)-droit(Eq2))
    a1=coeff(Eq1,Var1,1)
    a2=coeff(Eq2,Var1,1)
    b1=coeff(Eq1,Var2,1)
    b2=coeff(Eq2,Var2,1)
    d=normal(a1*b2-a2*b1)
    if (d==0) :
        return("Cas non traite : Eq1 ou Eq2 n'est pas une"+" equation de droite ou droites paralleles ou confondues")
    c1=subst(Eq1,[Var1,Var2],[0,0])
    c2=subst(Eq2,[Var1,Var2],[0,0])
    print("droites concourantes")
    return([normal(((-b2)*c1+b1*c2)/d),normal((a2*c1-a1*c2)/d)])

def Intersection(Eq1,Eq2,Var1,Var2):
    # local a1,b1,c1,a2,b2,c2,d
    Eq1=normal(gauche(Eq1)-droit(Eq1))
    if ((degree(Eq1,Var1))>1) and ((degree(Eq1,Var2))>1) :
        return("pas de degre 1")
    Eq2=normal(gauche(Eq2)-droit(Eq2))
    if ((degree(Eq2,Var1))>1) and ((degree(Eq2,Var2))>1) :
        return("pas de degre 1")
    a1=coeff(Eq1,Var1,1)
    a2=coeff(Eq2,Var1,1)
    b1=coeff(Eq1,Var2,1)
    b2=coeff(Eq2,Var2,1)
    if ((([a1,b1])==[0,0])) or ((([a2,b2])==[0,0])) :
        return("Eq1 ou Eq2 est nulle")
    c1=subst(Eq1,[Var1,Var2],[0,0])
    c2=subst(Eq2,[Var1,Var2],[0,0])
    d=normal(a1*b2-a2*b1)
    if d<>0 :
        print("droites concourantes")
        return([normal(((-b2)*c1+b1*c2)/d),normal((a2*c1-a1*c2)/d)])
    if (a1<>0) and (a2<>0) :
        if ((c1*a2-c2*a1)==0) :
            print("droites confondues")
            return([normal((-c1)/a1),Var2])
        else :
            print("droites paralleles")
            return([])
    if (b1<>0) and (b2<>0) :
        if ((c1*b2)==(c2*b1)) :
            print("droites confondues")
            return([Var1,normal((-c1)/b1)])
        else :
            print("droites paralleles")
            return([])

def Isopolygonec(C,A,n):
    # local L,k
    L=NULL
    L=A
    k=0
    while k<=(n-1) :
        L=L,C+(A-C)*exp(2*i_i_*k*pi/n)
        k=k+1
    return(polygon(L))

def Isopolygonec(C,A,n):
    # local L,k
    L=NULL
    L=A
    k=0
    while k<=(n-1) :
        L=L,C+(A-C)*exp(2*i*k*pi/n)
        k=k+1
    return(polygon(L))

def Lunule1(NULL):
    # local A,B,C,L
    L=NULL
    A=point(0)
    B=point(2,equal('display',black))
    C=point(3*i_i_,equal('display',black))
    L=L,circle((A+C)/2,3/2,pi/2,3*pi/2,equal('display',3+filled))
    L=L,circle(A,B,-pi,0,equal('display',3+filled))
    L=L,circle(B,C,0,pi,equal('display',4+filled))
    L=L,triangle(A,B,C,equal('display',1+filled))
    return(L)

def Lunule1(NULL):
    # local A,B,C,L
    L=NULL
    A=point(0)
    B=point(2,equal('display',black))
    C=point(3*i,equal('display',black))
    L=L,circle((A+C)/2,3/2,pi/2,3*pi/2,equal('display',3+filled))
    L=L,circle(A,B,-pi,0,equal('display',3+filled))
    L=L,circle(B,C,0,pi,equal('display',4+filled))
    L=L,triangle(A,B,C,equal('display',1+filled))
    return(L)

def Lunule2(NULL):
    # local A,B,C,L
    L=NULL
    L=L,circle(point(2),2,(-pi)/2,pi/2,equal('display',1+filled))
    L=L,circle(point(2*i_i_),2,0,pi,equal('display',2+filled))
    L=L,circle(point(-2),2,pi/2,3*pi/2,equal('display',3+filled))
    L=L,circle(point(0,-2),2,pi,2*pi,equal('display',4+filled))
    L=L,circle(0,2*sqrt(2),equal('display',5+filled))
    L=L,circle(point(0,-2),2)
    L=L,circle(point(0,2),2)
    L=L,circle(point(2,0),2)
    L=L,circle(point(-2,0),2)
    L=L,square(-2-2*i_i_,2-2*i_i_)
    return(L)

def Lunule2(NULL):
    # local A,B,C,L
    L=NULL
    L=L,circle(point(2),2,(-pi)/2,pi/2,equal('display',1+filled))
    L=L,circle(point(2*i),2,0,pi,equal('display',2+filled))
    L=L,circle(point(-2),2,pi/2,3*pi/2,equal('display',3+filled))
    L=L,circle(point(0,-2),2,pi,2*pi,equal('display',4+filled))
    L=L,circle(0,2*sqrt(2),equal('display',5+filled))
    L=L,circle(point(0,-2),2)
    L=L,circle(point(0,2),2)
    L=L,circle(point(2,0),2)
    L=L,circle(point(-2,0),2)
    L=L,square(-2-2*i,2-2*i)
    return(L)

def Secteurcirc(O,r,t,a):
    # local A,B,L,xO,yO
    L=NULL
    [xO,yO]=coordinates(O)
    A=point(xO+r*cos(t),yO+r*sin(t))
    B=point(xO+r*cos(t+a),yO+r*sin(t+a))
    L=L,circle(O,r,t,t+a,equal('display',4+filled))
    L=L,triangle(O,A,B,equal('display',1+filled))
    return(L)

def Lunule3(NULL):
    # local A,B,C,D,L,xO,yO
    L=NULL
    A=point(-2)
    B=point(2,equal('display',black))
    C=point([0,2],equal('display',black))
    D=point(0,-2)
    L=L,display(circle(0,2,0,pi),1+filled)
    L=L,triangle(A,B,C,equal('display',4+filled))
    L=L,display(circle(D,2*sqrt(2),pi/4,3*pi/4),6+filled)
    L=L,triangle(A,B,D,equal('display',3+filled))
    return(L)

def Lunule4(NULL):
    # local A,B,C,D,I,J,L
    L=NULL
    A=point(-(sqrt(3.0)))
    B=point(sqrt(3.0))
    C=point(1,sqrt(2*sqrt(3.0)))
    D=point(-1,sqrt(2*sqrt(3.0)))
    I=point(0,sqrt(-3+2*sqrt(3.0))*sqrt(3.0))/3
    undef
    undef
    J=point(0,-(sqrt(3+2*sqrt(3.0))))
    L=L,display(circle(I,evalf(distance(A,I)),angle(I,I+2,B),2*pi+angle(I,I+2,A)),1+filled)
    L=L,triangle(A,B,C,equal('display',2+filled))
    L=L,triangle(A,C,D,equal('display',2+filled))
    L=L,display(circle(J,sqrt(6+2*sqrt(3.0)),angle(J,J+2,B),angle(J,J+2,A)),4+filled)
    L=L,display(triangle(J,A,B),3+filled)
    L=L,segment(D,I),segment(C,I),segment(A,C),segment(A,J),segment(J,B),segment(I,J)
    return(L)

def Longueur(cA,cB):
    # local xA,xB,yA,yB
    xA=cA[0]
    yA=cA[1]
    xB=cB[0]
    yB=cB[1]
    return(simplify(sqrt((xA-xB)^2+(yA-yB)^2)))

def Milieu(cA,cB):
    # local xA,xB,yA,yB
    xA=cA[0]
    yA=cA[1]
    xB=cB[0]
    yB=cB[1]
    return([(xA+xB)/2,(yA+yB)/2])

def Droite1(cA,cB):
    # local xA,xB,yA,yB
    xA=cA[0]
    yA=cA[1]
    xB=cB[0]
    yB=cB[1]
    return(equal(normal((xA-xB)*y-(yA-yB)*x-yB*xA+yA*xB),0))

def Droite2(cA,m):
    # local xA,yA
    xA=cA[0]
    yA=cA[1]
    return(equal(y-m*(x-xA)-yA,0))

def Droite(cA,equal(L,0)):
    # local xA,xB,yA,yB,m
    if ((type(cA))==expression) :
        return(cA)
    xA=cA[0]
    yA=cA[1]
    if ((type(L))=='vector') :
        xB=L[0]
        yB=L[1]
        return(equal(normal((xA-xB)*y-(yA-yB)*x-yB*xA+yA*xB),0))
    else :
        m=L
        return(equal(y-m*(x-xA)-yA,0))

def Coeffsdroite(Eq):
    # local a,b,c,d1,d2,eq
    eq=gauche(Eq)-droit(Eq)
    c=subst(eq,[x,y],[0,0])
    d1=subst(eq,[x,y],[1,0])
    d2=subst(eq,[x,y],[0,1])
    return(normal(d1-c,d2-c,c))

def Coeffdroite(Eq):
    # local a,b,c
    Eq=gauche(Eq)-droit(Eq)
    a=coeff(Eq,x,1)
    b=coeff(Eq,y,1)
    c=subst(Eq,equal([x,y],[0,0]))
    return(normal(a,b,c))

def Interdroite(d1,d2):
    # local a1,a2,b1,b2,c1,c2,gd1,gd2,d
    a1,b1,c1=Coeffsdroite(d1)
    a2,b2,c2=Coeffsdroite(d2)
    d=normal(a2*b1-b2*a1)
    if (d==0) :
        return([])
    return([(b2*c1-b1*c2)/d,(c2*a1-a2*c1)/d])

def Triangle(cA,cB,cC):
    return(polygon(cA,cB,cC))

def Quadrilatere(cA,cB,cC,cD):
    return(polygon(cA,cB,cC,cD))

def Vecteur(cA,cB):
    # local xA,xB,yA,yB
    xA=cA[0]
    yA=cA[1]
    xB=cB[0]
    yB=cB[1]
    return(normal([xB-xA,yB-yA]))

def Vecteur(cA,cB):
    normal(cB-cA)

def SumVect(cV1,cV2):
    # local x1,x2,y1,y2
    x1=cV1[0]
    y1=cV1[1]
    x2=cV2[0]
    y2=cV2[1]
    return(normal([x1+x2,y1+y2]))

def SumVect(cV1,cV2):
    normal(cV1+cV2)

def Translation(cA,cB,cC):
    cC+cB-cA

def Norme(cV):
    # local xV,yV
    xV=cV[0]
    yV=cV[1]
    return(sqrt(xV^2+yV^2))

def Changexy2XY(cM,cI,cU):
    # local xM,xI,xU,xV,yM,yI,yU,yV,l
    xM=cM[0]
    yM=cM[1]
    xI=cI[0]
    yI=cI[1]
    xU=cU[0]
    yU=cU[1]
    l=xU^2+yU^2
    if l<>1 :
        l=sqrt(l)
        xU=xU/l
        yU=yU/l
    xV=-yU
    yV=xU
    return(normal([(xM-xI)*xU+(yM-yI)*yU,(-(xM-xI))*yU+(yM-yI)*xU]))

def ChangeXY2xy(CM,cI,cU):
    # local XM,xI,xU,xV,YM,yI,yU,yV,l
    XM=CM[0]
    YM=CM[1]
    xI=cI[0]
    yI=cI[1]
    xU=cU[0]
    yU=cU[1]
    l=xU^2+yU^2
    if l<>1 :
        l=sqrt(l)
        xU=xU/l
        yU=yU/l
    xV=-yU
    yV=xU
    return(normal([xI+XM*xU+YM*xV,yI+XM*yU+YM*yV]))

def Coordequi(cA,cB):
    # local xA,yA,xB,yB,cU,l,CC
    xA=cA[0]
    yA=cA[1]
    xB=cB[0]
    yB=cB[1]
    l=sqrt((xB-xA)^2+(yB-yA)^2)
    cU=[(xB-xA)/l,(yB-yA)/l]
    CC=[l/2,l*(sqrt(3))/2]
    return(ChangeXY2xy(CC,cA,cU))

def Coordcarre(cA,cB):
    # local xA,yA,xB,yB,CC,CD,cU,l
    xA=cA[0]
    yA=cA[1]
    xB=cB[0]
    yB=cB[1]
    l=sqrt((xB-xA)^2+(yB-yA)^2)
    cU=[(xB-xA)/l,(yB-yA)/l]
    CC=[l,l]
    CD=[0,l]
    return(ChangeXY2xy(CC,cA,cU),ChangeXY2xy(CD,cA,cU))

def Cercle1(cA,r):
    # local xA,yA
    xA=cA[0]
    yA=cA[1]
    return([cA,r,equal(x^2+y^2-2*xA*x-2*yA*y+xA^2+yA^2-r^2,0)])

def Cercle2(cA,cB):
    # local xA,xB,xM,yA,yB,yM,M,r
    xA=cA[0]
    yA=cA[1]
    xB=cB[0]
    yB=cB[1]
    xM=cM[0]
    yM=cM[1]
    return([cM,r,equal(x^2+y^2-2*xM*x-2*yM*y+xM^2+yM^2-r^2,0)])

def Cercle(cA,L):
    # local cB,xA,xB,xM,yA,yB,yM,cM,r
    xA=cA[0]
    yA=cA[1]
    if ((type(L))=='vector') :
        xB=L[0]
        yB=L[1]
        cB=[xB,yB]
        cM=Milieu(cA,cB)
        xM=cM[0]
        yM=cM[1]
        r=(Longueur(cA,cB))/2
        return([cM,r,equal(x^2+y^2-2*xM*x-2*yM*y+xM^2+yM^2-r^2,0)])
    else :
        r=L
        return([cA,r,equal(x^2+y^2-2*xA*x-2*yA*y+xA^2+yA^2-r^2,0)])

def Centrerayon(Eq):
    # local k,a,b,c
    Eq=gauche(Eq)-droit(Eq)
    k=coeff(Eq,x,2)
    if k<>(coeff(Eq,y,2)) :
        return("ce n'est pas un cercle")
    Eq=Eq/k
    a=(-coeff(Eq,x,1))/2
    b=(-coeff(Eq,y,1))/2
    c=subst(Eq,[x,y],[0,0])
    return([a,b],normal(sqrt(a^2+b^2-c)))

def Tangent1(C,cA):
    # local I,r,m,xI,yI,xA,yA,cI
    cI=C[0]
    r=C[1]
    if (Longueur(cA,cI))<>r :
        return("A n'est pas sur C")
    xI=cI[0]
    yI=cI[1]
    xA=cA[0]
    yA=cA[1]
    if yA<>yI :
        m=(-(xA-xI))/(yA-yI)
        return(Droite(cA,m))
    return(equal(x,xA))

def Tangent(C,cA):
    # local cI,r,xI,yI,xA,yA,XM1,YM1,xM1,yM1,XM2,YM2,xM2,yM2,l
    cI=C[0]
    xI=cI[0]
    yI=cI[1]
    r=C[1]
    l=Longueur(cA,cI)
    xA=cA[0]
    yA=cA[1]
    if l<r :
        print("A n'est pas a l'exterieur de C")
        return([])
    if ((l==r)) and ((yA==yI)) :
        return([equal(x-xA,0)])
    if ((l==r)) and ((yA-yI)<>0) :
        return([normal(Droite([xA,yA],(-(xA-xI))/(yA-yI)))])
    XM1=r^2/l
    YM1=r*sqrt(1-r^2/l^2)
    xM1=normal(xI+(XM1*(xA-xI)-YM1*(yA-yI))/l)
    yM1=normal(yI+(XM1*(yA-yI)+YM1*(xA-xI))/l)
    XM2=r^2/l
    YM2=(-r)*sqrt(1-r^2/l^2)
    xM2=normal(xI+(XM2*(xA-xI)-YM2*(yA-yI))/l)
    yM2=normal(yI+(XM2*(yA-yI)+YM2*(xA-xI))/l)
    return([Droite([xM1,yM1],[xA,yA]),Droite([xM2,yM2],[xA,yA])])

def Tangentes(C,cA):
    # local cI,r,xI,yI,xA,yA,XA,CM1,CM2,cM1,cM2,cU
    cI,r=C
    xI,yI=cI
    xA,yA=cA
    XA=Longueur(cA,cI)
    cU=[xA-xI,yA-yI]/XA
    if XA>r :
        CM1=[r^2/XA,r*sqrt(1-r^2/XA^2)]
        CM2=[r^2/XA,(-r)*sqrt(1-r^2/XA^2)]
        cM1=ChangeXY2xy(CM1,cI,cU)
        cM2=ChangeXY2xy(CM2,cI,cU)
        return([Droite(cM1,[xA,yA]),Droite(cM2,[xA,yA])])
    if (XA==r) :
        CM1=[r,1]
        cM1=ChangeXY2xy(CM1,cI,cU)
        return([Droite(cM1,[xA,yA])])
    return([])

def Tangenteq(C,cA):
    # local cI,r,l,xI,yI,xA,yA,xK,yK,Eq,xM,yM,xM1,yM1,xM2,yM2,R,m
    cI=C[0]
    xI=cI[0]
    yI=cI[1]
    r=C[1]
    l=Longueur(cA,cI)
    xA=cA[0]
    yA=cA[1]
    R=l/2
    if l>r :
        xK=(xI+xA)/2
        yK=(yI+yA)/2
        if (yI-yA)<>0 :
            yM=(xK^2+yK^2+r^2-xI^2-yI^2-R^2+2*(xI-xK)*x)/(yA-yI)
            Eq=equal(x^2+yM^2-2*xI*x-2*yI*yM+xI^2+yI^2-r^2,0)
            [xM1,xM2]=Solution12(Eq,x)
            yM1=subst(yM,equal(x,xM1))
            yM2=subst(yM,equal(x,xM2))
        else :
            xM=(xK^2+yK^2+r^2-xI^2-yI^2-R^2+2*(yI-yK)*y)/(xA-xI)
            Eq=equal(xM^2+y^2-2*xI*xM-2*yI*y+xI^2+yI^2-r^2,0)
            [yM1,yM2]=Solution12(Eq,y)
            xM1=subst(xM,equal(y,yM1))
            xM2=subst(xM,equal(y,yM2))
        return([Droite(cA,[xM1,yM1]),Droite(cA,[xM2,yM2])])
    if (l==r) :
        if (yI-yA)<>0 :
            m=normal((-(xA-xI))/(yA-yI))
            return([Droite([xA,yA],m)])
        else :
            return([Droite([xA,yA],[xA,yA+1])])
    return([])

def Estaligne(cA,cB,cC):
    # local xA,yA,xB,yB,xC,yC
    if ((cA==cB)) and ((cA==cC)) :
        return(2)
    if ((cA==cB)) or ((cA==cC)) :
        return(1)
    xA=cA[0]
    yA=cA[1]
    xB=cB[0]
    yB=cB[1]
    xC=cC[0]
    yC=cC[1]
    if ((normal((xB-xA)*(yC-yA)-(xC-xA)*(yB-yA)))==0) :
        return(1)
    return(0)

def Estparallele(d1,d2):
    # local a1,a2,b1,b2,d,c1,c2
    a1,b1,c1=Coeffsdroite(d1)
    a2,b2,c2=Coeffsdroite(d2)
    d=normal(a2*b1-b2*a1)
    if (d==0) :
        return(1)
    return(0)

def Stats(L):
    # local j,Lj,n,s,s2
    n=dim(L)
    s=0
    s2=0
    j=0
    while j<=(n-1) :        
        Lj=L[j]
        s=s+Lj
        s2=s2+Lj^2
        j=j+1
    return(s/n,sqrt(s2/n-(s/n)^2))

def Median(L):
    # local n
    n=dim(L)
    L=sort(L)
    if ((irem(n,2))==1) :
        return(L[(n-1)/2])
    else :
        return((L[n/2-1]+L[n/2])/2.0)

def Statexo1(L):
    # local j,lj,n,n1,s,s2,vj,ej
    n=dim(L)
    if (type(n))<>'vector' :
        return("erreur")
    s=0
    s2=0
    n1=n[0]
    n=sum(col(L,1))
    j=0
    while j<=(n1-1) :        
        lj=L[j]
        vj=lj[0]
        ej=lj[1]
        s=s+vj*ej
        s2=s2+vj^2*ej
        j=j+1
    return(s/n,sqrt(s2/n-(s/n)^2))

def Statexo2(L1,L2):
    # local j,vj,ej,n,n1,n2,s,s2
    n1=dim(L1)
    n2=dim(L2)
    if n1<>n2 :
        return("erreur")
    n=sum(L2)
    s=0
    s2=0
    j=0
    while j<=(n1-1) :        
        vj=L1[j]
        ej=L2[j]
        s=s+vj*ej
        s2=s2+vj^2*ej
        j=j+1
    return(s/n,sqrt(s2/n-(s/n)^2))

def Simu(n,p):
    # local j,a,n1
    n1=0
    j=1
    while j<=n :        
        a=rand(0,1)
        if a<=p :
            n1=n1+1
        j=j+1
    return(n1/n)

def Fluctuat(N,n,p):
    # local j,L,out
    L=[]
    out=0
    j=0
    while j<=(N-1) :        
        L[j]=Simu(n,p)
        if (abs(L[j]-p))>(1/(sqrt(n))) :
            out=out+1
        j=j+1
    return(out/N,L)

def experience(NULL):
    # local a
    a=rand(6)+1
    return(piecewise(a<2,1,a<5,2,4))

def evolutionmoyenne1(N):
    # local l,s,j,a
    l=[]
    s=0
    j=1
    while j<=N :        
        s=s+experience()
        l=append(l,s/j)
        j=j+1
    return(l)

def evolutionmoyenne(experience,N):
    # local l,s,j,a
    l=[]
    s=0
    j=1
    while j<=N :        
        s=s+experience()
        l=append(l,s/j)
        j=j+1
    return(l)

def correct(a,b,c):
    ((a<(b+c)) and (b<(a+c))) and (c<(a+b))

def spag1(NULL):
    # local x,y,c
    x=rand(0,1)
    y=rand(0,1)
    if y>x :
        return(correct(x,y-x,1-y))
    else :
        return(correct(y,x-y,1-x))

def spagn(n):
    # local L,s
    L=[]
    s=0
    j=1
    while j<=n :        
        if spag1() :
            s++
        L=append(L,s/j)
        j=j+1
    return(L)

def spag1(NULL):
    # local x,y,c
    x=rand(0,1)
    if x>(1/2) :
        y=x
        x=x*rand(0,1)
    else :
        y=x+(1-x)*rand(0,1)
    return(correct(x,y-x,1-y))

def buffonpi(l):
    # local y,theta
    y=rand(0,1)
    theta=rand(-0.5,0.5)*pi
    if (floor(y+l*sin(theta)))<>0 :
        return(1)
    else :
        return(0)

def experience(NULL):
    buffonpi(0.7)

def experience(NULL):
    buffonpi(1)

def experience(NULL):
    buffonpi(2.5)

def buffonsanspi(l):
    # local y,X,Y
    y=rand(0,1)
    while 1 :        
        X=rand(0,1)
        Y=rand(0,1)
        if (X*X+Y*Y)<=1 :
            break
    if (floor(y+l*Y/(sqrt(X^2+Y^2))))<>0 :
        return(1)
    else :
        return(0)

def experience(NULL):
    buffonsanspi(0.7)

def buffon(l):
    (floor(rand(0,1)+l*sin(pi*rand(-0.5,0.5))))<>0

def experience(NULL):
    buffon(0.7)

def probabuffon(l,N):
    # local s,j
    s=0
    j=1
    while j<=N :
        s=s+buffonpi(l)
        j=j+1
    return(s/N)

def Buffon(l,N):
    1-count_eq(0,floor(randvector(N,'uniform',0,1)+l*sin(pi*randvector(N,'uniform',-0.5,0.5))))/N

def marche(n):
    # local j,x
    x=0
    j=1
    while j<=n :
        if ((rand(2))==1) :
            x++
        else :
            x--
        j=j+1
    return(x)

def retour(n):
    # local j,x,r
    x=0
    r=0
    j=1
    while j<=n :        
        if ((rand(2))==1) :
            x++
        else :
            x--
        if (x==0) :
            r++
        j=j+1
    return(r)

def experience(NULL):
    retour(100)

def moyenneretour1(n):
    # local s,j
    s=0
    j=1
    while j<=1000 :
        s=s+retour(n)
        j=j+1
    return(s/1000)

def moyenneretour(N,n):
    # local k,pos,r
    pos=seq(0,N)
    r=0
    n=iquo(n,2)
    k=1
    while k<=n :        
        pos=pos+randvector(N,2)+randvector(N,2)
        r=r+count_eq(k,pos)
        k=k+1
    return(r/N)

def polya(r,b,n):
    # local L,j
    L=[r/(r+b)]
    j=1
    while j<=n :        
        if (rand(r+b))<r :
            r++
        else :
            b++
        L[j]=r/(r+b)
        j=j+1
    return(L)

def polya1(r,b,n):
    # local j
    j=1
    while j<=n :
        if (rand(r+b))<r :
            r++
        else :
            b++
        j=j+1
    return(r/(r+b))

def polya2(r,b,n):
    # local j,total,totalalafin
    totalalafin=r+b+n-1
    total=r+b
    while total<=totalalafin :
        if (rand(total))<r :
            r++
        total=total+1
    return(r/(total-1))

def pgcd(a,b):
    while b<>0 :
        a,b=b,irem(a,b)
    return(a)

def base2(n):
    # local l
    l=[]
    while n>0 :        
        l=append(l,irem(n,2))
        n=iquo(n,2)
    return(revlist(l))

def base10(l):
    # local n,x
    n=0
    while x in l :
        equal(n,2*n+x)
    return(n)

def taille2(n):
    # local l
    l=0
    while n>0 :        
        n=iquo(n,2)
        l++
    return(l)

def estpremier(n):
    # local d
    if n<2 :
        return(false)
    d=2
    while (d*d)<=n :        
        if ((irem(n,d))==0) :
            return(false)
        d++
    return(true)

def facto(n):
    # local l,d
    l=[]
    d=2
    while (d*d)<=n :        
        while ((irem(n,d))==0) :            
            l=append(l,d)
            n=n/d
        d++
    if n>1 :
        l=append(l,n)
    return(l)

def facto1(n):
    # local l,d
    l=[]
    d=2
    while n>1 :        
        if ((irem(n,d))==0) :
            while ((irem(n,d))==0) :                
                l=append(l,d)
                n=n/d
        d++
    return(l)

def longueurcourbe(f,a,b,n):
    # local l,k,h
    h=evalf((b-a)/n)
    l=0
    k=0
    while k<=(n-1) :
        l=l+distance(point(a+k*h,f(a+k*h)),point(a+(k+1)*h,f(a+(k+1)*h)))
        k=k+1
    return(l)

def f(x):
    sqrt(1-x^2)

def longueurcourbe(f,a,b,n):
    # local l,k,h,x,M,N
    h=evalf((b-a)/n)
    l=0
    x=a
    M=point(x,f(x))
    k=0
    while k<=(n-1) :        
        x=x+h
        N=point(x,f(x))
        l=l+distance(M,N)
        M=N
        k=k+1
    return(l)

def f(x):
    sqrt(1-x^2)

def approxcourbe(f,a,b,n):
    # local L,k,h,x,M,N
    h=evalf((b-a)/n)
    x=a
    M=point(x,f(x))
    L=[M]
    k=0
    while k<=(n-1) :        
        x=x+h
        N=point(x,f(x))
        L=append(L,N)
        M=N
        k=k+1
    return(open_polygon(L))

def f(x):
    sqrt(1-x^2)

def minih(g,x,h):
    if (g(x-h))<(g(x)) :
        while (g(x-h))<(g(x)) :
            x=x-h
    else :
        while (g(x+h))<(g(x)) :
            x=x+h
    return(x)

def g(x):
    (x^2-2)^2

def minih(g,x,h,equal(N,1000)):
    # local j
    if (g(x-h))<(g(x)) :
        j=1
        while j<=N :            
            if (g(x-h))>(g(x)) :
                return(x)
            x=x-h
            j=j+1
    else :
        j=1
        while j<=N :            
            if (g(x+h))>(g(x)) :
                return(x)
            x=x+h
            j=j+1
    return("non trouve")

def mini(g,x,equal(h,0.1),equal(eps,1e-10)):
    while h>eps :        
        x=minih(g,x,h)
        h=h/10
    return(minih(g,x,h))

def g(x):
    (x^2-2)^2

def g(x):
    n1*distance(A,point(x,f(x)))+n2*distance(B,point(x,f(x)))

def refraction(f,A,B,n1,n2):
    # local g,x,tst
    if ((f(abscissa(A)))<(ordinate(A))) or ((f(abscissa(B)))>(ordinate(B))) :
        return("A et B sont du meme cote du graphe!")
    g(x)=n1*distance(A,point(x,f(x)))+n2*distance(B,point(x,f(x)))
    x=mini(g,abscissa(midpoint(A,B)))
    return(point(x,f(x)))

def f(x):
    1-2*x

def f(x):
    cos(5*x)

def refraction(f,A,B,n1,n2):
    # local g,M,x,tst,xM
    tst=(f(abscissa(A))-ordinate(A))*(f(abscissa(B))-ordinate(B))
    if tst>=0 :
        return("A et B sont du meme cote du graphe!")
    purge(x)
    M=point(x,f(x))
    g=unapply(n1*distance(A,M)+n2*distance(B,M),x)
    xM=mini(g,abscissa(midpoint(A,B)))
    return(point(xM,f(xM)))

def mini2(g,a,b,c,equal(eps,1e-10)):
    # local u,v
    if (c<=a) or (c>=b) :
        return("erreur")
    if ((g(c))>=(g(a))) or ((g(c))>=(g(b))) :
        return("erreur")
    while (b-a)>eps :        
        u=(a+c)/2
        if ((g(u))<(g(a))) and ((g(u))<(g(c))) :
            a,c,b=a,u,c
            continue
        v=(b+c)/2
        if ((g(v))<(g(c))) and ((g(v))<(g(b))) :
            a,c,b=c,v,b
            continue
        a,c,b=u,c,v
    return(a,b,c)

def trisolve(a,b,c):
    # local x,y
    x=(c^2+b^2-a^2)/(2*c)
    y=sqrt(b^2-x^2)
    return(point(0,0),point(c,0),point(x,y))

def Parfait(n):
    # local j,s
    "Parfait(n) renvoie vrai si n est la somme de ses diviseurs"
    s=0
    j=1
    while j<=(n-1) :
        if ((irem(n,j))==0) :
            s=s+j
        j=j+1
    if (s==n) :
        return(true)
    else :
        return(false)

def fibo(n):
    # local u,v,w,j
    equal(u,1)
    equal(v,1)
    if n<2 :
        return(1)
    equal(j,2)
    while j<=n :        
        equal(w,u+v)
        equal(u,v)
        equal(v,w)
        j++
    return(v)

%%%%%%%%%%%%%%%%
fonction Lnbpremier(bt,p)
  local L,k,n1,n2,n;
  L:=NULL;
  k:=bt;
  n:=p*bt;
  n1:=Nbpremiers(k);
  L:=L,n1;
  tantque k<n faire 
     k:=k+bt;
     n2:=Nbpremiers(k);
     L:=L,n2-n1;
     n1:=n2;
  ftantque;
  retourne [L];
  ffonction:;
def Lnbpremier(bt,p) :
  # local L,k,n1,n2,n
  L=range(1,1)
  k=bt
  n=p*bt
  n1=Nbpremiers(k)
  L.append(n1)
  while k<n : 
     k=k+bt
     n2=Nbpremiers(k)
     L.append(n2-n1)
     n1=n2
  return [L];
